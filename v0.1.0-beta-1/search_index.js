var documenterSearchIndex = {"docs":
[{"location":"ParameterEstimation/ParameterEstimationMisc/#Miscelaneous","page":"Miscelaneous","title":"Miscelaneous","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Public","page":"Miscelaneous","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Private","page":"Miscelaneous","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"Constraints/NetworkConstraints/#Network-constraints","page":"Network constraints","title":"Network constraints","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#Public","page":"Network constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BetweennessCentrality","page":"Network constraints","title":"PortfolioOptimiser.BetweennessCentrality","text":"@kwdef mutable struct BetweennessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BoruvkaTree","page":"Network constraints","title":"PortfolioOptimiser.BoruvkaTree","text":"@kwdef mutable struct BoruvkaTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.ClosenessCentrality","page":"Network constraints","title":"PortfolioOptimiser.ClosenessCentrality","text":"@kwdef mutable struct ClosenessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.DegreeCentrality","page":"Network constraints","title":"PortfolioOptimiser.DegreeCentrality","text":"@kwdef mutable struct DegreeCentrality{T1 <: Integer} <: CentralityType\n    type::T1 = 0\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.EigenvectorCentrality","page":"Network constraints","title":"PortfolioOptimiser.EigenvectorCentrality","text":"struct EigenvectorCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KatzCentrality","page":"Network constraints","title":"PortfolioOptimiser.KatzCentrality","text":"@kwdef mutable struct KatzCentrality{T1 <: Real} <: CentralityType\n    alpha::T1 = 0.3\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KruskalTree","page":"Network constraints","title":"PortfolioOptimiser.KruskalTree","text":"@kwdef mutable struct KruskalTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.MST","page":"Network constraints","title":"PortfolioOptimiser.MST","text":"@kwdef mutable struct MST{T1 <: Integer} <: NetworkType\n    tree::TreeType = KruskalTree()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.Pagerank","page":"Network constraints","title":"PortfolioOptimiser.Pagerank","text":"@kwdef mutable struct Pagerank{T1 <: Real, T2 <: Integer, T3 <: Real} <: CentralityType\n    alpha::T1 = 0.85\n    n::T2 = 100\n    epsilon::T3 = 1e-6\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.PrimTree","page":"Network constraints","title":"PortfolioOptimiser.PrimTree","text":"@kwdef mutable struct PrimTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.RadialityCentrality","page":"Network constraints","title":"PortfolioOptimiser.RadialityCentrality","text":"struct RadialityCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.StressCentrality","page":"Network constraints","title":"PortfolioOptimiser.StressCentrality","text":"@kwdef mutable struct StressCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TMFG","page":"Network constraints","title":"PortfolioOptimiser.TMFG","text":"@kwdef mutable struct TMFG{T1 <: Integer} <: NetworkType\n    similarity::DBHTSimilarity = DBHTMaxDist()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#Private","page":"Network constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.CentralityType","page":"Network constraints","title":"PortfolioOptimiser.CentralityType","text":"abstract type CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.NetworkType","page":"Network constraints","title":"PortfolioOptimiser.NetworkType","text":"abstract type NetworkType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TreeType","page":"Network constraints","title":"PortfolioOptimiser.TreeType","text":"abstract type TreeType end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/#Specifying-solvers","page":"Types","title":"Specifying solvers","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"Some risk measures require solvers to compute the risk measure via calc_risk. When using high level functions that take in an instance of Portfolio/HCPortfolio as an argument, the solvers will be taken from it. However, it is possible to override them by directly providing the solvers to the risk measure instance.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"The solvers can be specified by any container which implements the AbstractDict interfaces. This dictionary must contain the key-value pairs of any solvers one wishes to use. Where the key can be of any type, but the value must be a dictionary with the following key-value pairs.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":":solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\n:add_bridges: (optional) value of the add_bridges kwarg of JuMP.Model, if not provided defaults to true.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"using JuMP, Clarabel","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"solvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, model bridge argument, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false),\n                                 # (Optional) Flag for adding JuMP bridges to JuMP.Model()\n                                 # defaults to true (https://jump.dev/JuMP.jl/stable/api/JuMP/#Model).\n                                 :add_bridges => false))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"Users are able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"solvers = Dict(:Clarabel_1 => Dict(:solver => Clarabel.Optimizer,\n                                   :check_sol => (allow_local = true, allow_almost = true),\n                                   :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :Clarabel_2 => Dict(:solver => JuMP.optimizer_with_attributes(Clarabel.Optimizer,\n                                                                             \"max_step_fraction\" => 0.75),\n                                   # Do not add JuMP bridges to JuMP.Model()\n                                   :add_bridges => false))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"PortfolioOptimiser will iterate over the solvers until it finds the first one to successfully solve the problem. If a deterministic ordering is desired (for example when going from relaxed to strict tolerances), use an OrderedDict.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Abstract-types","page":"Types","title":"Abstract types","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"PortfolioOptimiser's risk measures are implemented using Julia's type hierarchy. This makes it easy to add new ones by implementing relevant types and methods.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"PortfolioOptimiser.AbstractRiskMeasure\nRiskMeasure\nHCRiskMeasure","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.AbstractRiskMeasure","page":"Types","title":"PortfolioOptimiser.AbstractRiskMeasure","text":"abstract type AbstractRiskMeasure end\n\nDescription\n\nServes as the foundational type for all risk measurement approaches in the library.\n\nSee also: RiskMeasure, HCRiskMeasure.\n\nType Hierarchy\n\nDirect subtypes: RiskMeasure, HCRiskMeasure.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RiskMeasure","page":"Types","title":"PortfolioOptimiser.RiskMeasure","text":"abstract type RiskMeasure <: AbstractRiskMeasure end\n\nDescription\n\nDefines the interface for risk measures that can be used in both Portfolio and HCPortfolio optimisation contexts.\n\nSee also: AbstractRiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, calc_risk, set_rm, OptimType, ObjectiveFunction.\n\nType Hierarchy\n\nImplementation Requirements\n\nTo ensure concrete subtypes will handle both Portfolio and HCPortfolio contexts appropriately, they must implement:\n\nRisk calculation method calc_risk.\nScalar JuMP model implementation, if appropriate a vector equivalent set_rm.\nInclude a settings::RMSettings = RMSettings() field for configuration purposes.\nIf the calc_risk involves solving a JuMP model:\nInclude a solvers::Union{Nothing, <:AbstractDict} field.\nImplement _set_rm_solvers! and _unset_rm_solvers!.\n\nExamples\n\nNo solvers\n\n# Creating a concrete risk measure that subtypes RiskMeasure\nstruct MyRisk <: RiskMeasure\n    settings::RMSettings\n    # implementation details\nend\n\n# Creating risk calculation method\nfunction PortfolioOptimiser.calc_risk(risk::MyRisk, w::AbstractVector; kwargs...)\n    # implementation details\nend\n\n# Creating a scalar JuMP model implementation\nfunction PortfolioOptimiser.set_rm(port::Portfolio, rm::MyRisk, type::OptimType,\n                                   obj::ObjectiveFunction; kwargs...)\n    # implementation details\nend\n\n# Creating a vector JuMP model implementation\nfunction PortfolioOptimiser.set_rm(port::Portfolio, rms::AbstractVector{<:MyRisk},\n                                   type::OptimType, obj::ObjectiveFunction; kwargs...)\n    # implementation details\nend\n\nSolvers\n\n# Creating a concrete risk measure that subtypes RiskMeasure\n# and uses solvers\nstruct MySolverRisk <: RiskMeasure\n    settings::RMSettings\n    solvers::Union{Nothing, <:AbstractDict}\n    # implementation details\nend\n\n# Creating risk calculation method\nfunction PortfolioOptimiser.calc_risk(risk::MySolverRisk, w::AbstractVector; kwargs...)\n    # implementation details\nend\n\n# Creating a scalar JuMP model implementation\nfunction PortfolioOptimiser.set_rm(port::Portfolio, rm::MySolverRisk, type::OptimType,\n                                   obj::ObjectiveFunction; kwargs...)\n    # implementation details\nend\n\n# Creating a vector JuMP model implementation\nfunction PortfolioOptimiser.set_rm(port::Portfolio, rms::AbstractVector{<:MySolverRisk},\n                                   type::OptimType, obj::ObjectiveFunction; kwargs...)\n    # implementation details\nend\n\nfunction PortfolioOptimiser._set_rm_solvers!(rm::MySolverRisk, solvers)\n    flag = false\n    if isnothing(rm.solvers) || isempty(rm.solvers)\n        rm.solvers = solvers\n        flag = true\n    end\n    return flag\nend\n\nfunction PortfolioOptimiser._unset_rm_solvers!(rm::MySolverRisk, flag)\n    if flag\n        rm.solvers = nothing\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRiskMeasure","page":"Types","title":"PortfolioOptimiser.HCRiskMeasure","text":"abstract type HCRiskMeasure <: AbstractRiskMeasure end\n\nDescription\n\nDefines the interface for risk measures specifically designed for use with HCPortfolio optimisation.\n\nSee also: AbstractRiskMeasure, HCRMSettings, Portfolio, HCPortfolio, optimise!, calc_risk.\n\nImplementation Requirements\n\nConcrete subtypes must implement:\n\nRisk calculation method calc_risk.\nInclude a settings::HCRMSettings = HCRMSettings() field for configuration purposes.\nIf the calc_risk involves solving a JuMP model:\nInclude a solvers::Union{Nothing, <:AbstractDict} field.\nImplement _set_rm_solvers! and _unset_rm_solvers!.\n\nExamples\n\nNo solvers\n\n# Creating a concrete risk measure that subtypes HCRiskMeasure\nstruct MyHCRisk <: HCRiskMeasure\n    settings::HCRMSettings\n    # implementation details\nend\n\n# Creating risk calculation method\nfunction PortfolioOptimiser.calc_risk(risk::MyHCRisk, w::AbstractVector; kwargs...)\n    # implementation details\nend\n\nSolvers\n\n# Creating a concrete risk measure that subtypes HCRiskMeasure\n# and uses solvers\nstruct MySolverHCRisk <: HCRiskMeasure\n    settings::HCRMSettings\n    solvers::Union{Nothing, <:AbstractDict}\n    # implementation details\nend\n\nfunction PortfolioOptimiser.calc_risk(risk::MySolverHCRisk, w::AbstractVector; kwargs...)\n    # implementation details\nend\n\nfunction PortfolioOptimiser._set_rm_solvers!(rm::MySolverHCRisk, solvers)\n    flag = false\n    if isnothing(rm.solvers) || isempty(rm.solvers)\n        rm.solvers = solvers\n        flag = true\n    end\n    return flag\nend\n\nfunction PortfolioOptimiser._unset_rm_solvers!(rm::MySolverHCRisk, flag)\n    if flag\n        rm.solvers = nothing\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Settings","page":"Types","title":"Settings","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"PortfolioOptimiser lets users provide multiple risk measures at the same time. They can be added to the risk expression in the optimisation objective, or used to set upper risk bounds. If multiple risk measures are to be used as part of the risk expression in the optimisation objective, it makes sense provide a way to scale each risk contribution in the objective, especially because different risk expressions may have different units, and therefore require appropriate scaling.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"Furthermore, certain risk measures make use of Ordered Weight Array formulations, for which there is an expensive exact formulation, and an approximate, tunable one. We let users decide which one to use, and if they want to use the approximate one they can tune it as they see fit.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"The following structures provide said functionality.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"RMSettings\nHCRMSettings\nOWASettings","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RMSettings","page":"Types","title":"PortfolioOptimiser.RMSettings","text":"mutable struct RMSettings{T1 <: Real, T2 <: Real}\n\nDescription\n\nConfiguration settings for RiskMeasure and HCRiskMeasure.\n\nSee also: AbstractRiskMeasure, RiskMeasure, HCRiskMeasure, Portfolio, HCPortfolio, optimise!, calc_risk, set_rm.\n\nFields\n\nflag::Bool = true: controls risk inclusion to the risk expression in the optimisation objective.\nscale::T1 = 1.0: risk measure scaling factor.\nub::T2 = Inf: upper bound risk constraint.\n\nBehaviour\n\noptimise!(::Portfolio)\n\nWith R(w) being a risk measure.\n\nWhen flag == true: adds scale * R(w) to the risk expression in the optimisation objective.\nscale: multiplier for this risk term in the risk expression.\nWhen ub < Inf: adds constraint R(w) ≤ ub.\n\noptimise!(::HCPortfolio)\n\nflag: no effect.\nscale: multiplier for this risk term in the risk expression. Always adds scale * R(w) to the risk expression in the optimisation objective.\nub: no effect.\n\nNotes\n\nscale: typically used when combining different risk measures in a single optimisation.\n\nExamples\n\n# Default settings\nsettings = RMSettings()\n\n# Risk-averse configuration, whatever risk measure this is applied \n# to will contribute 8 * risk to the risk expression\nsettings = RMSettings(; scale = 8.0)\n\n# Risk not added to the objective but constrainted\nsettings = RMSettings(; flag = false, ub = 0.25)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRMSettings","page":"Types","title":"PortfolioOptimiser.HCRMSettings","text":"mutable struct HCRMSettings{T1 <: Real}\n\nDescription\n\nConfiguration settings for HCRiskMeasure.\n\nSee also: AbstractRiskMeasure, HCRiskMeasure, HCPortfolio, optimise!, calc_risk.\n\nFields\n\nscale::T1 = 1.0: multiplier for this risk term in the risk expression.\n\nBehaviour\n\nWith R(w) being a risk measure.\n\nscale: multiplier for this risk term in the risk expression. Always adds scale * R(w) to the risk expression in the optimisation objective.\nDoes not include flag or bounds as hierarchical optimisations cannot constrain the risk, only the weights of the assets.\n\nNotes\n\nscale: typically used when combining different risk measures in a single optimisation.\n\nExamples\n\n# Default settings\nsettings = HCRMSettings()\n\n# Contribute more risk to the risk expression\nsettings = HCRMSettings(; scale = 2.5)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWASettings","page":"Types","title":"PortfolioOptimiser.OWASettings","text":"mutable struct OWASettings{T1 <: AbstractVector{<:Real}}\n\nDescription\n\nDefines the settings for Ordered Weight Array (OWA) risk measures.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm.\n\nFields\n\napprox::Bool = true: use the p-norm based approximation of the OWA risk measure optimisation.\np::T1 = Float64[2, 3, 4, 10, 50]: vector of the p-norm orders to be used in the approximation.\n\nBehaviour\n\np is only used when approx == true.\n\nExamples\n\n# Default settings\nowa = OWASettings()\n\n# Use full risk measure formulation\nowa = OWASettings(; approx = false)\n\n# Use more p-norms\nowa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128])\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Risk-measures","page":"Types","title":"Risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These risk measures are compatible with both Portfolio and HCPortfolio optimisations. Different risk measures account for different aspects of the returns.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Dispersion-risk-measures","page":"Types","title":"Dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Full-dispersion-risk-measures","page":"Types","title":"Full dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure how far the returns deviate from the mean in both the positive and negative directions.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"PortfolioOptimiser.SDFormulation\nPortfolioOptimiser.SDSquaredFormulation\nQuadSD\nSOCSD\nSimpleSD\nSD\nMAD\nKurt\nRG\nCVaRRG\nTGRG\nGMD\nSkew\nBDVariance","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SDFormulation","page":"Types","title":"PortfolioOptimiser.SDFormulation","text":"abstract type SDFormulation end\n\nDescription\n\nBase type for implementing various approaches to Mean-Variance and standard deviation calculation strategies in Portfolio optimisation, each offering different computational and numerical properties.\n\nSee also: SDSquaredFormulation, QuadSD, SOCSD, SimpleSD, SD.\n\nType Hierarchy\n\nDirect subtypes:\n\nSDSquaredFormulation: for quadratic expressions of the variance.\nSimpleSD: for direct standard deviation optimisation.\n\nBehaviour\n\nPortfolio Optimisation\n\nConcrete subtypes define how standard deviation/variance is represented in the JuMP model.\nChoice of formulation can significantly impact solver performance and numerical stability.\nEach formulation may have different solver compatibility requirements.\n\nHCPortfolio Optimisation\n\nNo effect.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SDSquaredFormulation","page":"Types","title":"PortfolioOptimiser.SDSquaredFormulation","text":"abstract type SDSquaredFormulation <: SDFormulation end\n\nDescription\n\nAbstract type for Mean-Variance formulations using quadratic variance expressions for Portfolio optimisations.\n\nThese formulations work with the variance form of risk:\n\nbeginalign\nsigma^2 = bmw^intercal mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw is the N×1 vector of portfolio weights.\nmathbfSigma is the N×N covariance matrix.\nsigma^2 is the portfolio variance.\n\nSee also: SDFormulation, QuadSD, SOCSD, SimpleSD, SD.\n\nType Hierarchy\n\nDirect subtypes:\n\nQuadSD: explicit quadratic formulation of the portfolio variance.\nSOCSD: second-Order Cone (SOC) formulation of the portfolio variance.\n\nBehaviour\n\nProduces a QuadExpr for sd_risk in the JuMP model.\nNot compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nMay have different numerical stability properties compared to direct SD formulations.\nRisk is expressed in terms of the variance (squared standard deviation).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.QuadSD","page":"Types","title":"PortfolioOptimiser.QuadSD","text":"struct QuadSD <: SDSquaredFormulation end\n\nDescription\n\nExplicit quadratic formulation for variance-based Portfolio optimisation.\n\nImplements the classical quadratic form of portfolio variance:\n\nbeginalign\nundersetbmwmathrmopt qquad sigma^2nonumber\ntextrmst qquad sigma^2 = bmw^intercal mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw is the N×1 vector of portfolio weights.\nmathbfSigma is the N×N covariance matrix.\nsigma^2 is the portfolio variance.\n\nSee also: SDFormulation, SDSquaredFormulation, SOCSD, SimpleSD, SD.\n\nBehaviour\n\nProduces a QuadExpr risk expression sd_risk = dot(w, sigma, w).\nNot compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nNo additional variables or constraints introduced.\nRequires a solver capable of handling quadratic objectives.\nPerformance may degrade for large portfolios.\n\nExamples\n\n# Using portfolio's built-in covariance\nsd_risk = SD(; formulation = QuadSD())\n\n# Custom configuration with specific covariance matrix\nmy_sigma = [1.0 0.2; 0.2 1.0]\nsd_risk = SD(; settings = RMSettings(; scale = 2.0), formulation = QuadSD(),\n             sigma = my_sigma)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SOCSD","page":"Types","title":"PortfolioOptimiser.SOCSD","text":"struct SOCSD <: SDSquaredFormulation end\n\nDescription\n\nSecond-Order Cone (SOC) formulation for variance-based Portfolio optimisation.\n\nReformulates the quadratic variance expression using second-order cone constraints:\n\nbeginalign\nundersetbmwmathrmopt qquad sigma^2nonumber\ntextrmst qquad leftlVert sqrtmathbfSigma bmw rightrVert_2 leq sigma\nendalign\n\nWhere:\n\nbmw is the N×1 vector of portfolio weights.\nmathbfSigma is the N×N covariance matrix.\nsigma^2 is the portfolio variance.\nlVert cdot rVert_2 is the L-2 norm.\n\nSee also: SDFormulation, SDSquaredFormulation, QuadSD, SimpleSD, SD.\n\nBehaviour\n\nUses SecondOrderCone constraints.\nDefines a standard deviation variable dev.\nProduces a QuadExpr risk expression sd_risk = dev^2.\nNot compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nOften more numerically stable than direct quadratic formulation.\nBetter scaling properties for large portfolios.\nCompatible with specialised conic solvers.\nMay introduce more variables but often leads to better solution times.\nParticularly effective for large-scale problems.\n\nExamples\n\n# Custom configuration with specific covariance matrix\n# Using portfolio's built-in covariance\nsd_risk = SD(; formulation = SOCSD())\n\nmy_sigma = [1.0 0.2; 0.2 1.0]\nsd_risk = SD(; settings = RMSettings(; scale = 2.0), formulation = SOCSD(),\n             sigma = my_sigma)\n\nSee also: SD, SDSquaredFormulation, QuadSD, SimpleSD.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SimpleSD","page":"Types","title":"PortfolioOptimiser.SimpleSD","text":"struct SimpleSD <: SDFormulation end\n\nDescription\n\nLinear standard deviation formulation using Second-Order Cone constraints for Portfolio optimisations.\n\nReformulates the affine standard deviation expression using second-order cone constraints:\n\nbeginalign\nundersetbmwmathrmopt qquad sigmanonumber\ntextrmst qquad leftlVert sqrtmathbfSigma bmw rightrVert_2 leq sigma\nendalign\n\nWhere:\n\nbmw is the N×1 vector of portfolio weights.\nmathbfSigma is the N×N covariance matrix.\nsigma is the portfolio standard deviation.\nlVert cdot rVert_2 is the L-2 norm.\n\nSee also: SDFormulation, SDSquaredFormulation, SOCSD, QuadSD, SD.\n\nBehaviour\n\nUses SecondOrderCone constraints.\nDefines a standard deviation variable dev.\nSets the AffExpr risk expression sd_risk = dev.\nCompatible with NOC (Near Optimal Centering) optimisations because AffExpr are strictly convex.\nDirect optimisation of standard deviation rather than variance.\nOften better numerical properties than squared formulations.\nCompatible with specialised conic solvers.\nMay provide more intuitive results as risk is in same units as returns.\n\nExamples\n\n# Using portfolio's built-in covariance\nsd_risk = SD(; formulation = SimpleSD())\n\n# Custom configuration with specific covariance matrix\nmy_sigma = [1.0 0.2; 0.2 1.0]\nsd_risk = SD(; settings = RMSettings(; scale = 2.0), formulation = SimpleSD(),\n             sigma = my_sigma)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SD","page":"Types","title":"PortfolioOptimiser.SD","text":"mutable struct SD <: RiskMeasure\n\nDescription\n\nMeasures the dispersion in the returns from the mean.\n\nSee also: RiskMeasure, RMSettings, SDFormulation, SDSquaredFormulation, SOCSD, QuadSD, SimpleSD, MAD, Portfolio, HCPortfolio, optimise!, set_rm, PortClass, calc_risk(::SD, ::AbstractVector), _SD.\n\nPortfolio\n\nImplements portfolio Standard Deviation/Variance risk using configurable formulation strategies.\n\nHCPortfolio\n\nImplements portfolio Standard Deviation risk.\n\nFields\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nformulation::SDFormulation = SOCSD(): strategy for standard deviation/variance calculation. Only affects Portfolio optimisations.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: optional covariance matrix.\n\nBehaviour\n\nCovariance Matrix Usage\n\nIf sigma is nothing:\nWith Portfolio: uses the covariance matrix cov, fm_cov, bl_cov or blfm_cov, depending on the class::PortClass parameter of optimise!.\nWith HCPortfolio: uses the covariance matrix cov.\nIf sigma provided: uses custom covariance matrix.\n\nValidation\n\nWhen setting sigma at construction or runtime, the matrix must be square (N×N).\n\nFormulation Impact on Portfolio Optimisation\n\nQuadSD: Direct quadratic implementation of variance, QuadExpr. Not compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nSOCSD: Second-order cone formulation of variance, QuadExpr. Not compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nSimpleSD: Standard deviation Second-order cone constraints, AffExpr. Compatible with NOC (Near Optimal Centering) optimisations because AffExpr are strictly convex.\n\nExamples\n\n# Default settings\nsd_risk = SD()\n\n# Custom configuration with specific covariance matrix\nmy_sigma = [1.0 0.2; 0.2 1.0]\nsd_risk = SD(; settings = RMSettings(; scale = 2.0), formulation = SOCSD(),\n             sigma = my_sigma)\n\n# Using portfolio's built-in covariance\nsd_risk = SD(; formulation = QuadSD(), sigma = nothing)\n\n# For an NOC optimisation\nsd_risk = SD(; formulation = SimpleSD())\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MAD","page":"Types","title":"PortfolioOptimiser.MAD","text":"mutable struct MAD <: RiskMeasure\n\nDescription\n\nMean Absolute Deviation risk measure implementation.\n\nMeasures the dispersion in the returns from the mean.\n\nSee also: RiskMeasure, RMSettings, SD, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::MAD, ::AbstractVector), _MAD.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nmu::Union{<:AbstractVector, Nothing} = nothing: optional N×1 vector of expected asset returns.\n\nBehaviour\n\nPortfolio Optimisation\n\nIf mu is nothing: use the expected returns vector from the Portfolio instance.\n\nHCPortfolio Optimisation or in calc_risk(::MAD, ::AbstractVector).\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nmad = MAD()\n\n# Custom configuration\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nmu = rand(10)             # Expected returns\nmad = MAD(; settings = RMSettings(; scale = 2.0), w = w, mu = mu)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Kurt","page":"Types","title":"PortfolioOptimiser.Kurt","text":"mutable struct Kurt <: RiskMeasure\n\nDescription\n\nSquare Root Kurtosis risk measure implementation for portfolio optimisation.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::Kurt, ::AbstractVector), _Kurt, SKurt.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nkt::Union{AbstractMatrix, Nothing} = nothing: optional cokurtosis matrix.\n\nBehaviour\n\nIf kt is nothing: uses the semi cokurtosis matrix skurt from the Portfolio/HCPortfolio object.\nIf kt provided: uses custom semi cokurtosis matrix.\n\nValidation\n\nWhen setting kt at construction or runtime, the matrix must be square (N²×N²).\n\nExamples\n\n# Default settings\nkurt = Kurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nkurt = Kurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nkurt = Kurt(; kt = nothing)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RG","page":"Types","title":"PortfolioOptimiser.RG","text":"mutable struct RG{T1 <: Real} <: RiskMeasure\n\nDescription\n\nDefines the Range risk measure.\n\nMeasures the best and worst returns, leftmathrmWR(bmX) mathrmWR(-bmX)right.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::RG, ::AbstractVector), _RG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nrg = RG()\n\n# Custom settings\nrg = RG(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaRRG","page":"Types","title":"PortfolioOptimiser.CVaRRG","text":"mutable struct CVaRRG{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nDefines the Conditional Value at Risk Range risk measure.\n\nMeasures the range between the expected loss in the worst alpha % of cases and expected gain in the best beta % of cases, leftmathrmCVaR(bmX alpha) mathrmCVaR(-bmX beta)right.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::CVaRRG, ::AbstractVector), _TGRG, CVaR, RG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level of losses, alpha ∈ (0, 1).\nalpha::T2 = 0.05: significance level of gains, beta ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting beta at construction or runtime, beta ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar = CVaRRG()\n\n# Custom significance level\ncdar = CVaRRG(; settings = RMSettings(; scale = 1.0), #\n              alpha = 0.01, # 1 % significance level losses \n              beta = 0.03)  # 3 % significance level gains\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TGRG","page":"Types","title":"PortfolioOptimiser.TGRG","text":"mutable struct TGRG{T1 <: Real, T2 <: Real, T3 <: Integer, T4 <: Real, T5 <: Real, T6 <: Integer} <: RiskMeasure\n\nDescription\n\nDefines the Tail Gini Difference Range risk measure.\n\nMeasures the range between the worst alpha % tail gini of cases and best beta % tail gini of cases, leftmathrmTG(bmX alpha) mathrmTG(-bmX beta)right.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::TGRG, ::AbstractVector), _TGRG, TG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i::T4 = 0.0001: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta::T5 = 0.05: end value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nb_sim::T6 = 100: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\nBehaviour\n\nValidation\n\nWhen setting alpha_i at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting alpha at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting a_sim at construction or runtime, a_sim > 0.\nWhen setting beta_i at construction or runtime, 0 < beta_i < beta < 1.\nWhen setting beta at construction or runtime, 0 < beta_i < beta < 1.\nWhen setting b_sim at construction or runtime, b_sim > 0.\n\nExamples\n\n# Default settings\nrtg = RTG()\n\n# Use full risk measure formulation with custom parameters\nrtg = RTG(; alpha = 0.07, b_sim = 200, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\nrtg = RTG(; settings = RMSettings(; flag = false, ub = 0.1),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.GMD","page":"Types","title":"PortfolioOptimiser.GMD","text":"struct GMD <: RiskMeasure\n\nDescription\n\nDefines the Gini Mean Difference risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::GMD, ::AbstractVector), _GMD.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\n\nExamples\n\n# Default settings\ngmd = GMD()\n\n# Use full risk measure formulation\ngmd = GMD(; owa = OWASettings(; approx = false))\n\n# Use more p-norms and custom settings\ngmd = GMD(; settings = RMSettings(; scale = 1.7),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Skew","page":"Types","title":"PortfolioOptimiser.Skew","text":"struct Skew <: RiskMeasure\n\nDescription\n\nDefine the Quadratic Skewness risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::Skew, ::AbstractVector), _Skew.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: optional N×N² custom coskewness matrix.\nV::Union{Nothing, <:AbstractMatrix}: optional Na×Na custom sum of the symmetric negative spectral slices of the coskewness.\n\nBehaviour\n\nCoskewness matrix usage\n\nIf skew is nothing:\nWith Portfolio/calc_risk: no effect.\nWith HCPortfolio: uses the portfolio coskewness matrix skew to generate the V matrix.\nIf skew provided:\nWith Portfolio/calc_risk: no effect.\nWith HCPortfolio: uses the custom coskew matrix to generate the V matrix.\n\nV matrix\n\nIf V is nothing:\nWith Portfolio/calc_risk: uses the portfolio V matrix.\nWith HCPortfolio: no effect.\nIf V provided:\nWith Portfolio/calc_risk: uses the custom V matrix.\nWith HCPortfolio: no effect.\n\nValidation\n\nWhen setting skew at construction or runtime, the matrix must have dimensions (N×N²).\nWhen setting V at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nskew = Skew()\n\n# Custom settings\nskew = Skew(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.BDVariance","page":"Types","title":"PortfolioOptimiser.BDVariance","text":"struct BDVariance <: RiskMeasure\n\nDescription\n\nDefine the Brownian Distance Variance risk measure.\n\nMeasures linear and non-linear relationships between variables.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::BDVariance, ::AbstractVector), _BDVariance.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\ndvar = BDVariance()\n\n# Custom settings\ndvar = BDVariance(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-dispersion-risk-measures","page":"Types","title":"Downside dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"SSD\nFLPM\nSLPM\nSKurt\nSSkew","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSD","page":"Types","title":"PortfolioOptimiser.SSD","text":"mutable struct SSD{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSemi Standard Deviation risk measure implementation.\n\nMeasures the standard deviation equal to or below the target return threshold.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::SSD, ::AbstractVector), _SSD.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nmu::Union{<:AbstractVector, Nothing} = nothing: optional N×1 vector of expected asset returns.\n\nBehaviour\n\nPortfolio Optimisation\n\nIf mu is nothing: use the expected returns vector from the Portfolio instance.\n\nHCPortfolio Optimisation or in calc_risk(::SSD, ::AbstractVector).\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nssd = SSD()\n\n# Custom configuration with specific target\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nmu = rand(10)             # Expected returns\nssd = SSD(; settings = RMSettings(; scale = 2.0), w = w, mu = mu)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.FLPM","page":"Types","title":"PortfolioOptimiser.FLPM","text":"mutable struct FLPM{T1 <: Real} <: RiskMeasure\n\nDescription\n\nFirst Lower Partial Moment (Omega ratio) risk measure.\n\nMeasures the dispersion equal to or below the target return threshold.\n\nSee also: RiskMeasure, RMSettings, SLPM, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::FLPM, ::AbstractVector), _FLPM.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\n\nExamples\n\n# Default settings\nflpm = FLPM()\n\n# Custom target return\nflpm = FLPM(; target = 0.01)  # 1 % minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SLPM","page":"Types","title":"PortfolioOptimiser.SLPM","text":"mutable struct SLPM{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSecond Lower Partial Moment (Sortino ratio) risk measure.\n\nMeasures the dispersion equal to or below the target return threshold.\n\nSee also: RiskMeasure, RMSettings, FLPM, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::SLPM, ::AbstractVector), _SLPM.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\n\nExamples\n\n# Default settings\nslpm = SLPM()\n\n# Custom settings\nslpm = SLPM(; settings = RMSettings(; scale = 2.0), target = 0.005)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SKurt","page":"Types","title":"PortfolioOptimiser.SKurt","text":"mutable struct SKurt{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSquare Root Semi Kurtosis risk measure implementation for portfolio optimisation.\n\nMeasures the kurtosis equal to or below the target return threshold.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::SKurt, ::AbstractVector), _SKurt, Kurt.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nkt::Union{AbstractMatrix, Nothing} = nothing: optional cokurtosis matrix.\n\nBehaviour\n\nIf kt is nothing: uses the cokurtosis from matrix skurt from the Portfolio/HCPortfolio object.\nIf kt provided: uses custom cokurtosis matrix.\n\nValidation\n\nWhen setting kt at construction or runtime, the matrix must be square (N²×N²).\n\nExamples\n\n# Default settings\nskurt = SKurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nskurt = SKurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nskurt = SKurt(; kt = nothing, target = 0.015) # 1.5% minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSkew","page":"Types","title":"PortfolioOptimiser.SSkew","text":"struct SSkew <: RiskMeasure\n\nDescription\n\nDefine the Quadratic Semi Skewness risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::SSkew, ::AbstractVector), _Skew.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: optional N×N² custom semi coskewness matrix.\nV::Union{Nothing, <:AbstractMatrix}: optional Na×Na custom sum of the symmetric negative spectral slices of the semi coskewness.\n\nBehaviour\n\nCoskewness matrix usage\n\nIf skew is nothing:\nWith Portfolio/calc_risk: no effect.\nWith HCPortfolio: uses the portfolio semi coskewness matrix sskew to generate the V matrix.\nIf skew provided:\nWith Portfolio/calc_risk: no effect.\nWith HCPortfolio: uses the custom semi coskew matrix to generate the V matrix.\n\nV matrix\n\nIf V is nothing:\nWith Portfolio/calc_risk: uses the portfolio SV matrix.\nWith HCPortfolio: no effect.\nIf V provided:\nWith Portfolio/calc_risk: uses the custom V matrix.\nWith HCPortfolio: no effect.\n\nValidation\n\nWhen setting skew at construction or runtime, the matrix must have dimensions (N×N²).\nWhen setting V at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nsskew = SSkew()\n\n# Custom settings\nsskew = SSkew(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-risk-measures","page":"Types","title":"Downside risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"WR\nCVaR\nEVaR\nRLVaR\nTG","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.WR","page":"Types","title":"PortfolioOptimiser.WR","text":"struct WR <: RiskMeasure\n\nDescription\n\nWorst Realization/Return risk measure.\n\nUseful for extremely conservative risk assessment.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::WR, ::AbstractVector), _WR, VaR, CVaR, EVaR, RLVaR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nwr = WR()\n\n# Custom settings\nwr = WR(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaR","page":"Types","title":"PortfolioOptimiser.CVaR","text":"mutable struct CVaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nConditional Value at Risk (Expected Shortfall) risk measure.\n\nMeasures expected loss in the worst alpha % of cases.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::CVaR, ::AbstractVector), _CVaR, VaR, EVaR, RLVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncvar = CVaR()\n\n# Custom significance level\ncvar = CVaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EVaR","page":"Types","title":"PortfolioOptimiser.EVaR","text":"mutable struct EVaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nEntropic Value at Risk risk measure.\n\nIt is the upper bound of the Chernoff inequality for the VaR and CVaR.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::EVaR, ::AbstractVector), _EVaR, VaR, CVaR, RLVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EVaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nevar = EVaR()\n\n# Custom configuration with specific solver\nevar = EVaR(; alpha = 0.025,  # 2.5 % significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLVaR","page":"Types","title":"PortfolioOptimiser.RLVaR","text":"mutable struct RLVaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Value at Risk risk measure.\n\nIt is a generalisation of the EVaR.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\nlimlimits_kappa to 0 mathrmRLVaR(bmX alpha kappa) approx mathrmEVaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLVaR(bmX alpha kappa) approx mathrmWR(bmX)\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::RLVaR, ::AbstractVector), _RLVaR, VaR, CVaR, EVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLVaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrlvar = RLVaR()\n\n# Custom configuration\nrlvar = RLVaR(; alpha = 0.07,   # 7 % significance level\n              kappa = 0.2,      # Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TG","page":"Types","title":"PortfolioOptimiser.TG","text":"mutable struct TG{T1 <: Real, T2 <: Real, T3 <: Integer} <: RiskMeasure\n\nDescription\n\nDefines the Tail Gini Difference risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::TG, ::AbstractVector), _TG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\nBehaviour\n\nValidation\n\nWhen setting alpha_i at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting alpha at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting a_sim at construction or runtime, a_sim > 0.\n\nExamples\n\n# Default settings\ntg = TG()\n\n# Use full risk measure formulation with custom parameters\ntg = TG(; alpha = 0.07, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\ntg = TG(; settings = RMSettings(; flag = false, ub = 0.1),\n        owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Drawdown-risk-measures","page":"Types","title":"Drawdown risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"MDD\nADD\nUCI\nCDaR\nEDaR\nRLDaR","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD","page":"Types","title":"PortfolioOptimiser.MDD","text":"struct MDD <: RiskMeasure\n\nDescription\n\nMaximum Drawdown (Calmar ratio) risk measure for uncompounded cumulative returns.\n\nMeasures the largest peak-to-trough decline.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::MDD, ::AbstractVector), _MDD, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nmdd = MDD()\n\n# Custom settings\nmdd = MDD(; settings = RMSettings(; scale = 2.0))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD","page":"Types","title":"PortfolioOptimiser.ADD","text":"struct ADD <: RiskMeasure\n\nDescription\n\nAverage Drawdown risk measure for uncompounded cumulative returns.\n\nMeasures the average of all peak-to-trough declines.\nProvides a more balanced view than the maximum drawdown MDD.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::ADD, ::AbstractVector), _ADD, ADD_r, MDD.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nadd = ADD()\n\n# Custom settings\nadd = ADD(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI","page":"Types","title":"PortfolioOptimiser.UCI","text":"mutable struct UCI <: RiskMeasure\n\nDescription\n\nUlcer Index risk measure for uncompounded cumulative returns.\n\nPenalizes larger drawdowns more than smaller ones.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::UCI, ::AbstractVector), _UCI, UCI_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nuci = UCI()\n\n# Custom settings\nuci = UCI(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR","page":"Types","title":"PortfolioOptimiser.CDaR","text":"mutable struct CDaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nConditional Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nMeasures the expected peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::CDaR, ::AbstractVector), _CDaR, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar = CDaR()\n\n# Custom significance level\ncdar = CDaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR","page":"Types","title":"PortfolioOptimiser.EDaR","text":"mutable struct EDaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nEntropic Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nIt is the upper bound of the Chernoff inequality for the DaR and CDaR.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::EDaR, ::AbstractVector), _EDaR, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EDaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nedar = EDaR()\n\n# Custom configuration with specific solver\nedar = EDaR(; alpha = 0.025,  # 2.5 % significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR","page":"Types","title":"PortfolioOptimiser.RLDaR","text":"mutable struct RLDaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nIt is a generalisation of the EDaR.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\nlimlimits_kappa to 0 mathrmRLDaR(bmX alpha kappa) approx mathrmEDaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR(bmX alpha kappa) approx mathrmMDD(bmX)\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::RLDaR, ::AbstractVector), _RLDaR, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLDaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05, # 5 % significance level\n              kappa = 0.3,    # 30 % Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Linear-moments-(L-moments)","page":"Types","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"This is used to measure linear moments of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"OWA","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWA","page":"Types","title":"PortfolioOptimiser.OWA","text":"mutable struct OWA <: RiskMeasure\n\nDescription\n\nDefines the generic Ordered Weight Array risk measure.\n\nUses a vector of ordered weights generated by owa_l_moment or owa_l_moment_crm for arbitrary L-moment optimisations.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, HCPortfolio, optimise!, set_rm, calc_risk(::OWA, ::AbstractVector), _OWA, owa_l_moment, owa_l_moment_crm.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nw::Union{<:AbstractWeights, Nothing} = nothing: T×1 ordered weight vector of arbitrary L-moments generated by owa_l_moment or owa_l_moment_crm.\n\nExamples\n\n# Default settings\nw = owa_l_moment_crm(10)\nowa = OWA(; w = w)\n\n# Use full risk measure formulation with custom parameters\nowa = OWA(; w = w, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\nowa = OWA(; w = w, settings = RMSettings(; flag = false, ub = 0.1),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Hierarchical-risk-measures","page":"Types","title":"Hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These risk measures are compatible with HCPortfolio. Different risk measures account for different aspects of the returns.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Dispersion-hierarchical-risk-measures","page":"Types","title":"Dispersion hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure the characteristics of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Full-dispersion-hierarchical-risk-measures","page":"Types","title":"Full dispersion hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure how far the returns deviate from the mean in both the positive and negative directions.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"Variance","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Variance","page":"Types","title":"PortfolioOptimiser.Variance","text":"mutable struct Variance{T1 <: Union{<:AbstractMatrix, Nothing}} <: HCRiskMeasure\n\nDescription\n\nDefines the Variance risk measure.\n\nSee also: HCRMSettings, HCPortfolio, optimise!, calc_risk(::Variance, ::AbstractVector), _Variance.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): hierarchical risk measure configuration settings.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: optional covariance matrix.\n\nBehaviour\n\nIf sigma is nothing: uses the covariance matrix cov from the HCPortfolio (or [Portfolio] when used in calc_risk) instance.\nIf sigma provided: uses custom covariance matrix.\n\nValidation\n\nWhen setting sigma at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nvariance = Variance()\n\n# Custom settings\nvariance = Variance(; settings = HCRMSettings(; scale = 3))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-dispersion-hierarchical-risk-measures","page":"Types","title":"Downside dispersion hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"SVariance","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SVariance","page":"Types","title":"PortfolioOptimiser.SVariance","text":"mutable struct SVariance{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Semi Variance risk measure.\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::SVariance, ::AbstractVector), _SVariance.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\n\nBehaviour\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nsvariance = SVariance()\n\n# Custom configuration with specific target\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nsvariance = SVariance(; target = 0.02,  # 2 % return target\n                      settings = HCRMSettings(; scale = 2.0), w = w)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-hierarchical-risk-measures","page":"Types","title":"Downside hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"VaR","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.VaR","page":"Types","title":"PortfolioOptimiser.VaR","text":"mutable struct VaR{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Value at Risk risk measure.\n\nMeasures lower bound of the losses in the worst alpha % of cases.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::VaR, ::AbstractVector), _VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nvar = VaR()\n\n# Custom significance level\nvar = VaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Drawdown-hierarchical-risk-measures","page":"Types","title":"Drawdown hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"DaR\nDaR_r\nMDD_r\nADD_r\nUCI_r\nCDaR_r\nEDaR_r\nRLDaR_r","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR","page":"Types","title":"PortfolioOptimiser.DaR","text":"mutable struct DaR{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for uncompounded cumulative returns risk measure.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::DaR, ::AbstractVector), _DaR, VaR, CVaR, EVaR, RLVaR WR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR()\n\n# Custom significance level\ndar = DaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR_r","page":"Types","title":"PortfolioOptimiser.DaR_r","text":"mutable struct DaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for compounded cumulative returns risk measure.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::DaR_r, ::AbstractVector), _DaR_r, VaR, CVaR, EVaR, RLVaR WR, DaR, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR_r()\n\n# Custom significance level\ndar = DaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD_r","page":"Types","title":"PortfolioOptimiser.MDD_r","text":"mutable struct MDD_r <: HCRiskMeasure\n\nDescription\n\nMaximum Drawdown (Calmar ratio) risk measure for compounded cumulative returns.\n\nMeasures the largest peak-to-trough decline.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::MDD_r, ::AbstractVector), _MDD_r, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nmdd = MDD_r()\n\n# Custom significance level\nmdd = MDD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD_r","page":"Types","title":"PortfolioOptimiser.ADD_r","text":"mutable struct ADD_r <: HCRiskMeasure\n\nDescription\n\nAverage Drawdown risk measure for uncompounded cumulative returns.\n\nMeasures the average of all peak-to-trough declines.\nProvides a more balanced view than the maximum drawdown MDD_r.\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, calc_risk(::ADD_r, ::AbstractVector), _ADD_r, ADD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nadd = ADD_r()\n\n# Custom significance level\nadd = ADD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI_r","page":"Types","title":"PortfolioOptimiser.UCI_r","text":"mutable struct UCI_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nUlcer Index risk measure for compounded cumulative returns.\n\nPenalizes larger drawdowns more than smaller ones.\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::UCI_r, ::AbstractVector), _UCI_r, UCI.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nuci_r = UCI_r()\n\n# Custom settings\nuci_r = UCI_r(; settings = HCRMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR_r","page":"Types","title":"PortfolioOptimiser.CDaR_r","text":"mutable struct CDaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nConditional Drawdown at Risk risk measure for compounded cumulative returns.\n\nMeasures the expected peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, HCPortfolio, optimise!, calc_risk(::CDaR_r, ::AbstractVector), _CDaR_r, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar_r = CDaR_r()\n\n# Custom significance level\ncdar_r = CDaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR_r","page":"Types","title":"PortfolioOptimiser.EDaR_r","text":"mutable struct EDaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nEntropic Drawdown at Risk risk measure for compounded cumulative returns.\n\nIt is the upper bound of the Chernoff inequality for the DaR and CDaR.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nSee also: HCRiskMeasure, HCRMSettings, Portfolio, HCPortfolio, optimise!, calc_risk(::EDaR_r, ::AbstractVector), _EDaR_r, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nedar_r = EDaR_r()\n\n# Custom configuration with specific solver\nedar_r = EDaR_r(; alpha = 0.025,  # 2.5 % significance level\n                solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR_r","page":"Types","title":"PortfolioOptimiser.RLDaR_r","text":"mutable struct RLDaR_r{T1 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Drawdown at Risk risk measure for compounded cumulative returns.\n\nIt is a generalisation of the EDaR.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\nlimlimits_kappa to 0 mathrmRLDaR_r(bmX alpha kappa) approx mathrmEDaR_r(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR_r(bmX alpha kappa) approx mathrmMDD_r(bmX)\n\nSee also: RiskMeasure, RMSettings, Portfolio, HCPortfolio, optimise!, calc_risk(::RLDaR_r, ::AbstractVector), _RLDaR_r, VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/HCPortfolio.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05, # 5 % significance level\n              kappa = 0.3,    # 30 % Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Equal-risk-contribution","page":"Types","title":"Equal risk contribution","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"This assumes the risk is equally distributed among the variables.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Types","title":"Types","text":"Equal","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Equal","page":"Types","title":"PortfolioOptimiser.Equal","text":"struct Equal <: HCRiskMeasure\n\nDescription\n\nEqual risk measure.\n\nRisk is allocated evenly among a group of assets.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nequal = Equal()\n\n# Custom configuration\nequal = Equal(; settings = HCRMSettings(; scale = 3))\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioRisk/#Risk","page":"Risk","title":"Risk","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/#Public","page":"Risk","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.calc_risk-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                         F::AbstractMatrix = port.f_returns,\n                         type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                         rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6)\n\nCompute the factor risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nw: Na×1 vector of asset weights.\nX: T×Na matrix of asset returns.\nF: T×Nf matrix of factor returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nOutputs\n\nrc_f: Nf×1 vector of risk contribution per factor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.number_effective_assets-Tuple{Any}","page":"Risk","title":"PortfolioOptimiser.number_effective_assets","text":"number_effective_assets(port; type::Symbol = isa(port, Portfolio) ? :Trad : :HRP)\n\nCompute the number of effective assets.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                  rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6,\n                  marginal::Bool = false)\n\nCompute the asset risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nmarginal:\nif true: compute the marginal risk contribution.\nelse: compute the risk by contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc: Na×1 vector of risk contribution per asset.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n             mu::AbstractVector = port.mu,\n             type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n             rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6, rf::Real = 0.0,\n             kelly::Bool = false)\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N matrix of asset returns.\nmu: N×1 vector of expected returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#Private","page":"Risk","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Constraints/ViewsConstraints/#Views-constraints","page":"Views constraints","title":"Views constraints","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/#Public","page":"Views constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.asset_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.asset_views","text":"asset_views(views::DataFrame, asset_sets::DataFrame)\n\nCreate the asset views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×9 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nType: (String) specifies the object(s) to which a view applies:\nAsset: specific asset.\nSubset: whole class.\nSet: (String) if Type is Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the view applies.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nReturn: (<:Real) the view's return.\nRelative_Type: (String) specifies to what the view is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative view.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nP: Nv×Na matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nviews = DataFrame(\"Enabled\" => [true, true, true, true, true],\n                  \"Type\" => [\"Asset\", \"Subset\", \"Subset\", \"Asset\", \"Subset\"],\n                  \"Set\" => [\"\", \"Class 2\", \"Class 1\", \"\", \"Class 1\"],\n                  \"Position\" => [\"WFC\", \"Financial\", \"Equity\", \"FB\", \"Fixed Income\"],\n                  \"Sign\" => [\"<=\", \">=\", \">=\", \">=\", \"<=\"],\n                  \"Return\" => [0.3, 0.1, 0.05, 0.03, 0.017],\n                  \"Relative_Type\" => [\"Asset\", \"Subset\", \"Asset\", \"\", \"\"],\n                  \"Relative_Set\" => [\"\", \"Class 1\", \"\", \"\", \"\"],\n                  \"Relative_Position\" => [\"FB\", \"Fixed Income\", \"TLT\", \"\", \"\"])\nP, Q = asset_views(views, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.factor_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.factor_views","text":"factor_views(views::DataFrame, loadings::DataFrame)\n\nCreate the factor views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×4 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nFactor: (String) name of the view's factor.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the view is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nP: Nv×Nf matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nviews = DataFrame(\"Enabled\" => [true, true, true], \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\"],\n                  \"Sign\" => [\"<=\", \"<=\", \">=\"], \"Value\" => [0.9, -1.2, 0.3],\n                  \"Relative_Factor\" => [\"USMV\", \"\", \"\"])\nP, Q = factor_views(views, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#Private","page":"Views constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"EditURL = \"../../../examples/2_asset_statistics.jl\"","category":"page"},{"location":"examples/2_asset_statistics/#Example-2:-Asset-statistics","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This example follows from Example 1. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This example focuses on the computation of asset statistics. This is one of the most important functions in PortfolioOptimiser. It can be used for computing any and all statistics needed to optimise Portfolio and HCPortfolio. It is also possible to define any and all statistics at variable instantiation, or by changing the relevant property in the Portfolio or HCPortfolio instance. Every case will perform validation checks.","category":"page"},{"location":"examples/2_asset_statistics/#2.1-Downloading-the-data","page":"Example 2: Asset statistics","title":"2.1 Downloading the data","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      SparseArrays\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/#2.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 2: Asset statistics","title":"2.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"portfolio = Portfolio(; prices = prices);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/#3-Asset-statistics","page":"Example 2: Asset statistics","title":"3 Asset statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"When you first create a Portfolio in this way, it does not contain any statistics other than the returns. So we must compute them.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"PortfolioOptimiser uses the StatsAPI.jl interfaces through StatsBase.jl. Meaning it is composable with other packages which use the common framework, and it also makes it easy for users to define their custom methods by using Julia's typesystem.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We'll only focus on the expected returns and covariance matrix. The default parameters are the arithmetic mean and sample covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"asset_statistics!(portfolio; set_kurt = false, set_skurt = false, set_skew = false,\n                  set_sskew = false);\n\n# Save these for later use.\nmu1 = copy(portfolio.mu);\ncov1 = copy(portfolio.cov);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We can prove this by computing the arithmetic mean and sample covariance of the returns.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"println(isapprox(mu1, vec(mean(portfolio.returns; dims = 1)))) # true\nprintln(isapprox(cov1, cov(portfolio.returns; dims = 1))) # true","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"These statistics are not very robust, so they're not very reliable. We can make them a bit better by using weights. First we need to explain the estimators.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.1-Mean-estimators","page":"Example 2: Asset statistics","title":"2.3.1 Mean estimators","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Lets start with the easier one, PortfolioOptimiser.MeanEstimator. There are four of these, MuSimple, MuJS, MuBS, MuBOP. As you can see, they are all subtypes of PortfolioOptimiser.MeanEstimator, we will use this later on to define our own method. Lets first focus on the first estimator, which is also the default.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We've already seen its default behaviour, we know from above it's the same as the arithmetic mean. But it can take a vector of AbstractWeights.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"First lets get the number of timestamps T, and number of assets N. We'll use T for defining our weights.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"T, N = size(portfolio.returns)","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"There are a variety of weights, but the only ones that make sense with no prior knowledge are exponential weights. Now lets use this to compute the asset expected returns vector, we do this by passing the argument mu_type = mu_type_1 to the function, we've also set the set_cov = false so it doesn't recompute the covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# Play around with the value of lambda (1/T, in the example) to see the effect\n# it has on the weights and computed expected returns vector.\nw = eweights(1:T, 1 / T; scale = true)\nmu_type_1 = MuSimple(; w = w)\nasset_statistics!(portfolio; mu_type = mu_type_1, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu2 = copy(portfolio.mu)\n\nprintln(isapprox(mu1, mu2)) # false","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The other three estimators included in PortfolioOptimiser require a target and a covariance matrix, since they use these to correct the estimate of the arithmetic mean. The available targets are GM, VW, SE, they all default to GM. They can also take an AbstractWeights, which they will use to compute the arithmetic mean that is then corrected with the target and covariane matrix. We'll try a few combinations.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The covariance matrix is not needed, if it is empty, it will be computed by asset_statistics! from the parameters given to it via cov_type even if set_cov = false, it just won't replace the old covariance matrix with the one that's been computed for the mean estimator, once the calculation is done, the sigma field of the estimator will be set to empty once more. If a covariance matrix is provided, then asset_statistics! will use this rather than computing one for it.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Feel free to mix and match, and to play around with various combinations.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"mu_type_2 = MuJS(; target = GM())\nasset_statistics!(portfolio; mu_type = mu_type_2, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu3 = copy(portfolio.mu)\n\nmu_type_3 = MuBS(; target = VW(), w = w)\nasset_statistics!(portfolio; mu_type = mu_type_3, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu4 = copy(portfolio.mu)\n\n# Using a custom covariance with random noise.\n# It's not guaranteed to be positive definite.\nnoise = randn(N, N) / N^2\nnoise = transpose(noise) * noise\nmu_type_4 = MuBOP(; target = SE(), sigma = cov1 + noise)\nasset_statistics!(portfolio; mu_type = mu_type_4, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu5 = copy(portfolio.mu);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"All targets subtype PortfolioOptimiser.MeanTarget. It is possible for users to define a one by creating a concrete subtype of PortfolioOptimiser.MeanTarget and defining a new target_mean for the custom target.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"struct CustomMeanTarget <: MeanTarget\n    ...\nend\nfunction target_mean(ct::CustomMeanTarget, mu::AbstractVector,\n                     sigma::AbstractMatrix, inv_sigma,\n                     T::Integer, N::Integer)\n    ...\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"However, this limits the target to using the same data as the current ones. It's easier to define a new concrete subtype of PortfolioOptimiser.MeanEstimator. We will do this in the following section.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.2-Defining-a-custom-mean-method","page":"Example 2: Asset statistics","title":"2.3.2 Defining a custom mean method","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"In order to define a new method all you need to do is create a new subtype of PortfolioOptimiser.MeanEstimator (it's not exported so it must be qualified) and define a new StatsBase.mean function.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This is all we need, we can now define a custom mean that is the same as the MuSimple, but scales the vector. You can scale the vector uniformly, by providing a scalar, or scale each item individually by providing an AbstractVector.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"mutable struct MyScaledMean{T1, T2} <: PortfolioOptimiser.MeanEstimator\n    scale::T1\n    w::T2\nend\nfunction MyScaledMean(; scale::Union{<:AbstractVector{<:Real}, Real} = 1, w = nothing)\n    return MyScaledMean{typeof(scale), typeof(w)}(scale, w)\nend\n\n# We have to turn this into a vec so we can scale by a vector.\nfunction StatsBase.mean(me::MyScaledMean, X::AbstractArray; dims::Int = 1)\n    return me.scale .*\n           vec((isnothing(me.w) ? mean(X; dims = dims) : mean(X, me.w; dims = dims)))\nend\n\nscale = 5\nmu_type_5 = MyScaledMean(; scale = scale)\nasset_statistics!(portfolio; mu_type = mu_type_5, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu6 = copy(portfolio.mu)\n# Should be a vector of 5's.\nprintln(mu6 ./ mu1)\n\nscale = 1:N\nmu_type_6 = MyScaledMean(; scale = scale)\nasset_statistics!(portfolio; mu_type = mu_type_6, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu7 = copy(portfolio.mu)\n# Should be a vector going from 1 to N.\nprintln(mu7 ./ mu1)","category":"page"},{"location":"examples/2_asset_statistics/#2.3.3-Covariance-estimators","page":"Example 2: Asset statistics","title":"2.3.3 Covariance estimators","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"PortfolioOptimiser comes with quite a few covariance estimators. However, it is best to wrap them all with PortCovCor. This is because it contains methods for denoising, fixing non-positive definite matrices, and using a graph-based algorithm for computing the covariance based on its relational structure.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Portfoliooptimiser's mean and covariance estimators are based on the idea of subtyping StatsBase.CovarianceEstimator to specialise their respective functions.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We will also not illustrate how to define custom methods as it follows the same principles as for the mean estimators, but instead by creating a concrete subtype (a struct) of StatsBase.CovarianceEstimator and implementing StatsBase.cov for the custom type.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"All estimators are different, some can nest other estimators, and those estimators may or may not support weights or even certain types of weights. There are so many different permutations that we will not go over an exhaustive list. For details on external methods please refer back to the documentation in their respective packages. For details on PortfolioOptimiser's estimators please refer to the docs.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"As far as my recommendation/preference, I like the CorGerberSB1 as it's fairly tuneable and produces less noisy matrices, but it is among the more expensive ones to compute.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# `corrected = true` does not support weights\nce0_a = StatsBase.SimpleCovariance(; corrected = false)\n\n# Method from [CovarianceEstimation.jl](https://github.com/mateuszbaran/CovarianceEstimation.jl),\n# does not support weights.\nce0_b = CovarianceEstimation.AnalyticalNonlinearShrinkage()\n\n# Exponential weights, try something else if you wish.\nw = eweights(1:T, 1 / sqrt(T); scale = true)\n\n# Risk free rate, we will use as the minimum acceptable return for the semi covariance.\nrf = 3.5 / 100 / 252","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Lets put our estimators in a vector to make programming easier.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces = CovarianceEstimator[]\n# Full covariance.\npush!(ces, CovFull(; ce = ce0_a, w = w))\n\n# Semi covariance, only focuses on variations that take\n# the returns below the target value.\npush!(ces, CovSemi(; ce = ce0_b, target = rf))\n\n# This bins the data and uses the information overlap between variables.\npush!(ces, CorMutualInfo())\n\n# This computes the distance covariance.\npush!(ces, CovDistance())\n\n# This uses how closely related the lower tail of the returns are between assets.\n# It combines the idea behind the Value at Risk and rank correlation.\npush!(ces, CorLTD())\n\n# The Gerber family of robust covariance estimators that count\n# co-movements and filters large and small movements by classifying\n# them into zones. They are a rank-based (counting) approach.\npush!(ces, CorGerber0())\npush!(ces, CorGerber1())\npush!(ces, CorGerber2())\n\n# Smyth-Broby family of covariance estimators that modifies the\n# Gerber statistics by scoring the quality of the classification\n# of co-movements (instead of adding 1 they add a score).\npush!(ces, CorSB0())\npush!(ces, CorSB1())\n\n# Smyth-Broby-Gerber family of covariance estimators that modifies\n# the Gerber statistics by counting co-movements, scoring them,\n# and then it multiplies the scores by the counts.\npush!(ces, CorGerberSB0())\npush!(ces, CorGerberSB1());\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We then instantiate some PortCovCor estimators and push them to a vector for convenience.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"pces = PortCovCor[]\nfor ce ∈ ces\n    push!(pces, PortCovCor(; ce = ce))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We can now call asset_statistics! with all these different estimators.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"covs = Matrix[]\nfor pce ∈ pces\n    asset_statistics!(portfolio; cov_type = pce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx 1 to 12, see how different the covariances look. What happens if you change some parameter in the covariance estimators? Are there methods that give you the most obvious ones? Try to see if you can spot patterns in the relationships between certain assets (ape together strong).","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We're showing the correlation matrix since it makes it easier to see the differences. We've set the colour limits to go from 0 to 1 clim = (0, 1), since all these assets appear to be postively correlated. Strictly speaking, only CorMutualInfo, CovDistance and CorLTD are guaranteed to be only positive. More information on all the methods is found in the docs.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:12\n   plot(cov2cor(covs[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/#2.3.4-Covariance-denoising","page":"Example 2: Asset statistics","title":"2.3.4 Covariance denoising","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Though the Gerber and its modified methods work well out of the box, other methods can benefit from extra processing. We'll use the default CovFull for this. First we will denoise it, for which we have three methods, DenoiseFixed, DenoiseSpectral, DenoiseShrink, which use fixed, spectral and shrink denoising methods described in [1, Chapter 2]. Each denoise method contains various tuning parameters. We will only explore the effects of detone and mkt_comp and leave the rest as defaults.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_denoise = PortCovCor[]\npush!(ces_denoise, PortCovCor(;))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseFixed()))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseSpectral()))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseShrink()))\ncovs_denoise = Matrix[]\nfor ce ∈ ces_denoise\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_denoise, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 4 to see how the matrix changes.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:4\n   plot(cov2cor(covs_denoise[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The market prices are not independent of each other, they are subject to market forces that affect all products. Hence why most assets have positive covariances with other assets. These market forces can wash out the true relationships between assets. To do this, we can detone the denoised matrix by removing the largest M eigenvalues. Typically, only the one largest is removed but we give the option for removing more. This operation however, can make the matrix singular. Which means it can't be used for mean variance optimisation, but can be more useful for clustering than a standard covariance. However, PortCovCor also contains an option for fixing non-positive definite correlation matrices, which may be able to make the detoned matrix non-singular. We will pass the argument posdef = NoPosdef() to ensure the matrices aren't fixed.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Although detoned matrices may be singular, and therefore unsuitable for traditional optimisation, they can be very useful in hierarchical optimisations since they remove market forces and thus only the true relationships between assets remain.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_detone = PortCovCor[]\npush!(ces_detone, PortCovCor(;))\n\n# `mkt_comp` defaults to 1 when `detone == true`, the value of `mkt_comp`\n# defines how many of the largest eigenvalues are removed from the denoised matrix.\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseFixed(; detone = true, mkt_comp = 1)))\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseSpectral(; detone = true, mkt_comp = 1)))\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseShrink(; detone = true, mkt_comp = 1)))\ncovs_detone = Matrix[]\nfor ce ∈ ces_detone\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_detone, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 4 to see how the matrix changes. Try commenting out posdef = NoPosdef() from the cell above and see how it changes the output of this cell.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:4\n   plot(cov2cor(covs_detone[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\n   println(\"idx = $idx, isposdef = $(isposdef(covs_detone[idx]))\")\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Denoising and detoning can be applied to any PortfolioOptimiser.PortfolioOptimiserCovCor method, but others already have contingencies for capturing true signals. Denoising has to be applied with care, otherwise you risk washing out true effects. Denoising and detoning can be quite powerful for clustering assets, since it can remove market noise as well as systemic market effects.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.5-LoGo-covariance","page":"Example 2: Asset statistics","title":"2.3.5 LoGo covariance","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The LoGo covariance uses graph theory to sparsify the inverse covariance matrix according to graph cliques and separators. This ensures only the strongest components of the realtionships are reflected in the covariance matrix. Although the inverse covariance is sparsified, the actual covariance is not, therefore it still encodes relationships between all assets.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The structure LoGo contains a distance and a similarity parameter, details can be found in its documentation. We will use the defaults, feel free to change them or create your by subtyping the relevant abstract types and defining the relevant methods.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_logo = PortCovCor[]\npush!(ces_logo, PortCovCor(;))\npush!(ces_logo, PortCovCor(; logo = LoGo(;)))\n\ncovs_logo = Matrix[]\nfor ce ∈ ces_logo\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_logo, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 2 to see how the matrix changes.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:2\n   plot(cov2cor(covs_logo[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The LoGo covariance algorithm computes the sparsified inverse covariance, which is inverted to recover the LoGo covariance. The inversion is numerical, so if we invert the covariance, we will get some very small, non-zero values. We remove them to show the sparsified inverse covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"J = covs_logo[2] \\ I\nJ[abs.(J) .<= 1e-10] .= zero(eltype(J))\nsparse(J)","category":"page"},{"location":"examples/2_asset_statistics/#Other-statistics","page":"Example 2: Asset statistics","title":"Other statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"There are other asset statistics that can be computed with asset_statistics!. However, they do not use anything that has not been covered in this tutorial. For further details refer to the docs of asset_statistics!.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"M. M. López de Prado. Machine Learning for Asset Managers. Elements in Quantitative Finance (Cambridge University Press, 2020).\n\n\n\nM. L. De Prado. Building diversified portfolios that outperform out of sample. The Journal of Portfolio Management 42, 59–69 (2016).\n\n\n\nA. Hacine-Gharbi, P. Ravier, R. Harba and T. Mohamadi. Low bias histogram-based estimation of mutual information for feature selection. Pattern Recognition Letters 33, 1302–1308 (2012).\n\n\n\nW.-M. Song, T. Di Matteo and T. Aste. Hierarchical information clustering by means of topologically embedded graphs. PloS one 7, e31929 (2012).\n\n\n\nW.-M. Song, T. . Matteo and T. Aste. Nested hierarchies in planar graphs. Discrete Applied Mathematics 159, 2135–2146 (2011).\n\n\n\nW. Barfuss, G. P. Massara, T. Di Matteo and T. Aste. Parsimonious modeling with information filtering networks. Phys. Rev. E 94, 062306 (2016).\n\n\n\nG. P. Massara, T. Di Matteo and T. Aste. Network Filtering for Big Data: Triangulated Maximally Filtered Graph. Journal of Complex Networks 5, 161–178 (2016), arXiv:https://academic.oup.com/comnet/article-pdf/5/2/161/13794756/cnw015.pdf.\n\n\n\nT. Bodnar, O. Okhrin and N. Parolya. Optimal shrinkage estimator for high-dimensional mean vector. Journal of Multivariate Analysis 170, 63–79 (2019).\n\n\n\nP. Jorion. Bayes-Stein Estimation for Portfolio Analysis. The Journal of Financial and Quantitative Analysis 21, 279–292 (1986). Accessed on Mar 1, 2024.\n\n\n\nA. Meucci. Risk and asset allocation. Vol. 1 (Springer, 2005).\n\n\n\nY. Feng and D. P. Palomar. A Signal Processing Perspective on Financial Engineering. Foundations and Trends® in Signal Processing 9, 1–231 (2016).\n\n\n\nD. Cajas. Higher Order Moment Portfolio Optimization with L-Moments. Available at SSRN 4393155 (2023).\n\n\n\n","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Risk-measures","page":"Risk measures","title":"Risk measures","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#Public","page":"Risk measures","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Private","page":"Risk measures","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#PortfolioOptimiser.set_rm-Tuple{Portfolio, SD, Union{RP, Trad}, Any}","page":"Risk measures","title":"PortfolioOptimiser.set_rm","text":"set_rm(port::Portfolio, rm::SD, type::Union{Trad, RP}, obj;\n            sigma::AbstractMatrix{<:Real},\n            kelly_approx_idx::Union{AbstractVector{<:Integer}, Nothing}, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Matrix-denoising","page":"Matrix denoising","title":"Matrix denoising","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#Public","page":"Matrix denoising","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseFixed","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseFixed","text":"@kwdef mutable struct DenoiseFixed{T1, T2, T3, T4} <: Denoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the fixed method in denoise! [1, Chapter 2]. This method performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to their average, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: remove the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to remove from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseShrink","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseShrink","text":"@kwdef mutable struct DenoiseShrink{T1, T2, T3, T4, T5} <: Denoise\n    alpha::Real = 0.0\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the shrink method in denoise! [1, Chapter 2]. This method shrinks the covariance to a target of unequal variance of the matrix reconstructed with the eigenvalues that are below the noise significance value. The degree of shrinkage is parametrised by alpha.\n\nbeginalign\nmathbfC = mathbfC_u + alpha mathbfC_l + (1 - alpha) mathrmDiag(mathbfC)\nmathbfC_u = mathbfE_u mathbflambda_u mathbfE_u^intercal\nmathbfC_l = mathbfE_l mathbflambda_l mathbfE_l^intercal\nendalign\n\nWhere:\n\nmathbfC is the denoised correlation matrix.\nmathbfC_u is the reconstructed correlation matrix out of the eigenvalues that are above the noise significance threshold, and their corresponding eigenvectors.\nmathbfC_l is the reconstructed correlation matrix out of the eigenvalues that are below the noise significance threshold, and their corresponding eigenvectors.\nmathbfE_u are the eigenvectors corresponding to the eigenvalues that are above the noise significance threshold.\nmathbflambda_u is the diagonal matrix of eigenvalues that are above the noise significance threshold.\nmathbfE_l are the eigenvectors corresponding to the eigenvalues that are below the noise significance threshold.\nmathbflambda_l is the diagonal matrix of eigenvalues that are below the noise significance threshold.\n\nParameters\n\nalpha: tuning parameter for how much the matrix should be shrunk, alpha ∈ [0, 1].\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseSpectral","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseSpectral","text":"@kwdef mutable struct DenoiseSpectral{T1, T2, T3, T4} <: Denoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the spectral method in denoise! [1, Chapter 2]. This method performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to zero, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.NoDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.NoDenoise","text":"struct NoDenoise <: Denoise end\n\nApply no denoising in denoise!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.denoise!-Tuple{PortfolioOptimiser.Denoise, PortfolioOptimiser.PosdefFix, AbstractMatrix, Real}","page":"Matrix denoising","title":"PortfolioOptimiser.denoise!","text":"denoise!(ce::Denoise, posdef::PosdefFix, X::AbstractMatrix, q::Real)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Private","page":"Matrix denoising","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.Denoise","page":"Matrix denoising","title":"PortfolioOptimiser.Denoise","text":"abstract type Denoise end\n\nAbstract type for subtyping denoising methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#Ordered-Weight-Arrays","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#Public","page":"Ordered Weight Arrays","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.CRRA","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.CRRA","text":"@kwdef mutable struct CRRA{T1 <: Real} <: OWAMethods\n    g::T1 = 0.5\nend\n\nNormalised Constant Relative Risk Aversion Coefficients.\n\nParameters\n\ng: Risk aversion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MaxEntropy","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MaxEntropy","text":"@kwdef mutable struct MaxEntropy{T1 <: Real, T2 <: AbstractDict} <: OWAMethods\n    max_phi::T1 = 0.5\n    solvers::T2 = Dict()\nend\n\nMaximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSqDist","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSqDist","text":"@kwdef mutable struct MinSqDist{T1 <: Real} <: OWAMethods\n    max_phi::T1 = 0.5\nend\n\nMinimum Square Distance. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSumSq","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSumSq","text":"@kwdef mutable struct MinSumSq{T1 <: Real} <: OWAMethods\n    max_phi::T1 = 0.5\nend\n\nMinimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_cvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_cvar","text":"owa_cvar(T::Integer; alpha::Real = 0.05)\n\nCalculate the OWA weights corresponding to the Critical Value at Risk (CVaR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_gmd-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_gmd","text":"owa_gmd(T::Integer)\n\nComputes the Gini Mean Difference (GMD) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n[OWA]: Cajas, Dany, OWA Portfolio Optimization: A Disciplined Convex Programming Framework (December 18, 2021). Available at SSRN: https://ssrn.com/abstract=3988927 or http://dx.doi.org/10.2139/ssrn.3988927\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment","text":"owa_l_moment(T::Integer; k::Integer = 2)\n\nCalculates the OWA weights of the k'th linear moment (L-moment) of a returns series [12].\n\nInputs\n\nk: order of the L-moment.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment_crm-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment_crm","text":"owa_l_moment_crm(T::Integer; k::Integer = 2, method::Symbol = :SD, g::Real = 0.5,\n                 max_phi::Real = 0.5, solvers = Dict())\n\nCompute the OWA weights for the convex risk measure considering higher order L-moments [12].\n\nInputs\n\nk: order of the L-moment, k ≥ 2.\nmethod: method for computing the weights used to combine L-moments higher than 2, used in OWAMethods.\n:CRRA: Normalised Constant Relative Risk Aversion Coefficients.\n:E: Maximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n:SS: Minimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n:SD: Minimum Square Distance. Solver must support MOI.SecondOrderCone.\ng: the risk aversion coefficient.\nmax_phi: maximum weight constraint of the L-moments.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rcvar-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rcvar","text":"owa_rcvar(T::Integer; alpha::Real = 0.05, beta::Real = alpha)\n\nCompute the OWA weights for the CVaR Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rg","text":"owa_rg(T::Integer)\n\nCompute the OWA weights for the Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rtg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rtg","text":"owa_rtg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100,\n        beta_i::Real = alpha_i, beta::Real = alpha, b_sim::Integer = a_sim)\n\nCompute the OWA weights for the Tail Gini Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rwcvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rwcvar","text":"owa_rwcvar(T::Integer, alphas::AbstractVector{<:Real}, weights_a::AbstractVector{<:Real};\n           betas::AbstractVector{<:Real} = alphas,\n           weights_b::AbstractVector{<:Real} = weights_b)\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of the losses for each CVaR model, where N is the number of losses models, each .\nweights_a: N×1 vector of weights of the losses for each CVaR model, where N is the number of losses models.\nbetas: M×1 vector of significance levels of the gains for each CVaR model, where M is the number of gains models, each .\nweights_b: M×1 vector of weights of the gains for each CVaR model, where M is the number of gains models.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_tg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_tg","text":"owa_tg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100)\n\nCompute the OWA weights for the Tail Gini of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wcvar-Tuple{Integer, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wcvar","text":"owa_wcvar(T::Integer, alphas::AbstractVector{<:Real}, weights::AbstractVector{<:Real})\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of each CVaR model, where N is the number of models, each .\nweights: N×1 vector of weights of each CVaR model, where N is the number of models.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wr-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wr","text":"owa_wr(T::Integer)\n\nCompute the OWA weights for the Worst Realisation (WR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#Private","page":"Ordered Weight Arrays","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.OWAMethods","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.OWAMethods","text":"abstract type OWAMethods end\n\nAbstract type for subtyping Ordered Weight Array (OWA) methods for computing the weights used to combine L-moments higher than 2 [12] in owa_l_moment_crm.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser._crra_method-Tuple{AbstractMatrix{<:Real}, Integer, Real}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser._crra_method","text":"_crra_method(weights::AbstractMatrix{<:Real}, k::Integer, g::Real)\n\nInternal function for computing the Normalized Constant Relative Risk Aversion coefficients.\n\nInputs\n\nweights: T×(k-1) matrix where T is the number of observations and k the order of the L-moments to combine, the i'th column contains the weights for the (i+1)'th L-moment.\nk: the maximum order of the L-moments.\ng: the risk aversion coefficient.\n\nOutputs\n\nw: T×1 ordered weight vector of the combined L-moments.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser._optimise_JuMP_model-Tuple{Any, Any}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser._optimise_JuMP_model","text":"_optimise_JuMP_model(model, solvers)\n\nInternal function to optimise an OWA JuMP model.\n\nInputs\n\nmodel: JuMP model.\n\nOutputs\n\nterm_status: JuMP termination status.\nsolvers_tried: Dictionary that contains a dictionary of failed optimisations. Dict(key => Dict(...)), where key is the solver key used for the iteration of solver that failed.\nIf an MOI call fails on a model:\nDict(:jump_error => jump_error): JuMP error code.\nIf the optimiser fails to optimise the model satisfactorily:\nDict(:objective_val => JuMP.objective_value(model), :term_status => term_status, :params => haskey(val, :params) ? val[:params] : missing), where val is the value of the dictionary corresponding to key.\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Entropic-and-relativistic-moments","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/#Public","page":"Entropic and relativistic moments","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationGetZ.jl\"]","category":"page"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z-Tuple{Portfolio, Union{RiskMeasure, AbstractVector}, Any}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z","text":"get_z\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z_from_model-Tuple{JuMP.Model, EVaR, Any}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z_from_model","text":"get_z_from_model\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Private","page":"Entropic and relativistic moments","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationGetZ.jl\"]","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"EditURL = \"../../../examples/4_hrp_portfolios.jl\"","category":"page"},{"location":"examples/4_hrp_portfolios/#Example-4:-Hierarchical-risk-parity","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This example focuses on the HRP optimisation type of HCPortfolio.","category":"page"},{"location":"examples/4_hrp_portfolios/#4.1-Downloading-the-data","page":"Example 4: Hierarchical risk parity","title":"4.1 Downloading the data","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/4_hrp_portfolios/#4.2-Instantiating-an-instance-of-[HCPortfolio](@ref).","page":"Example 4: Hierarchical risk parity","title":"4.2 Instantiating an instance of HCPortfolio.","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Since we're going to be performing HRP optimisations, we only need solvers for entropic and relativistic risk measures. Others don't make use of a solver, they can be computed from the asset statistics.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"portfolio = HCPortfolio(; prices = prices,\n                        # Continuous optimiser.\n                        solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                         :check_sol => (allow_local = true,\n                                                                        allow_almost = true),\n                                                         :params => Dict(\"verbose\" => false))),\n                        # MIP optimiser for the discrete allocation.\n                        alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                            :check_sol => (allow_local = true,\n                                                                           allow_almost = true),\n                                                            :params => Dict(\"log_to_console\" => false))));\nnothing #hide","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will first use the most basic statistics. We'll later see how we can change the characteristics by changing them.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"cov_type = PortCovCor()\ncor_type = PortCovCor()\ndist_type = DistCanonical()\nasset_statistics!(portfolio; cov_type = cov_type, cor_type = cor_type,\n                  dist_type = dist_type)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3-Basic-HRP-portfolio","page":"Example 4: Hierarchical risk parity","title":"4.3 Basic HRP portfolio","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/#4.3.1-Hierarchical-clustering","page":"Example 4: Hierarchical risk parity","title":"4.3.1 Hierarchical clustering","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"All [HCPortfolio]s use the assets' correlation structure to optimise the portfolios based on their correlation structure. PortfolioOptimiser comes with two clustering methods.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Hierarchical clustering using Clustering.jl.\nDirect Bubble Hierarchy Trees.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll use the default values for everything, see optimise! for details.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Standard deviation\nrm = SD()\n\n# Hierachical clustering with Ward's linkage.\nhclust_alg = HAC(; linkage = :ward)\n# Method for determining the number of clusters is the two-difference gap statistic [`TwoDiff`](@ref).\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\n# Optimise.\nw1 = optimise!(portfolio; rm = rm)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"HRP uses the clustering structure, but it splits the dendrogram naïvely down the middle. This means it can't take full advantage of the clustering structure, and may split closely related assets into separate clusters, which is not ideal. However, the next example will go over the HERC optimisation type, which does consider the clustering structure.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Regardless, we'll plot the clusters to see the structure of the relationships between assets. We don't want to clusterise again so we'll set cluster = false, which is also a flag in optimise!, which saves on processing when the assets have been previously clusterised, the default is cluster = true.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"plot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Before moving on to DBHT clustering, we'll use a different linkage function. Generally speaking, Ward's clustering is the most robust when dealing with noisy data, which is why it's the default method. Lets see what complete clustering looks like. And now we'll use a different method for determining the clusters, StdSilhouette.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Hierarchical clustering with complete linkage.\nhclust_alg = HAC(; linkage = :complete)\n# Method for determining the number of clusters is the Standard silhouette score [`StdSilhouette`](@ref).\nhclust_opt = HCOpt(; k_method = StdSilhouette())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\n# Optimise.\nw2 = optimise!(portfolio; rm = rm)\npretty_table(w2; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3.2-DBHT-clustering","page":"Example 4: Hierarchical risk parity","title":"4.3.2 DBHT clustering","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Direct Bubble Hierarchy Tree (DBHT) clustering, is a type of clustering based on graph-theoretic filtering. The same idea is used to compute the LoGo covariance, which we explored in Example 2.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"DBHT clustering also uses a similarity matrix, the original MATLAB code proposes two methods. PortfolioOptimiser implements them both using DBHTMaxDist and DBHTExp. Though users can define their own creating a concrete subtype of PortfolioOptimiser.DBHTSimilarity and implementing dbht_similarity for it. There are also two methods for defining roots of graphs, either of which can be used UniqueDBHT and EqualDBHT.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"For now we will use teh defaults.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Again we will use default parameters first. We're not setting cluster = flase in this optimisation since we want the assets to be clustered using this new algorithm.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# DBHT clustering, using the distance from the maximum value of the dissimilarity matrix [`DBHTMaxDist`](@ref).\nhclust_alg = DBHT(; similarity = DBHTMaxDist())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\nw3 = optimise!(portfolio; rm = rm)\npretty_table(w3; formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will again plot the clusters. Note how different the clusters are.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"plot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll see the effect changing the similarity matrix calculation to exponential decay of the disimilarity score.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTExp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw4 = optimise!(portfolio; rm = rm)\npretty_table(w4; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll define our own method for the similarity matrix. We'll use one of the potential definitions given in DBHTs.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As a general rule, PortfolioOptimiser doesn't export abstract types, so they have to be explicitly imported.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll define our similarity matrix using only the correlation, denoted here by S, the distance matrix is denoted by D dbht_similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"struct DBHTClamp <: PortfolioOptimiser.DBHTSimilarity end\nfunction PortfolioOptimiser.dbht_similarity(::DBHTClamp, S, D)\n    return S .+ abs(minimum(S))\nend\nhclust_alg = DBHT(; similarity = DBHTClamp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw5 = optimise!(portfolio; rm = rm)\npretty_table(w5; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll make another method that uses both the correlation and distance matrices to create the DBHT similarity matrix. We'll also make it tuneable.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"@kwdef mutable struct DBHTTuneableLinComboMaxDistExp{T1 <: Real, T2 <: Real, T3 <: Real} <:\n                      PortfolioOptimiser.DBHTSimilarity\n    maxdist_c::T1 = 1.0\n    expdeca_c::T2 = 1.0\n    argcoef::T3 = 0.5\nend\nfunction PortfolioOptimiser.dbht_similarity(DBHT::DBHTTuneableLinComboMaxDistExp, S, D)\n    max_dist = DBHT.maxdist_c * PortfolioOptimiser.dbht_similarity(DBHTMaxDist(), S, D)\n    exp_dec = exp.(-DBHT.argcoef * D)\n    return max_dist + exp_dec\nend\nhclust_alg = DBHT(;\n                  similarity = DBHTTuneableLinComboMaxDistExp(; maxdist_c = 0.3,\n                                                              expdeca_c = 1, argcoef = 0.4))\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw6 = optimise!(portfolio; rm = rm)\npretty_table(w6; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3.3-Using-detoned-matrices.","page":"Example 4: Hierarchical risk parity","title":"4.3.3 Using detoned matrices.","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As mentioned in Example 2, detoned matrices can be of great value in hierarchical optimisations. We'll see their effect here.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will repeat the exact same steps as above, but without redefining the structures.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"cov_type = PortCovCor(; denoise = DenoiseFixed(; detone = true))\ncor_type = PortCovCor(; denoise = DenoiseFixed(; detone = true))\ndist_type = DistCanonical()\nasset_statistics!(portfolio; cov_type = cov_type, cor_type = cor_type,\n                  dist_type = dist_type)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"First we try Ward's linkage.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = HAC(; linkage = :ward)\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw7 = optimise!(portfolio; rm = rm)\npretty_table(w7; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Then complete, and we'll see categorise the number of clusters according to the standard silhouette score.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = HAC(; linkage = :complete)\nhclust_opt = HCOpt(; k_method = StdSilhouette())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw8 = optimise!(portfolio; rm = rm)\npretty_table(w8; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll use DBHT clustering with max distance similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTMaxDist())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw9 = optimise!(portfolio; rm = rm)\npretty_table(w9; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll use the exponential decay similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTExp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw10 = optimise!(portfolio; rm = rm)\npretty_table(w10; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll try the clamp method.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTClamp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw11 = optimise!(portfolio; rm = rm)\npretty_table(w11; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"And finally the tuneable linear combination of max distance and exponential decay.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(;\n                  similarity = DBHTTuneableLinComboMaxDistExp(; maxdist_c = 0.3,\n                                                              expdeca_c = 1, argcoef = 0.4))\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw12 = optimise!(portfolio; rm = rm)\npretty_table(w12; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As you can see, there are drastic differences in the correlation matrices. We'll display the weights of the sample  correlations and covariances (:weights) and their detoned counterparts (:weights_d) side by side.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Ward's linkage\npretty_table(DataFrames.rename!(hcat(w1, w7.weights), :x1 => :weights_d); formatters = fmt1)\n# complete linkage\npretty_table(DataFrames.rename!(hcat(w2, w8.weights), :x1 => :weights_d); formatters = fmt1)\n# DBHT max dist\npretty_table(DataFrames.rename!(hcat(w3, w9.weights), :x1 => :weights_d); formatters = fmt1)\n# DBHT exp decay\npretty_table(DataFrames.rename!(hcat(w4, w10.weights), :x1 => :weights_d);\n             formatters = fmt1)\n# DBHT clamp (custom method)\npretty_table(DataFrames.rename!(hcat(w5, w11.weights), :x1 => :weights_d);\n             formatters = fmt1)\n# DBHT tuneable linear combination max dist exp decay\npretty_table(DataFrames.rename!(hcat(w6, w12.weights), :x1 => :weights_d);\n             formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Constraints/WeightConstraints/#Weight-constraints","page":"Weight constraints","title":"Weight constraints","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#Public","page":"Weight constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.asset_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.asset_constraints","text":"asset_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the linear constraint matrix A and vector B:\n\nmathbfA bmw geq bmB.\n\nInputs\n\nconstraints: Nc×10 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nSubset: whole class.\nAll Assets: all assets.\nAll Subsets: all asset classes.\nEach Asset in Subset: specific assets in a class.\nSet: (String) if Type is Subset, All Subsets or Each Asset in Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nRelative_Type: (String) specifies to what the constraint is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative constraint.\nFactor: (<:Real) the factor of the relative constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nA: Nc×Na matrix of constraints where  and .\nB: Nc×1 vector of constraints where .\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\", \"FCN\",\n                                   \"TKO\", \"ZOO\", \"ZVO\", \"ZX\", \"ZZA\", \"ZZB\", \"ZZC\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\", \"Equity\", \"Equity\",\n                                     \"Equity\", \"Fixed Income\", \"Fixed Income\", \"Equity\",\n                                     \"Fixed Income\", \"Equity\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\", \"Financial\",\n                                     \"Entertainment\", \"Treasury\", \"Financial\", \"Financial\",\n                                     \"Entertainment\", \"Technology\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true, true, true, true,\n                                      true, true, true, true, true, true],\n                        \"Type\" => [\"Subset\", \"All Subsets\", \"Asset\", \"Asset\", \"Subset\",\n                                   \"All Assets\", \"Each Asset in Subset\", \"Asset\",\n                                   \"All Assets\", \"All Assets\", \"Subset\", \"All Subsets\",\n                                   \"All Subsets\", \"Each Asset in Subset\",\n                                   \"Each Asset in Subset\"],\n                        \"Set\" => [\"Class 1\", \"Class 1\", \"\", \"\", \"Class 2\", \"\", \"Class 1\",\n                                  \"Class 1\", \"Class 2\", \"\", \"Class 1\", \"Class 2\", \"Class 2\",\n                                  \"Class 2\", \"Class 1\"],\n                        \"Position\" => [\"Equity\", \"Fixed Income\", \"BAC\", \"WFC\", \"Financial\",\n                                       \"\", \"Equity\", \"FCN\", \"TKO\", \"ZOO\", \"Fixed Income\",\n                                       \"Treasury\", \"Entertainment\", \"Treasury\", \"Equity\"],\n                        \"Sign\" => [\"<=\", \"<=\", \"<=\", \"<=\", \">=\", \">=\", \">=\", \"<=\", \">=\",\n                                   \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\"],\n                        \"Weight\" => [0.6, 0.5, 0.1, \"\", \"\", 0.02, \"\", \"\", \"\", \"\", \"\", \"\",\n                                     \"\", 0.27, \"\"],\n                        \"Relative_Type\" => [\"\", \"\", \"\", \"Asset\", \"Subset\", \"\", \"Asset\",\n                                            \"Subset\", \"Asset\", \"Subset\", \"Asset\", \"Asset\",\n                                            \"Subset\", \"\", \"Subset\"],\n                        \"Relative_Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"\", \"\", \"Class 1\", \"\",\n                                           \"Class 2\", \"\", \"Class 2\", \"Class 2\", \"\",\n                                           \"Class 2\"],\n                        \"Relative_Position\" => [\"\", \"\", \"\", \"FB\", \"Fixed Income\", \"\", \"TLT\",\n                                                \"Equity\", \"NTFX\", \"Financial\", \"WFC\", \"ZOO\",\n                                                \"Entertainment\", \"\", \"Entertainment\"],\n                        \"Factor\" => [\"\", \"\", \"\", 1.2, 0.5, \"\", 0.4, 0.7, 0.21, 0.11, 0.13,\n                                     -0.17, 0.23, \"\", -0.31])\nA, B = asset_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.factor_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.factor_constraints","text":"factor_constraints(constraints::DataFrame, loadings::DataFrame)\n\nCreate the factor constraints matrix C and vector D:\n\nmathbfC bmw geq bmD.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nFactor: (String) name of the constraint's factor.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the constraint is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nC: Nc×Nf matrix of constraints where  and .\nD: Nc×1 vector of constraints where .\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true],\n                        \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\", \"const\"],\n                        \"Sign\" => [\"<=\", \"<=\", \">=\", \">=\"],\n                        \"Value\" => [0.9, -1.2, 0.3, -0.1],\n                        \"Relative_Factor\" => [\"USMV\", \"\", \"\", \"SIZE\"])\nC, D = factor_constraints(constraints, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.hrp_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.hrp_constraints","text":"hrp_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the upper and lower bounds constraints for hierarchical risk parity portfolios.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nAll Assets: all assets.\nEach Asset in Subset: specific assets in a class.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nw_min: Na×1 vector of the lower bounds for asset weights.\nw_max: Na×1 vector of the upper bounds for asset weights.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true],\n                        \"Type\" => [\"Asset\", \"Asset\", \"All Assets\", \"All Assets\",\n                                   \"Each Asset in Subset\", \"Each Asset in Subset\"],\n                        \"Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"Class 2\"],\n                        \"Position\" => [\"BAC\", \"FB\", \"\", \"\", \"Fixed Income\", \"Financial\"],\n                        \"Sign\" => [\">=\", \"<=\", \"<=\", \">=\", \"<=\", \"<=\"],\n                        \"Weight\" => [0.02, 0.085, 0.09, 0.01, 0.07, 0.06])\nw_min, w_max = hrp_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.rp_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.rp_constraints","text":"rp_constraints(asset_sets::DataFrame; type::Symbol = :Asset,\n               class_col::Union{String, Symbol, Nothing} = nothing)\n\nConstructs risk contribution constraint vector for the risk parity optimisation (:RP and :RRP types of PortTypes).\n\nInputs\n\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets. They are only used if type == :Subset.\nclass_col: index of set of classes from asset_sets to use in when type == :Subset.\n\nOutputs\n\nrw: risk contribution constraint vector.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\n\nrw_a = rp_constraints(asset_sets, :Asset)\nrw_c = rp_constraints(asset_sets, :Subset, \"Class 2\")\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.turnover_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.turnover_constraints","text":"turnover_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\n\"Asset\"\n\"All Assets\"\n\"Each Asset in Subset\"\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#Private","page":"Weight constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Finalisation-functions","page":"Finalisation functions","title":"Finalisation functions","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Public","page":"Finalisation functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Private","page":"Finalisation functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"EditURL = \"../../../examples/3_shorting_portfolios.jl\"","category":"page"},{"location":"examples/3_shorting_portfolios/#Example-3:-Shorting-and-leveraged-portfolios","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This example focuses on using the shorting constraints available to Trad and WC optimisations of Portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/#3.1-Downloading-the-data","page":"Example 3: Shorting and leveraged portfolios","title":"3.1 Downloading the data","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/#3.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 3: Shorting and leveraged portfolios","title":"3.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"mu_type = MuSimple()\ncov_type = PortCovCor()\nasset_statistics!(portfolio; mu_type = mu_type, cov_type = cov_type)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Risk free rate.\nrf = 3.5 / 100 / 252\n# Risk aversion.\nl = 2.0\n# Objective function.\nobj = MinRisk()\n# Risk measure.\nrm = SD()\n# Money available to us.\ninvestment = 6750;\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.1-Long-only-portfolio","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.1 Long-only portfolio","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"First we will optimise the portfolio without shorting and plot the weights and the efficient frontier.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = false\nportfolio.optimal[:ns] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :ns)\nportfolio.frontier[:ns] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :ns)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"We'll now allocate the portfolio according to our means. We'll use both allocation methods:","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Linear Mixed-integer Programming (LP): (default) can only allocate discrete integer shares and requires an MIP solver.\nGreedy algorithm, can round down to the nearest integer + N*rounding, but is not guaranteed to be globally optimal. The rounding also rounds down, as it ensures the investment will not be exceeded.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.optimal[:nsal] = allocate!(portfolio; type = :ns, method = LP(),\n                                     investment = investment)\nportfolio.optimal[:nsag] = allocate!(portfolio; type = :ns,\n                                     method = Greedy(; rounding = 0.3),\n                                     investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available. We'll also compare the would-be optimal portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:ns].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment = $(sum(investment * portfolio.optimal[:ns].weights[long_optimal_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:ns].weights[long_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:nsal].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:nsal].shares[long_LP_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:nsal].weights[long_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:nsag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:nsag].shares[long_Greedy_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:nsag].weights[long_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"As you can see, the greedy algorithm doesn't make optimal use of the available investment.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets now see what the long-only portfolio looks like, in both optimal and allocated form.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights without shorting.\n                       ns_w = portfolio.optimal[:ns].weights,\n                       # Discretely allocated optimal weights without shorting.\n                       # Linear programming.\n                       nsal_w = portfolio.optimal[:nsal].weights,\n                       # Discretely allocated shares without shorting.\n                       # Linear programming.\n                       nsal_s = portfolio.optimal[:nsal].shares,\n                       # Discretely allocated optimal weights without shorting.\n                       # Greedy algorithm.\n                       nsag_w = portfolio.optimal[:nsag].weights,\n                       # Discretely allocated shares without shorting.\n                       # Greedy algorithm.\n                       nsag_s = portfolio.optimal[:nsag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.2-Shorting","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.2 Shorting","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Enabling shorting is very simple. This will allow negative weights, which correspond to shorting portfolios. It is generally a good idea to start with little to no leverage.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = true;\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"How short- or long-heavy we want to be is mediated by the short_u, long_u, short_budget and budget properties. They set the upper bound for the absolute value of the sum of the short and long weights respectively.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"budget: the sum of all the weights will be equal to this value.\nshort_budget: upper bound for the absolute value of the sum of the short weights.\nlong_u: upper bound of each of the long weights.\nshort_u: upper bound of the absolute value of each of the short weights.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"These values multiply the cash at our disposal when we allocate the portfolio. So when allocate! is called, the long investment will be investment * long_u. And if shorting is enabled, the short investment (the amount shorted) will be short_u * investment.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets short the market whithout reinvesting the earnings, meaning we'll have a cash reserve in our balance that is equal to the short sale value. You can change this by increasing long_u, if you set it to 1 + short_u it means the profits from short selling will be reinvested into the portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"We will use the default values.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# The absolute value of the sum of the short weights is equal to `0.2`.\nportfolio.short_budget = 0.2\n# The portfolio weights will add up to 0.8, meaning the portfolio will be underleveraged.\nportfolio.budget = 0.8;\n# Each short position can have a maximum value of -0.2.\nportfolio.short_u = 0.2\n# Each long position can have a maximum value of 1.\nportfolio.long_u = 1.0","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"The portfolio budget gives us the leverage characteristics of the portfolio. This is a property that is automatically computed and cannot be cahnged. There are verious scenarios that budget describes.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"budget < 0: the short sale value of the portfolio is higher than the long-sale value.\nbudget == 0: the short and long values of the portfolio are equal. The market neutral portfolio is found by maximising the return given these conditions.\n0 < budget < 1: the portfolio is under-leveraged, meaning there is a cash reserve that is not being used.\nbudget == 1: the portfolio has no leverage. If shorting is enabled, this means the profits from shorting are being invested in long positions.\nbudget > 1: the portfolio is leveraged, meaning it's using more money than is available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here the portfolio is under-leveraged.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets optimise the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.optimal[:s] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :s)\nportfolio.frontier[:s] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :s)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets allocate the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Allocating the short-long portfolio.\nportfolio.optimal[:sal] = allocate!(portfolio; type = :s, investment = investment)\nportfolio.optimal[:sag] = allocate!(portfolio; type = :s, method = Greedy(; rounding = 0.3),\n                                    investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:s].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment\")\nprintln(\"long = $(sum(investment * portfolio.optimal[:s].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(investment * portfolio.optimal[:s].weights[short_optimal_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:s].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:s].weights[short_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:sal].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:sal].shares[long_LP_idx]))\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sal].shares[short_LP_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sal].weights[long_LP_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sal].weights[short_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:sag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:sag].shares[long_Greedy_idx]))\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:sag].shares[short_Greedy_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sag].weights[long_Greedy_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sag].weights[short_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here's what the short-long portfolio looks like. See how this differs from the long-only portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights with shorting.\n                       s_w = portfolio.optimal[:s].weights,\n                       # Discretely allocated optimal weights with shorting.\n                       # Linear programming.\n                       sal_w = portfolio.optimal[:sal].weights,\n                       # Discretely allocated shares with shorting.\n                       # Linear programming.\n                       sal_s = portfolio.optimal[:sal].shares,\n                       # Discretely allocated optimal weights with shorting.\n                       # Greedy algorithm.\n                       sag_w = portfolio.optimal[:sag].weights,\n                       # Discretely allocated shares with shorting.\n                       # Greedy algorithm.\n                       sag_s = portfolio.optimal[:sag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.3-Shorting-with-reinvestment","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.3 Shorting with reinvestment","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"In this section we'll reinvest the money made from short selling, this can be acomplished by setting the value of long_u = 1 + short_u.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = true\n\n# The absolute value of the sum of the short weights is equal to `0.2`.\nportfolio.short_budget = 0.2\n# Reinvest the earnings from short selling.\nportfolio.budget = 1\n\nportfolio.optimal[:sr] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :sr)\nportfolio.frontier[:sr] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :sr)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets allocate the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Allocating the short-long portfolio.\nportfolio.optimal[:sral] = allocate!(portfolio; type = :sr, investment = investment)\nportfolio.optimal[:srag] = allocate!(portfolio; type = :sr,\n                                     method = Greedy(; rounding = 0.3),\n                                     investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:sr].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment\")\nprintln(\"long = $(sum(investment * portfolio.optimal[:sr].weights[long_optimal_idx]))\")\nprintln(\"long = $(investment + abs(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))) = $(investment) + $(abs(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))) = investment + short_profit\")\nprintln(\"short = $(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sr].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sr].weights[short_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:sral].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:sral].shares[long_LP_idx]))\")\nprintln(\"long ≈ $(investment + abs(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))) ≈ $(investment) + $(abs(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))) ≈ investment + short_profit\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sral].weights[long_LP_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sral].weights[short_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:srag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:srag].shares[long_Greedy_idx]))\")\nprintln(\"long ≈ $(investment + abs(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))) ≈ $(investment) + $(abs(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))) ≈ investment + short_profit\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:srag].weights[long_Greedy_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:srag].weights[short_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here's what the short-long portfolio looks like when we reinvest profits from shorting.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights with shorting.\n                       s_w = portfolio.optimal[:sr].weights,\n                       # Discretely allocated optimal weights with shorting.\n                       # Linear programming.\n                       sal_w = portfolio.optimal[:sral].weights,\n                       # Discretely allocated shares with shorting.\n                       # Linear programming.\n                       sal_s = portfolio.optimal[:sral].shares,\n                       # Discretely allocated optimal weights with shorting.\n                       # Greedy algorithm.\n                       sag_w = portfolio.optimal[:srag].weights,\n                       # Discretely allocated shares with shorting.\n                       # Greedy algorithm.\n                       sag_s = portfolio.optimal[:srag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"EditURL = \"../../../examples/5_risk_parity_portfolios.jl\"","category":"page"},{"location":"examples/5_risk_parity_portfolios/#Example-5:-Risk-parity","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This example focuses on the RP optimisation type of Portfolio.","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.1-Downloading-the-data","page":"Example 5: Risk parity","title":"5.1 Downloading the data","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 5: Risk parity","title":"5.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.3-Optimising-the-portfolio","page":"Example 5: Risk parity","title":"5.3 Optimising the portfolio","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"The RP uses a risk budget vector for defining the risk contribution of each asset. The vector defaults to equal risk contribution for all assets.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Risk parity portfolios don't use a user-provided objective function. They minimise the risk subject to a constraint that minimises the deviation","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"rm = SD()\ntype = RP()\nw1 = optimise!(portfolio; type = type, rm = rm)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We can check that the risk budget and risk contribution match.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# Risk budget.\nrb = portfolio.risk_budget\n# Compute the risk contribution, for the [`SD`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = rm)\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\n\npretty_table(hcat(w1, DataFrame(; budget = rb, contribution = rc)); formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"As you can see, the weights of each asset in the portfolio are such that the asset contributes 4% of the risk of the portfolio. This is because we used the default value for the risk budget, which defaults to equal risk contribution per asset, which is equal to 1/N, where N is the number of assets.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We can also plot the risk contribution in asbolute and relative terms.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"plot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets change the risk budget to something a little bit more interesting. The risk budget can be provided from to the Portfolio constructor, or after instatiation. Either way, the risk budget will be normalised to add up to 1. If using the latter method, the element type of the vector provided must match that of risk_budget because the normalisation is done in-place to avoid unecessary allocations.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"x = range(; start = 0, stop = 2pi, length = length(w1.weights))\nportfolio.risk_budget = sin.(x) .^ 2;\nnothing #hide","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets optimise using this risk budget to see what happens.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"w1 = optimise!(portfolio; type = type, rm = rm)\nrb = portfolio.risk_budget\n# Compute the risk contribution, for the [`SD`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = rm)\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\npretty_table(hcat(w1, DataFrame(; budget = rb, contribution = rc)); formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets plot the results.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"plot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We've used the SD risk function for computing the risk parity portfolio, as well as for computing and plotting the risk contribution, but there's nothing stopping us from computing the risk contribution and/or plotting the risk contribution for risk measures other than the one that was optimised.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# Compute the risk contribution, for the [`CDaR`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = CDaR())\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\npretty_table(hcat(w1, DataFrame(; budget_SD = rb, contribution_CDaR = rc));\n             formatters = fmt1)\n\nplot_risk_contribution(portfolio; rm = CDaR(), type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = CDaR(), type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Optimisation/OptimisationReturns/#Returns","page":"Returns","title":"Returns","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/#Public","page":"Returns","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"Optimisation/OptimisationReturns/#Private","page":"Returns","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#Covariance,-correlation,-cokurtosis-and-coskewness","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#Public","page":"Covariance, correlation, cokurtosis and coskewness","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber0","text":"@kwdef mutable struct CorGerber0{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber1","text":"@kwdef mutable struct CorGerber1{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber2","text":"@kwdef mutable struct CorGerber2{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 2 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 2 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB0","text":"@kwdef mutable struct CorGerberSB0{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification with vote counting of the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB1","text":"@kwdef mutable struct CorGerberSB1{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification with vote counting of the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorKendall","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorKendall","text":"@kwdef mutable struct CorKendall <: CorRank\n    absolute::Bool = false\nend\n\nKendall type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corkendall(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorLTD","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorLTD","text":"mutable struct CorLTD <: PortfolioOptimiserCovCor\n    alpha::Real\n    ve::StatsBase.CovarianceEstimator\n    w::Union{<:AbstractWeights, Nothing}\nend\n\nLower tail dependence correlation and covariance matrix estimator.\n\nParameters\n\nalpha: significance level of the lower tail dependence, alpha ∈ (0, 1).\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorMutualInfo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorMutualInfo","text":"@kwdef mutable struct CorMutualInfo <: PortfolioOptimiserCovCor\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nMutual information correlation matrix estimator.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB0","text":"@kwdef mutable struct CorSB0{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification of the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB1","text":"@kwdef mutable struct CorSB1{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification of the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSpearman","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSpearman","text":"@kwdef mutable struct CorSpearman <: CorRank\n    absolute::Bool = false\nend\n\nSpearman type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corspearman(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovDistance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovDistance","text":"mutable struct CovDistance <: PortfolioOptimiserCovCor\n    distance::Distances.Metric\n    dist_args::Tuple\n    dist_kwargs::NamedTuple\n    mean_w1::Union{<:AbstractWeights, Nothing}\n    mean_w2::Union{<:AbstractWeights, Nothing}\n    mean_w3::Union{<:AbstractWeights, Nothing}\nend\n\nDistance covariance and correlation matrix estimator.\n\nParameters\n\ndistance: distance metric from Distances.jl.\ndist_args: args for the Distances.pairwise function of Distances.jl.\ndist_kwargs: kwargs for the Distances.pairwise function of Distances.jl.\nmean_w1: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its rows (dims = 1).\nmean_w2: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its columns (dims = 2).\nmean_w3: optional T×1 vector of weights for computing the mean of the entirety of the pairwise distance matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovFull","text":"@kwdef mutable struct CovFull <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nFull Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSemi","text":"@kwdef mutable struct CovSemi <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSemi Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtFull","text":"@kwdef mutable struct KurtFull <: KurtEstimator\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nFull cokurtosis estimator.\n\nParameters\n\nposdef: method for fixing non a positive definite cokurtosis matrix PosdefFix.\ndenoise: method for denoising the cokurtosis matrix Denoise.\nlogo: method for computing the LoGo cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtSemi","text":"@kwdef mutable struct KurtSemi <: KurtEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nposdef: method for fixing non a positive definite semi cokurtosis matrix PosdefFix.\ndenoise: method for denoising the semi cokurtosis matrix Denoise.\nlogo: method for computing the LoGo semi cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.LoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.LoGo","text":"@kwdef mutable struct LoGo <: AbstractLoGo\n    distance::DistMethod = DistMLP()\n    similarity::DBHTSimilarity = DBHTMaxDist()\nend\n\nCompute the LoGo covariance and correlation matrix estimator.\n\nParameters\n\ndistance: method for computing the distance (disimilarity) matrix from the correlation matrix if the distance matrix is not provided to logo!.\nsimilarity: method for computing the similarity matrix from the correlation and distance matrices. The distance matrix is used to compute sparsity pattern of the inverse of the LoGo covariance and correlation matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.NoLoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.NoLoGo","text":"struct NoLoGo <: AbstractLoGo end\n\nLeave the matrix as is.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortCovCor","text":"@kwdef mutable struct PortCovCor <: PortfolioOptimiserCovCor\n    ce::CovarianceEstimator = CovFull(;)\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nPortfolioOptimiser covariance and correlation estimator.\n\nParameters\n\nce: covariance estimator.\nposdef: method for fixing the portfolio covariance or correlation matrix PosdefFix.\ndenoise: method for denoising the portfolio covariance or correlation matrix Denoise.\nlogo: method for computing the LoGo portfolio covariance or correlation matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SimpleVariance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SimpleVariance","text":"@kwdef mutable struct SimpleVariance <: StatsBase.CovarianceEstimator\n    corrected::Bool = true\nend\n\nSimple variance estimator.\n\nParameters\n\ncorrected:\nif true: correct the bias dividing by N-1 instead of N.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewFull","text":"struct SkewFull <: SkewEstimator end\n\nFull cokurtosis estimator.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewSemi","text":"@kwdef mutable struct SkewSemi <: SkewEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewFull, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(::SkewFull, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewSemi, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(se::SkewSemi, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.logo!","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.logo!","text":"logo!(je::LoGo, posdef::PosdefFix, X::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.logo!-2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.logo!","text":"logo!(::NoLoGo, ::PosdefFix, ::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/CovCorKurtSkew/#Private","page":"Covariance, correlation, cokurtosis and coskewness","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PosdefFixCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PosdefFixCovCor","text":"const PosdefFixCovCor = Union{<:CorGerber, PortCovCor}\n\nCovariance and correlation estimators that support positive definite fixes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.AbstractLoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.AbstractLoGo","text":"abstract type AbstractLoGo end\n\nAbstract type for subtyping LoGo covariance and correlation matrix estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber","text":"abstract type CorGerber <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberBasic","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberBasic","text":"abstract type CorGerberBasic <: CorGerber end\n\nAbstract type for subtyping the original Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB","text":"abstract type CorSB <: CorGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications with vote counting of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorPearson","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorPearson","text":"abstract type CorPearson <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Pearson type covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorRank","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorRank","text":"abstract type CorRank <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping rank based covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB","text":"abstract type CorSB <: CorGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtEstimator","text":"abstract type KurtEstimator end\n\nAbstract type for subtyping cokurtosis estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortfolioOptimiserCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortfolioOptimiserCovCor","text":"abstract type PortfolioOptimiserCovCor <: StatsBase.CovarianceEstimator end\n\nAbstract type for subtyping portfolio covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewEstimator","text":"abstract type SkewEstimator end\n\nAbstract type for subtyping coskew estimators.\n\n\n\n\n\n","category":"type"},{"location":"PlotsExtension/#Plots-extension","page":"Plots Extension","title":"Plots extension","text":"","category":"section"},{"location":"PlotsExtension/#Public","page":"Plots Extension","title":"Public","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = true\nPrivate = false\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#Private","page":"Plots Extension","title":"Private","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = false\nPrivate = true\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#PortfolioOptimiser.plot_returns-NTuple{4, Any}","page":"Plots Extension","title":"PortfolioOptimiser.plot_returns","text":"plot_returns(timestamps, assets, returns, weights; per_asset = false, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Asset-allocation","page":"Asset allocation","title":"Asset allocation","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#Public","page":"Asset allocation","title":"Public","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.LP","page":"Asset allocation","title":"PortfolioOptimiser.LP","text":"struct LP <: AllocationMethod end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.allocate!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Asset allocation","title":"PortfolioOptimiser.allocate!","text":"allocate!(port::AbstractPortfolio;\n                   type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                   method::AllocationMethod = LP(), latest_prices = port.latest_prices,\n                   investment::Real = 1e6, \n                   string_names::Bool = false)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Private","page":"Asset allocation","title":"Private","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.roundmult-Tuple{Any, Any, Vararg{Any}}","page":"Asset allocation","title":"PortfolioOptimiser.roundmult","text":"roundmult(val, prec [, args...] [; kwargs...])\n\nRound a number to a multiple of prec. Uses the same defaults and has the same args and kwargs of the built-in Base.round.\n\nEquivalent to:\n\nround(div(val, prec) * prec, args...; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Regression","page":"Regression","title":"Regression","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#Public","page":"Regression","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AIC","page":"Regression","title":"PortfolioOptimiser.AIC","text":"struct AIC <: MinValStepwiseRegressionCriteria end\n\nAkaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AICC","page":"Regression","title":"PortfolioOptimiser.AICC","text":"struct AICC <: MinValStepwiseRegressionCriteria end\n\nCorrected Akaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AdjRSq","page":"Regression","title":"PortfolioOptimiser.AdjRSq","text":"struct AdjRSq <: MaxValStepwiseRegressionCriteria end\n\nAdjusted R² for a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BIC","page":"Regression","title":"PortfolioOptimiser.BIC","text":"struct BIC <: MinValStepwiseRegressionCriteria end\n\nBayesian Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BReg","page":"Regression","title":"PortfolioOptimiser.BReg","text":"@kwdef mutable struct BReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nBackward stepwise regression. Starts by assuming all features are significant and uses criterion to remove the worst performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FReg","page":"Regression","title":"PortfolioOptimiser.FReg","text":"@kwdef mutable struct FReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nForward stepwise regression. Starts by assuming no factor is significant and uses criterion to add the best performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FactorType","page":"Regression","title":"PortfolioOptimiser.FactorType","text":"@kwdef mutable struct FactorType\n    error::Bool = true\n    B::Union{Nothing, DataFrame} = nothing\n    method::RegressionType = FReg(;)\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    var_w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCAReg","page":"Regression","title":"PortfolioOptimiser.PCAReg","text":"@kwdef mutable struct PCAReg <: DimensionReductionRegression\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    target::DimensionReductionTarget = PCATarget(;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCATarget","page":"Regression","title":"PortfolioOptimiser.PCATarget","text":"@kwdef mutable struct PCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PPCATarget","page":"Regression","title":"PortfolioOptimiser.PPCATarget","text":"@kwdef mutable struct PPCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PVal","page":"Regression","title":"PortfolioOptimiser.PVal","text":"@kwdef mutable struct PVal{T1 <: Real} <: StepwiseRegressionCriteria\n    threshold::T1 = 0.05\nend\n\nP-value as feature selection criterion.\n\nParameters\n\nthreshold: threshold for classifying significant p-values. Only features whose p-values are lower than threshold are considered significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RSq","page":"Regression","title":"PortfolioOptimiser.RSq","text":"struct RSq <: MaxValStepwiseRegressionCriteria end\n\nR² of a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.loadings_matrix","page":"Regression","title":"PortfolioOptimiser.loadings_matrix","text":"loadings_matrix(x::DataFrame, y::DataFrame, method::RegressionType = FReg())\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.regression-Tuple{PCAReg, DataFrames.DataFrame, DataFrames.DataFrame}","page":"Regression","title":"PortfolioOptimiser.regression","text":"regression(method::PCAReg, x::DataFrame, y::DataFrame)\n\nDescription\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Private","page":"Regression","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionRegression","page":"Regression","title":"PortfolioOptimiser.DimensionReductionRegression","text":"abstract type DimensionReductionRegression <: RegressionType end\n\nAbstract type for subtyping dimensionality reduction regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionTarget","page":"Regression","title":"PortfolioOptimiser.DimensionReductionTarget","text":"abstract type DimensionReductionTarget end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MaxValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MaxValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where larger values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MinValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MinValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where smaller values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RegressionType","page":"Regression","title":"PortfolioOptimiser.RegressionType","text":"abstract type RegressionType end\n\nAbstract type for subtyping regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegression","page":"Regression","title":"PortfolioOptimiser.StepwiseRegression","text":"abstract type StepwiseRegression <: RegressionType end\n\nAbstract type for subtyping stepwise regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.StepwiseRegressionCriteria","text":"abstract type StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria for selecting significant features when using StepwiseRegression methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#Expected-returns","page":"Expected returns","title":"Expected returns","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#Public","page":"Expected returns","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.GM","page":"Expected returns","title":"PortfolioOptimiser.GM","text":"struct GM <: MeanTarget end\n\nGrand mean target.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBOP","page":"Expected returns","title":"PortfolioOptimiser.MuBOP","text":"@kwdef mutable struct MuBOP <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBodnar-Okhrin-Parolya [8] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBS","page":"Expected returns","title":"PortfolioOptimiser.MuBS","text":"@kwdef mutable struct MuBS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBayes-Stein [9] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuJS","page":"Expected returns","title":"PortfolioOptimiser.MuJS","text":"@kwdef mutable struct MuJS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nJames-Stein [10, 11] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuSimple","page":"Expected returns","title":"PortfolioOptimiser.MuSimple","text":"@kwdef mutable struct MuSimple <: MeanEstimator\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSimple expected returns vector estimator.\n\nParameters\n\nw: optional T×1 vector of weights for computing the expected returns vector.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.SE","page":"Expected returns","title":"PortfolioOptimiser.SE","text":"struct SE <: MeanTarget end\n\nMean square error of sample mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.VW","page":"Expected returns","title":"PortfolioOptimiser.VW","text":"struct VW <: MeanTarget end\n\nVolatility-weighted grand mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.target_mean-Tuple{GM, AbstractVector, AbstractMatrix, Any, Integer, Integer}","page":"Expected returns","title":"PortfolioOptimiser.target_mean","text":"target_mean(::GM, mu::AbstractVector, sigma::AbstractMatrix, inv_sigma, T::Integer,\n                     N::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MeanEstimators/#Private","page":"Expected returns","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanEstimator","text":"abstract type MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanSigmaEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanSigmaEstimator","text":"abstract type MeanSigmaEstimator <: MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanTarget","page":"Expected returns","title":"PortfolioOptimiser.MeanTarget","text":"abstract type MeanTarget end\n\nAbstract type for subtyping correction targets of expected returns estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Worst-case-mean-variance-sets","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#Public","page":"Worst case mean variance sets","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.ArchWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.ArchWC","text":"@kwdef mutable struct ArchWC{T1 <: Integer, T2 <: Integer, T3 <: Real} <: WorstCaseMethod\n    bootstrap::WorstCaseArchMethod = StationaryBS()\n    n_sim::T1 = 3_000\n    block_size::T2 = 3\n    q::T3 = 0.05\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Box","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Box","text":"struct Box <: WorstCaseSet end\n\nBox sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.CircularBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.CircularBS","text":"struct CircularBS <: WorstCaseArchMethod end\n\nCircular block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.DeltaWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.DeltaWC","text":"@kwdef mutable struct DeltaWC{T1 <: Real, T2 <: Real} <: WorstCaseMethod\n    dcov::T1 = 0.1\n    dmu::T2 = 0.1\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Ellipse","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Ellipse","text":"struct Ellipse <: WorstCaseSet end\n\nElliptical sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KGeneralWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KGeneralWC","text":"struct KGeneralWC <: WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KNormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KNormalWC","text":"struct KNormalWC <: WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.MovingBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.MovingBS","text":"struct MovingBS <: WorstCaseArchMethod end\n\nMoving block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NoWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NoWC","text":"@kwdef mutable struct NoWC <: WorstCaseSet\n    formulation::SDSquaredFormulation = SOCSD()\nend\n\nUse no set for worst case mean variance optimisation.\n\nParameters\n\nformulation: quadratic expression formulation of SD risk measure to use SDSquaredFormulation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NormalWC","text":"@kwdef mutable struct NormalWC{T1 <: Integer, T2 <: Real} <: WorstCaseMethod\n    n_sim::T1 = 3_000\n    q::T2 = 0.05\n    rng::AbstractRNG = Random.default_rng()\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.StationaryBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.StationaryBS","text":"struct StationaryBS <: WorstCaseArchMethod end\n\nStationary bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCType","text":"@kwdef mutable struct WCType\n    cov_type::PortfolioOptimiserCovCor = PortCovCor(;)\n    mu_type::MeanEstimator = MuSimple(;)\n    box::WorstCaseMethod = NormalWC(;)\n    ellipse::WorstCaseMethod = NormalWC(;)\n    k_sigma::Union{<:Real, WorstCaseKMethod} = KNormalWC(;)\n    k_mu::Union{<:Real, WorstCaseKMethod} = KNormalWC(;)\n    posdef::PosdefFix = PosdefNearest(;)\n    diagonal::Bool = false\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Private","page":"Worst case mean variance sets","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseArchMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseArchMethod","text":"abstract type WorstCaseArchMethod <: WorstCaseMethod end\n\nAbstract type for subtyping methods for computing worst case mean variance for bootstrapping with arch.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseKMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseKMethod","text":"abstract type WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseMethod","text":"abstract type WorstCaseMethod end\n\nAbstract type for subtyping methods for computing worst case mean variance sets.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseSet","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseSet","text":"abstract type WorstCaseSet end\n\nAbstract type for subtyping worst case mean variance set types.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#Optimisation-kinds","page":"Optimisation kinds","title":"Optimisation kinds","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#Public","page":"Optimisation kinds","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationWC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHRP.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHERC.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationNCO.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.BasicRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.BasicRRP","text":"struct BasicRRP <: RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HERC","page":"Optimisation kinds","title":"PortfolioOptimiser.HERC","text":"struct HERC <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HRP","page":"Optimisation kinds","title":"PortfolioOptimiser.HRP","text":"struct HRP <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NCO","page":"Optimisation kinds","title":"PortfolioOptimiser.NCO","text":"@kwdef mutable struct NCO <: HCOptimType\n    opt_kwargs::NamedTuple = (;)\n    opt_kwargs_o::NamedTuple = opt_kwargs\n    port_kwargs::NamedTuple = (;)\n    port_kwargs_o::NamedTuple = port_kwargs\n    stat_kwargs_o::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NOC","page":"Optimisation kinds","title":"PortfolioOptimiser.NOC","text":"@kwdef mutable struct NOC{T1 <: Real, T2 <: AbstractVector{<:Real},\n                          T3 <: AbstractVector{<:Real}, T4 <: AbstractVector{<:Real},\n                          T5 <: AbstractVector{<:Real}, T6 <: AbstractVector{<:Real}} <:\n                      OptimType\n    type::Union{WC, Trad} = Trad()\n    bins::T1 = 20.0\n    w_opt::T2 = Vector{Float64}(undef, 0)\n    w_min::T3 = Vector{Float64}(undef, 0)\n    w_max::T4 = Vector{Float64}(undef, 0)\n    w_min_ini::T5 = Vector{Float64}(undef, 0)\n    w_max_ini::T6 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RP","page":"Optimisation kinds","title":"PortfolioOptimiser.RP","text":"struct RP <: OptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RRP","text":"@kwdef mutable struct RRP <: OptimType\n    version::RRPVersion = BasicRRP()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegPenRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RegPenRRP","text":"@kwdef mutable struct RegPenRRP{T1 <: Real} <: RRPVersion\n    penalty::T1 = 1.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RegRRP","text":"struct RegRRP <: RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.Trad","page":"Optimisation kinds","title":"PortfolioOptimiser.Trad","text":"struct Trad <: OptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.WC","page":"Optimisation kinds","title":"PortfolioOptimiser.WC","text":"@kwdef mutable struct WC <: OptimType\n    mu::WorstCaseSet = Box()\n    cov::WorstCaseSet = Box()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.efficient_frontier!-Tuple{Portfolio}","page":"Optimisation kinds","title":"PortfolioOptimiser.efficient_frontier!","text":"efficient_frontier!(port::Portfolio; type::Union{Trad, NOC} = Trad(),\n                             rm::Union{AbstractVector, <:RiskMeasure} = SD(),\n                             kelly::RetType = NoKelly(), class::PortClass = Classic(),\n                             w_min_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             w_max_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             points::Integer = 20, rf::Real = 0.0)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.optimise!-Tuple{Portfolio}","page":"Optimisation kinds","title":"PortfolioOptimiser.optimise!","text":"optimise!(port::Portfolio; rm::Union{AbstractVector, <:RiskMeasure} = SD(),\n          type::OptimType = Trad(), obj::ObjectiveFunction = MinRisk(),\n          kelly::RetType = NoKelly(), class::PortClass = Classic(),\n          w_ini::AbstractVector = Vector{Float64}(undef, 0),\n          str_names::Bool = false)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.optimise!-Tuple{HCPortfolio}","page":"Optimisation kinds","title":"PortfolioOptimiser.optimise!","text":"optimise!(port::HCPortfolio; rm::Union{AbstractVector, <:AbstractRiskMeasure} = SD(),\n                   rm_o::Union{AbstractVector, <:AbstractRiskMeasure} = rm,\n                   type::HCOptimType = HRP(), cluster::Bool = true,\n                   hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt(),\n                   max_iter::Int = 100)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#Private","page":"Optimisation kinds","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationWC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHRP.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHERC.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationNCO.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractOptimType","text":"abstract type AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HCOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.HCOptimType","text":"abstract type HCOptimType <: AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.OptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.OptimType","text":"abstract type OptimType <: AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRPVersion","page":"Optimisation kinds","title":"PortfolioOptimiser.RRPVersion","text":"abstract type RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskValue/#Risk-value","page":"Risk value","title":"Risk value","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"Despite the fact that HCRiskMeasure are only compatible with HCPortfolio, it is possible to compute the value of every risk measure for a given returns matrix and vector of weights.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskValue/#Dispersion","page":"Risk value","title":"Dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskValue/#Full-dispersion","page":"Risk value","title":"Full dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"These measure how far the returns deviate from the mean in both the positive and negative directions.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::Variance, ::AbstractVector)\nPortfolioOptimiser._Variance\ncalc_risk(::SD, ::AbstractVector)\nPortfolioOptimiser._SD\ncalc_risk(::MAD, ::AbstractVector)\nPortfolioOptimiser._MAD\ncalc_risk(::Kurt, ::AbstractVector)\nPortfolioOptimiser._Kurt\ncalc_risk(::RG, ::AbstractVector)\nPortfolioOptimiser._RG\ncalc_risk(::CVaRRG, ::AbstractVector)\nPortfolioOptimiser._CVaRRG\ncalc_risk(::TGRG, ::AbstractVector)\nPortfolioOptimiser._TGRG\ncalc_risk(::GMD, ::AbstractVector)\nPortfolioOptimiser._GMD\ncalc_risk(::PortfolioOptimiser.RMSkew, w::AbstractVector)\nPortfolioOptimiser._Skew\ncalc_risk(::BDVariance, ::AbstractVector)\nPortfolioOptimiser._BDVariance","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{Variance, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(variance::Variance, w::AbstractVector; kwargs...)\n\nDescription\n\nCompute the Variance via _Variance.\n\nSee also: Variance, _Variance.\n\nInputs\n\nPositional\n\nvariance::Variance: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nkwargs: used for other methods.\n\nOutputs\n\nrisk::Real: variance.\n\nExamples\n\n# Number of assets\nN = 3\n\n# Create sample covariance matrix\nΣ = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Create weight vector\nw = [0.3, 0.4, 0.3]\n\n# Create instance of risk measure.\nvariance_rm = Variance(; sigma = Σ)\n\n# Calculate portfolio standard deviation\nrisk = calc_risk(variance_rm, w)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._Variance","page":"Risk value","title":"PortfolioOptimiser._Variance","text":"_Variance(w::AbstractVector, Σ::AbstractMatrix)\n\nDescription\n\nCompute the Variance. This is the square of _SD.\n\nbeginalign\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\nendalign\n\nSee also: Variance, calc_risk(::Variance, ::AbstractVector), _SD, SD.\n\nInputs\n\nw::AbstractVector: N×1 vector of asset weights.\nΣ::AbstractMatrix: N×N covariance matrix of asset returns.\n\nOutputs\n\nvariance::Real: variance.\n\nExamples\n\n# Number of assets\nN = 3\n\n# Create sample covariance matrix\nΣ = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Create weight vector\nw = [0.3, 0.4, 0.3]\n\n# Calculate portfolio variance\nvariance = _Variance(w, Σ)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{SD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(sd::SD, w::AbstractVector; kwargs...)\n\nDescription\n\nCompute the SD via _SD.\n\nSee also: SD, _SD.\n\nInputs\n\nPositional\n\nsd::SD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nkwargs: used for other methods.\n\nOutputs\n\nrisk::Real: standard deviation.\n\nExamples\n\n# Number of assets\nN = 3\n\n# Create sample covariance matrix\nΣ = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Create weight vector\nw = [0.3, 0.4, 0.3]\n\n# Create instance of risk measure.\nsd_rm = SD(; sigma = Σ)\n\n# Calculate portfolio standard deviation\nrisk = calc_risk(sd_rm, w)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._SD","page":"Risk value","title":"PortfolioOptimiser._SD","text":"_SD(w::AbstractVector, Σ::AbstractMatrix)\n\nDescription\n\nCompute the Standard Deviation. This is the square root of _Variance.\n\nbeginalign\nmathrmSD(bmw mathbfSigma) = left(bmw^intercal  mathbfSigma  bmwright)^12\nendalign\n\nSee also: SD, calc_risk(::SD, ::AbstractVector), _Variance, Variance.\n\nInputs\n\nw::AbstractVector: N×1 vector of asset weights.\nΣ::AbstractMatrix: N×N covariance matrix of asset returns.\n\nOutputs\n\nsd::Real: standard deviation.\n\nExamples\n\n# Number of assets\nN = 3\n\n# Create sample covariance matrix\nΣ = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Create weight vector\nw = [0.3, 0.4, 0.3]\n\n# Calculate portfolio standard deviation\nsd = _SD(w, Σ)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{MAD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(mad::MAD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the MAD via _MAD.\n\nSee also: MAD, _MAD.\n\nInputs\n\nPositional\n\nmad::MAD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nmad::Real: mean absolute deviation.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nmad_rm1 = MAD()\nmad_risk1 = calc_risk(mad_rm1, w; X = returns)\n\n# Calculate using mean returns using weighted mean\nmad_rm2 = MAD(; w = eweights(1:size(returns, 1), 0.3))\nmad_risk2 = calc_risk(mad_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._MAD","page":"Risk value","title":"PortfolioOptimiser._MAD","text":"_MAD(x::AbstractVector, w::Union{AbstractWeights, Nothing} = nothing)\n\nDescription\n\nCompute the Mean Absolute Deviation.\n\nbeginalign\nmathrmMAD(bmX) = dfrac1T sumlimits_t=1^T leftlvert X_t - mathbbE(bmX) rightrvert\nendalign\n\nSee also: MAD, calc_risk(::MAD, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nw::Union{AbstractWeights, Nothing} = nothing: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nmad::Real: mean absolute deviation.\n\nBehaviour\n\nIf w is nothing: uses simple arithmetic mean.\nIf w is provided: uses weighted mean for calculating deviations.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the mean absolute deviation with default parameters\nmad1 = _MAD(returns)\n\n# Calculate with weights\nweights = eweights(1:length(return), 0.3)\nmad2 = _MAD(returns, weights)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{Kurt, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(kt::Kurt, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the Kurt via _Kurt.\n\nSee also: Kurt, _Kurt.\n\nInputs\n\nPositional\n\nkurt::Kurt: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nkurt::Real: square root kurtosis.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the square root kurtosis with default parameters\nkurt_rm1 = Kurt()\nkurt_risk1 = calc_risk(kurt_rm1, w; X = returns)\n\n# Calculate the square root kurtosis using a weighted \n# mean returns using weighted mean\nkurt_rm2 = Kurt(; w = eweights(1:size(returns, 1), 0.3))\nkurt_risk2 = calc_risk(kurt_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._Kurt","page":"Risk value","title":"PortfolioOptimiser._Kurt","text":"_Kurt(x::AbstractVector, w::Union{AbstractWeights, Nothing} = nothing; scale::Bool = false)\n\nDescription\n\nCompute the Square Root Kurtosis.\n\nbeginalign\nmathrmKurt(bmX) = left(dfrac1T sumlimits_t=1^T left( X_t - mathbbE(bmX) right)^4 right)^12\nendalign\n\nSee also: Kurt, calc_risk(::Kurt, ::AbstractWeights), risk_contribution.\n\nInputs\n\nPositional\n\nx::AbstractVector: T×1 returns vector.\nw::Union{AbstractWeights, Nothing} = nothing: T×1 optional vector of weights for computing the expected return.\n\nNamed\n\nscale::Bool = false: flag for scaling risk in risk_contribution.\n\nBehaviour\n\nIf w is nothing: uses simple arithmetic mean.\nIf w is provided: uses weighted mean for calculating deviations.\nIf scale is false: no effect.\nIf scale is true: divide by 2, used in risk_contribution.\n\nOutputs\n\nkurt::Real: square root kurtosis.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the square root kurtosis\nkurt1 = _Kurt(returns)\n\n# Calculate the square root kurtosis using weights\nkurt2 = _Kurt(returns, eweights(1:length(returns), 0.3))\n\n# Calculate the square root kurtosis using weights,\n# for use in risk_contribution\nkurt3 = _Kurt(returns, eweights(1:length(returns), 0.1); scale = true)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{RG, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::RG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the RG via _RG.\n\nSee also: RG, RG.\n\nInputs\n\nPositional\n\nrg::RG: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nrg::Real: Gini Mean Difference.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the range with default parameters\nrg_rm = RG()\nrg_risk = calc_risk(rg_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._RG","page":"Risk value","title":"PortfolioOptimiser._RG","text":"_RG(x::AbstractVector)\n\nDescription\n\nCompute the Range.\n\nSee also: RG, calc_risk(::RG, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nrg::Real: Range.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the gini mean difference\nrg = _RG(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{CVaRRG, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rcvar::CVaRRG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the CVaRRG via _CVaRRG.\n\nSee also: CVaRRG, _CVaRRG.\n\nInputs\n\nPositional\n\ncvarrg::CVaRRG: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ncvarrg::Real: Conditional Value at Risk Range.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the conditional value at risk range with default parameters\ncvarrg_rm1 = CVaRRG()\ncvarrg_risk1 = calc_risk(cvarrg_rm1, w; X = returns)\n\n# Calculate conditional value at risk range  with 7 % significance \n# parameter of losses and 32 % significance parameter of gains.\ncvarrg_rm2 = CVaRRG(; alpha = 0.07, beta = 0.32)\ncvarrg_risk2 = calc_risk(cvarrg_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._CVaRRG","page":"Risk value","title":"PortfolioOptimiser._CVaRRG","text":"_CVaRRG(x::AbstractVector; alpha::Real = 0.05, beta::Real = 0.05)\n\nDescription\n\nCompute the Conditional Value at Risk Range.\n\nSee also: CVaRRG, calc_risk(::CVaRRG, ::AbstractVector).\n\nInputs\n\nPositional\n\nx::AbstractVector: T×1 returns vector.\n\nNamed\n\nalpha::Real = 0.05: significance level of losses, alpha ∈ (0, 1).\nbeta::Real = 0.05: significance level of gains, beta ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\nalpha and beta are not validated because this is an internal function. They should have been validated by CVaRRG.\n\nOutputs\n\ncvarrg::Real: Conditional Value at Risk Range.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the conditional value at risk range with default parameters\ncvarrg1 = _CVaRRG(returns)\n\n# Calculate with 7 % significance parameter of losses and\n# 12 % significance parameter of gains.\ncvarrg2 = _CVaRRG(returns; alpha = 0.07, beta = 0.12)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{TGRG, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rtg::TGRG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the TGRG via _TGRG.\n\nSee also: TGRG, _TGRG.\n\nInputs\n\nPositional\n\ntgrg::TGRG: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ntgrg::Real: Tail Gini Range.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the tail gini range with default parameters\ntgrg_rm1 = TGRG()\ntgrg_risk1 = calc_risk(tgrg_rm1, w; X = returns)\n\n# Calculate the tail gini range with custom parameters\ntgrg_rm2 = TGRG(; alpha_i = 0.003, alpha = 0.07, a_sim = 131, beta_i = 0.001, beta = 0.03,\n                b_sim = 97)\ntgrg_risk2 = calc_risk(tgrg_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._TGRG","page":"Risk value","title":"PortfolioOptimiser._TGRG","text":"_TGRG(x::AbstractVector; \n      alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100,\n      beta_i::Real = 0.0001, beta::Real = 0.05, b_sim::Integer = 100)\n\nDescription\n\nCompute the Tail Gini Range.\n\nSee also: TG, calc_risk(::TG, ::AbstractVector).\n\nInputs\n\nPositional\n\nx::AbstractVector: T×1 returns vector.\n\nNamed\n\nalpha_i::Real = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::Real = 0.05: significance level of losses, alpha ∈ (0, 1).\na_sim::Integer = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i::Real = 0.0001: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta::Real = 0.05: end value of the significance level of CVaR gains, beta ∈ (0, 1).\nb_sim = 100: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\nalpha_i, alpha, a_sim, beta_i, beta, and b_sim are not validated because this is an internal function. They should have been validated by TGRG.\n\nOutputs\n\ntgrg::Real: Tail Gini Range.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the tail gini range with default parameters\ntgrg1 = _TGRG(returns)\n\n# Calculate with custom parameters\ntgrg2 = _TGRG(returns; alpha_i = 0.003, alpha = 0.07, a_sim = 131, beta_i = 0.001,\n              beta = 0.03, b_sim = 97)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{GMD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::GMD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the GMD via _GMD.\n\nSee also: GMD, _GMD.\n\nInputs\n\nPositional\n\ngmd::GMD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ngmd::Real: Gini Mean Difference.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the gini mean difference with default parameters\ngmd_rm = GMD()\ngmd_risk = calc_risk(gmd_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._GMD","page":"Risk value","title":"PortfolioOptimiser._GMD","text":"_GMD(x::AbstractVector)\n\nDescription\n\nCompute the Gini Mean Difference.\n\nSee also: GMD, calc_risk(::GMD, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\ngmd::Real: Gini Mean Difference.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the gini mean difference\ngmd = _GMD(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{Union{SSkew, Skew}, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::RMSkew, w::AbstractVector; kwargs...)\n\nDescription\n\nCompute the Skew via _Skew.\n\nSee also: Skew, _Skew.\n\nInputs\n\nPositional\n\nskew::Skew: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nOutputs\n\nskew::Real: Quadratic Skewness.\n\nExamples\n\n# Create sample sum of the symmetric negative spectral slices \n# of the coskewness\nV = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the skew\nskew_rm = Skew()\nskew_risk = calc_risk(skew_rm, w; V = V)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._Skew","page":"Risk value","title":"PortfolioOptimiser._Skew","text":"_Skew(w::AbstractVector, V::AbstractMatrix)\n\nDescription\n\nCompute the Quadratic Skewness/Semi Skewness.\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw is the vector of asset weights.\nmathbfV is the sum of the symmetric negative spectral slices of the coskewness or semicoskewness.\n\nSee also: Skew, calc_risk(::Skew, ::AbstractWeights), SSkew, calc_risk(::SSkew, ::AbstractWeights).\n\nInputs\n\nw::AbstractVector: N×1 vector of weights.\nV::AbstractMatrix: N×N matrix of the sum of negative spectral slices of the coskewness or semi coskewness.\n\nOutputs\n\nskew::Real: quadradic skew or quadratic semi skew.\n\nExamples\n\n# Number of assets\nN = 3\n\n# Create sample sum of negative spectral \n# slices of the coskewness\nV = [0.04 0.02 0.01;\n     0.02 0.09 0.03;\n     0.01 0.03 0.06]\n\n# Create weight vector\nw = [0.3, 0.4, 0.3]\n\n# Calculate portfolio skew\nskew = _Skew(w, V)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{BDVariance, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::BDVariance, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the BDVariance via _BDVariance.\n\nSee also: BDVariance, _BDVariance.\n\nInputs\n\nPositional\n\nbdvariance::BDVariance: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nbdvariance::Real: Brownian Distance Variance.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the Brownian distance variance\nbdvariance_rm = BDVariance()\nbdvariance_risk = calc_risk(bdvariance_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._BDVariance","page":"Risk value","title":"PortfolioOptimiser._BDVariance","text":"_BDVariance(x::AbstractVector)\n\nDescription\n\nCompute the Brownian Distance variance.\n\nbeginalign\nmathrmBDVariance(bmX) = mathrmBDCov(bmX bmX) =  dfrac1T^2 sumlimits_i=1^Tsumlimits_j=1^T A_ij^2\nmathrmBDCov(bmX bmY) = dfrac1T^2 sumlimits_i=1^T sumlimits_j=1^T A_ij B_ij\nA_ij = a_ij - bara_i - bara_j + bara_\nB_ij = b_ij - barb_i - barb_j + barb_\na_ij = lVert X_i - X_j rVert_2 quad forall i j = 1 ldots  T\nb_ij = lVert Y_i - Y_j rVert_2 quad forall i j = 1 ldots  T\nendalign\n\nwhere:\n\nbmX and bmY are random variables, they are equal in this case as they are the portfolio returns.\na_ij and b_ij are entries of a distance matrix where i and j are points in time. Each entry is defined as the Euclidean distance lVert cdot rVert_2 between the value of the random variable at time i and its value at time j.\nbara_icdot and barb_icdot are the i-th row means of their respective matrices.\nbara_cdotj and barb_cdotj are the j-th column means of their respective matrices.\nbara_cdotcdot and barb_cdotcdot are the grand means of their respective matrices.\nA_ij and B_ij are doubly centered distances.\n\nSee also: BDVariance, calc_risk(::BDVariance, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\ndvar::Real: Brownian Distance Variance.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the gini mean difference\nbdvar = _BDVariance(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#Downside-dispersion","page":"Risk value","title":"Downside dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::SVariance, ::AbstractVector)\nPortfolioOptimiser._SVariance\ncalc_risk(::SSD, ::AbstractVector)\nPortfolioOptimiser._SSD\ncalc_risk(::FLPM, ::AbstractVector)\nPortfolioOptimiser._FLPM\ncalc_risk(::SLPM, ::AbstractVector)\nPortfolioOptimiser._SLPM\ncalc_risk(::SKurt, ::AbstractVector)\nPortfolioOptimiser._SKurt","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{SVariance, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(svariance::SVariance, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the SVariance via _SVariance.\n\nSee also: SVariance, _SVariance.\n\nInputs\n\nPositional\n\nsvariance::SVariance: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nsvariance::Real: semi variance.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nsvariance_rm1 = SSD()\nsvariance_risk1 = calc_risk(svariance_rm1, w; X = returns)\n\n# Calculate using mean returns using weighted mean and 1.5 % return target\nsvariance_rm2 = SSD(; w = eweights(1:size(returns, 1), 0.3), target = 0.015)\nsvariance_risk2 = calc_risk(svariance_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._SVariance","page":"Risk value","title":"PortfolioOptimiser._SVariance","text":"_SVariance(x::AbstractVector, r::Real = 0.0, w::Union{AbstractWeights, Nothing} = nothing)\n\nDescription\n\nCompute the Semi Variance. This is the square of _SSD.\n\nbeginalign\nmathrmSVariance(bmX) = dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2\nendalign\n\nSee also: SVariance, calc_risk(::SVariance, ::AbstractVector), _SSD, SSD.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nr::Real = 0.0: minimum return target.\nw::Union{AbstractWeights, Nothing} = nothing: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nsvariance::Real: semi variance.\n\nBehaviour\n\nIf w is nothing: uses simple arithmetic mean.\nIf w is provided: uses weighted mean for calculating deviations.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the semi variance with default parameters\nsv1 = _SVariance(returns)\n\n# Calculate with custom target return\nsv2 = _SVariance(returns, 0.01)\n\n# Calculate with weights\nweights = eweights(1:length(return), 0.3)\nsv3 = _SVariance(returns, 0.01, weights)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{SSD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(ssd::SSD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the SSD via _SSD.\n\nSee also: SSD, _SSD.\n\nInputs\n\nPositional\n\nssd::SSD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nssd::Real: semi standard deviation.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nssd_rm1 = SSD()\nssd_risk1 = calc_risk(ssd_rm1, w; X = returns)\n\n# Calculate using mean returns using weighted mean and 1.5 % return target\nssd_rm2 = SSD(; w = eweights(1:size(returns, 1), 0.3), target = 0.015)\nssd_risk2 = calc_risk(ssd_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._SSD","page":"Risk value","title":"PortfolioOptimiser._SSD","text":"_SSD(x::AbstractVector, r::Real = 0.0, w::Union{AbstractWeights, Nothing} = nothing)\n\nDescription\n\nCompute the Semi Standard Deviation. This is the square root of _SVariance.\n\nbeginalign\nmathrmSSD(bmX) = left(dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2right)^12\nendalign\n\nSee also: SSD, calc_risk(::SSD, ::AbstractVector), _SVariance, SVariance.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nr::Real = 0.0: minimum return target.\nw::Union{AbstractWeights, Nothing} = nothing: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nssd::Real: semi standard deviation.\n\nBehaviour\n\nIf w is nothing: uses simple arithmetic mean.\nIf w is provided: uses weighted mean for calculating deviations.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the semi standard deviation with default parameters\nssd1 = _SSD(returns)\n\n# Calculate with custom target return\nssd2 = _SSD(returns, 0.01)\n\n# Calculate with weights\nweights = eweights(1:length(return), 0.3)\nssd3 = _SSD(returns, 0.01, weights)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{FLPM, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(flpm::FLPM, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the FLPM via _FLPM.\n\nSee also: FLPM, _FLPM.\n\nInputs\n\nPositional\n\nflpm::FLPM: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nflpm::Real: first lower partial moment.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nflpm_rm1 = FLPM()\nflpm_risk1 = calc_risk(flpm_rm1, w; X = returns)\n\n# Calculate using mean returns using a 1.5 % return target\nflpm_rm2 = FLPM(; target = 0.015)\nflpm_risk2 = calc_risk(flpm_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._FLPM","page":"Risk value","title":"PortfolioOptimiser._FLPM","text":"_FLPM(x::AbstractVector, r::Real = 0.0)\n\nDescription\n\nCompute the First Lower Partial Moment (Omega ratio).\n\nbeginalign\nmathrmFLPM(bmX r) = dfrac1T sumlimits_t=1^Tmaxleft(r - X_t 0right)\nendalign\n\nSee also: FLPM, calc_risk(::FLPM, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nr::Real = 0.0: minimum return target.\n\nOutputs\n\nflpm::Real: first lower partial moment.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the first lower partial moment with default parameters\nflpm1 = _FLPM(returns)\n\n# Calculate with custom target return\nflpm2 = _FLPM(returns, 0.01)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{SLPM, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(slpm::SLPM, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the SLPM via _SLPM.\n\nSee also: SLPM, _SLPM.\n\nInputs\n\nPositional\n\nslpm::SLPM: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nslpm::Real: second lower partial moment.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nslpm_rm1 = SLPM()\nslpm_risk1 = calc_risk(slpm_rm1, w; X = returns)\n\n# Calculate using mean returns using a 1.5 % return target\nslpm_rm2 = SLPM(; target = 0.015)\nslpm_risk2 = calc_risk(slpm_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._SLPM","page":"Risk value","title":"PortfolioOptimiser._SLPM","text":"_SLPM(x::AbstractVector, r::Real = 0.0)\n\nDescription\n\nCompute the Second Lower Partial Moment (Sortino Ratio).\n\nbeginalign\nmathrmSLPM(bmX r) = left(dfrac1T-1 sumlimits_t=1^Tmaxleft(r - X_t 0right)^2right)^12\nendalign\n\nSee also: SLPM, calc_risk(::SLPM, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nr::Real = 0.0: minimum return target.\n\nOutputs\n\nslpm::Real: second lower partial moment.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the second lower partial moment with default parameters\nslpm1 = _SLPM(returns)\n\n# Calculate with custom target return\nslpm2 = _SLPM(returns, 0.01)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{SKurt, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(skt::SKurt, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the SKurt via _SKurt.\n\nSee also: SKurt, _SKurt.\n\nInputs\n\nPositional\n\nskurt::SKurt: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nskurt::Real: square root semi.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the square root semi kurtosis with default parameters\nskurt_rm1 = SKurt()\nskurt_risk1 = calc_risk(skurt_rm1, w; X = returns)\n\n# Calculate the square root semi kurtosis using mean returns using a \n# weighted mean and 1.5 % return target\nskurt_rm2 = SKurt(; w = eweights(1:size(returns, 1), 0.3), target = 0.015)\nskurt_risk2 = calc_risk(skurt_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._SKurt","page":"Risk value","title":"PortfolioOptimiser._SKurt","text":"_SKurt(x::AbstractVector, r::Real = 0.0, w::Union{AbstractWeights, Nothing} = nothing; scale::Bool = false)\n\nDescription\n\nCompute the Square Root Semi Kurtosis.\n\nbeginalign\nmathrmSKurt(bmX) = left(dfrac1T sumlimits_t=1^T minleft( X_t - mathbbE(bmX) r right)^4 right)^12\nendalign\n\nSee also: SKurt, calc_risk(::SKurt, ::AbstractWeights), risk_contribution.\n\nInputs\n\nPositional\n\nx::AbstractVector: T×1 returns vector.\nr::Real = 0.0: minimum return threshold for downside classification.\nw::Union{AbstractWeights, Nothing} = nothing: T×1 optional vector of weights for computing the expected return.\n\nNamed\n\nscale::Bool = false: flag for scaling risk in risk_contribution.\n\nBehaviour\n\nIf w is nothing: uses simple arithmetic mean.\nIf w is provided: uses weighted mean for calculating deviations.\nIf scale is false: no effect.\nIf scale is true: divide by 2, used in risk_contribution.\n\nOutputs\n\nskurt::Real: square root semi kurtosis.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the square root kurtosis\nskurt1 = _SKurt(returns)\n\n# Calculate the square root semi kurtosis using weights\nskurt2 = _SKurt(returns, eweights(1:length(returns), 0.3))\n\n# Calculate the square root semi kurtosis using weights,\n# for use in risk_contribution\nskurt3 = _SKurt(returns, eweights(1:length(returns), 0.1); scale = true)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#Downside","page":"Risk value","title":"Downside","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::WR, ::AbstractVector)\nPortfolioOptimiser._WR\ncalc_risk(::VaR, ::AbstractVector)\nPortfolioOptimiser._VaR\ncalc_risk(::CVaR, ::AbstractVector)\nPortfolioOptimiser._CVaR\nPortfolioOptimiser.ERM\ncalc_risk(::EVaR, ::AbstractVector)\nPortfolioOptimiser._EVaR\nPortfolioOptimiser.RRM\ncalc_risk(::RLVaR, ::AbstractVector)\nPortfolioOptimiser._RLVaR\ncalc_risk(::TG, ::AbstractVector)\nPortfolioOptimiser._TG","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{WR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::WR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the WR via _WR.\n\nSee also: WR, _WR.\n\nInputs\n\nPositional\n\nwr::WR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nwr::Real: worst realisation.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the mean absolute deviation with default parameters\nwr_rm = WR()\nwr_risk = calc_risk(wr_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._WR","page":"Risk value","title":"PortfolioOptimiser._WR","text":"_WR(x::AbstractVector)\n\nDescription\n\nCompute the Worst Realisation or Worst Case Scenario.\n\nbeginalign\nmathrmWR(bmX) = -min(bmX)\nendalign\n\nSee also: WR, calc_risk(::WR, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nwr::Real: worst realisation.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the worst realisation with default parameters\nwr1 = _WR(returns)\n\n# Calculate with custom target return\nwr2 = _WR(returns, 0.01)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{VaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(var::VaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the VaR via _VaR.\n\nSee also: VaR, _VaR.\n\nInputs\n\nPositional\n\nvar::VaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nvar::Real: Value at Risk.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the value at risk with default parameters\nvar_rm1 = VaR()\nvar_risk1 = calc_risk(var_rm1, w; X = returns)\n\n# Calculate the value at risk with 50 % significance parameter\nvar_rm2 = VaR(; alpha = 0.5)\nvar_risk2 = calc_risk(var_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._VaR","page":"Risk value","title":"PortfolioOptimiser._VaR","text":"_VaR(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Value at Risk.\n\nbeginalign\nmathrmVaR(bmX alpha) = -undersett in (0 T)inf left X_t in mathbbR    F_bmX(X_t)  alpha right\nendalign\n\nSee also: VaR, calc_risk(::VaR, ::AbstractVector), _CVaR, calc_risk(::CVaR, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\nα is not validated because this is an internal function. It should have been validated by VaR.\n\nOutputs\n\nvar::Real: Value at Risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the value at risk with default parameters\nvar1 = _VaR(returns)\n\n# Calculate with 7 % significance parameter\nvar2 = _VaR(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{CVaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(cvar::CVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the CVaR via _CVaR.\n\nSee also: CVaR, _CVaR.\n\nInputs\n\nPositional\n\ncvar::CVaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ncvar::Real: Conditional Value at Risk.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the conditional value at risk with default parameters\ncvar_rm1 = CVaR()\ncvar_risk1 = calc_risk(cvar_rm1, w; X = returns)\n\n# Calculate the conditional value at risk with 50 % significance parameter\ncvar_rm2 = CVaR(; alpha = 0.5)\ncvar_risk2 = calc_risk(cvar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._CVaR","page":"Risk value","title":"PortfolioOptimiser._CVaR","text":"_CVaR(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Conditional Value at Risk.\n\nbeginalign\nmathrmCVaR(bmX alpha) = mathrmVaR(bmX alpha) + dfrac1alpha T sumlimits_t=1^T maxleft(-X_t - mathrmVaR(bmX alpha) 0right)\nendalign\n\nWhere:\n\nmathrmVaR(bmX alpha) is the Value at Risk as defined in _VaR.\n\nSee also: CVaR, calc_risk(::CVaR, ::AbstractVector), _VaR, calc_risk(::VaR, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\nα is not validated because this is an internal function. It should have been validated by CVaR.\n\nOutputs\n\ncvar::Real: Conditional Value at Risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the conditional value at risk with default parameters\ncvar1 = _CVaR(returns)\n\n# Calculate with 7 % significance parameter\ncvar2 = _CVaR(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.ERM","page":"Risk value","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector, z::Real = 1.0, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = z ln left(dfracM_bmXleft(z^-1right)alpha right)\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nalpha in (01) is the significance parameter.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nz::Real = 1.0: entropic moment, can be obtained from get_z_from_model and get_z after optimising a Portfolio.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic risk measure with default parameters\ner1 = ERM(returns, 2.3, 0.03)\n\n# Calculate with a 2.3 entropic moment and 3 % significance parameter\ner2 = ERM(returns, 2.3, 0.03)\n\n\n\n\n\nERM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = \n    begincases\n        undersetz t uinf  t + z lnleft(dfrac1alpha Tright)\n        mathrmst  z geq sumlimits_i=1^T u_inonumber\n         (-X_i-t z u_i) in mathcalK_exp  forall  i=1dots T\n    endcases\n= undersetz0infleft z ln left(dfracM_bmXleft(z^-1right)alpha right)right\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nmathcalK_mathrmexp is the exponential cone.\nalpha in (01) is the significance parameter.\n\nSee also: EVaR, calc_risk(::EVaR, ::AbstractVector), _EVaR, EDaR, calc_risk(::EDaR, ::AbstractVector), _EDaR, EDaR_r, calc_risk(::EDaR_r, ::AbstractVector), _EDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EVaR, EDaR, or EDaR_r.\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic risk measure with default parameters\ner1 = ERM(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter\ner2 = ERM(returns, Dict(\"solver\" => my_solver), 0.03)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{EVaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(evar::EVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the EVaR via _EVaR.\n\nSee also: EVaR, _EVaR.\n\nInputs\n\nPositional\n\nevar::EVaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nevar::Real: Entropic Value at Risk.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the entropic value at risk with default parameters\nevar_rm1 = EVaR(; solvers = my_solvers)\nevar_risk1 = calc_risk(evar_rm1, w; X = returns)\n\n# Calculate the entropic value at risk with 50 % significance parameter\nevar_rm2 = EVaR(; solvers = my_solvers, alpha = 0.5)\nevar_risk2 = calc_risk(evar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._EVaR","page":"Risk value","title":"PortfolioOptimiser._EVaR","text":"_EVaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Value at Risk.\n\nbeginalign\nmathrmEVaR(bmXalpha) = undersetz  0inf leftmathrmERM(bmX z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(bmX z alpha) is the entropic risk measure as defined in ERM.\n\nSee also: ERM, calc_risk(::EVaR, ::AbstractVector), _EVaR.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EVaR.\n\nOutputs\n\nevar::Real: Entropic Value at Risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic value at risk with default parameters\nevar1 = _EVaR(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter\nevar2 = _EVaR(returns, Dict(\"solver\" => my_solver), 0.03)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.RRM","page":"Risk value","title":"PortfolioOptimiser.RRM","text":"RRM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nDescription\n\nCompute the Relativistic Risk Measure. Used in _RLVaR, _RLDaR and _RLDaR_r.\n\nbeginalign\nmathrmRRM(Xalphakappa) = left\n    beginalign\n        undersetz t psi theta  varepsilon omegatextinf  t + z ln_kappa left(dfrac1alpha Tright) + sumlimits_i=1^T left(psi_i + theta_i  right) nonumber\n        mathrmst  -X  - t + varepsilon + omega leq 0 nonumber\n        z geq 0 \n        left( zleft(dfrac1+kappa2kapparight) psi_ileft(dfrac1+kappakapparight) varepsilon_i right) in mathcalP_3^1(1+kappa) kappa(1+kappa)nonumber\n        left( omega_ileft(dfrac11-kapparight) theta_ileft(dfrac1kapparight) -z left(dfrac12kapparight) right) in mathcalP_3^1-kappa kappanonumber\n        forall  i=1dots T nonumber\n    endalign\nright\nendalign\n\nWhere:\n\nmathcalP_3^alpha 1-alpha is the 3D power cone.\nalpha in (01) is the significance parameter.\nkappa in (01) is the relativistic deformation parameter.\n\nSee also: RLVaR, calc_risk(::RLVaR, ::AbstractVector), _RLVaR, RLDaR, calc_risk(::RLDaR, ::AbstractVector), _RLDaR, RLDaR_r, calc_risk(::RLDaR_r, ::AbstractVector), _RLDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for 3D power cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: relativistic deformation parameter, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLVaR, RLDaR, or RLDaR_r.\n\nOutputs\n\nrlr::Real: relativistic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the relativistic risk with default parameters\nrlr1 = RRM(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter and 80 % deformation parameter\nrlr2 = RRM(returns, Dict(\"solver\" => my_solver), 0.03, 0.8)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{RLVaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rlvar::RLVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the RLVaR via _RLVaR.\n\nSee also: RLVaR, _RLVaR.\n\nInputs\n\nPositional\n\nrlvar::RLVaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nrlvar::Real: Relativistic Value at Risk.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the relativistic value at risk with default parameters\nrlvar_rm1 = RLVaR(; solvers = my_solvers)\nrlvar_risk1 = calc_risk(rlvar_rm1, w; X = returns)\n\n# Calculate the relativistic value at risk with 50 % significance parameter\n# and 15 % deformation parameter.\nrlvar_rm2 = RLVaR(; solvers = my_solvers, alpha = 0.5, kappa = 0.15)\nrlvar_risk2 = calc_risk(rlvar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._RLVaR","page":"Risk value","title":"PortfolioOptimiser._RLVaR","text":"_RLVaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nDescription\n\nCompute the Relativistic Value at Risk.\n\nbeginalign\nmathrmRLVaR(bmX alpha kappa) = mathrmRRM(bmX alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(bmX alpha kappa) is the Relativistic Risk Measure as defined in RRM.\n\nSee also: RRM, RLVaR, calc_risk(::RLVaR, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for 3D power cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: relativistic deformation parameter, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLVaR.\n\nOutputs\n\nrlvar::Real: Relativistic Value at Risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the relativistic value at risk with default parameters\nrlvar1 = _RLVaR(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter and 80 % deformation parameter\nrlvar2 = _RLVaR(returns, Dict(\"solver\" => my_solver), 0.03, 0.8)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{TG, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(tg::TG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the TG via _TG.\n\nSee also: TG, _TG.\n\nInputs\n\nPositional\n\ntg::TG: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ntg::Real: Tail Gini.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the tail gini with default parameters\ntg_rm1 = TG()\ntg_risk1 = calc_risk(tg_rm1, w; X = returns)\n\n# Calculate the tail gini with custom parameters\ntg_rm2 = TG(; alpha_i = 0.003, alpha = 0.07, a_sim = 131)\ntg_risk2 = calc_risk(tg_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._TG","page":"Risk value","title":"PortfolioOptimiser._TG","text":"_TG(x::AbstractVector; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100)\n\nDescription\n\nCompute the Tail Gini.\n\nSee also: TG, calc_risk(::TG, ::AbstractVector).\n\nInputs\n\nPositional\n\nx::AbstractVector: T×1 returns vector.\n\nNamed\n\nalpha_i::Real = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::Real = 0.05: significance level of losses, alpha ∈ (0, 1).\na_sim::Integer = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\nalpha_i, alpha, and a_sim are not validated because this is an internal function. They should have been validated by TG.\n\nOutputs\n\ntg::Real: Tail Gini.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the tail gini with default parameters\ntg1 = _TG(returns)\n\n# Calculate with custom parameters\ntg2 = _TG(returns; alpha_i = 0.003, alpha = 0.07, a_sim = 131)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::DaR, ::AbstractVector)\nPortfolioOptimiser._DaR\ncalc_risk(::MDD, ::AbstractVector)\nPortfolioOptimiser._MDD\ncalc_risk(::ADD, ::AbstractVector)\nPortfolioOptimiser._ADD\ncalc_risk(::CDaR, ::AbstractVector)\nPortfolioOptimiser._CDaR\ncalc_risk(::UCI, ::AbstractVector)\nPortfolioOptimiser._UCI\ncalc_risk(::EDaR, ::AbstractVector)\nPortfolioOptimiser._EDaR\ncalc_risk(::RLDaR, ::AbstractVector)\nPortfolioOptimiser._RLDaR\ncalc_risk(::DaR_r, ::AbstractVector)\nPortfolioOptimiser._DaR_r\ncalc_risk(::MDD_r, ::AbstractVector)\nPortfolioOptimiser._MDD_r\ncalc_risk(::ADD_r, ::AbstractVector)\nPortfolioOptimiser._ADD_r\ncalc_risk(::CDaR_r, ::AbstractVector)\nPortfolioOptimiser._CDaR_r\ncalc_risk(::UCI_r, ::AbstractVector)\nPortfolioOptimiser._UCI_r\ncalc_risk(::EDaR_r, ::AbstractVector)\nPortfolioOptimiser._EDaR_r\ncalc_risk(::RLDaR_r, ::AbstractVector)\nPortfolioOptimiser._RLDaR_r","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{DaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(dar::DaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the DaR via _DaR.\n\nSee also: DaR, _DaR.\n\nInputs\n\nPositional\n\ndar::DaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ndar::Real: Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of uncompounded cumulative \n# returns with default parameters\ndar_rm1 = DaR()\ndar_risk1 = calc_risk(dar_rm1, w; X = returns)\n\n# Calculate the drawdown at risk of uncompounded cumulative \n# returns with 50 % significance parameter\ndar_rm2 = DaR(; alpha = 0.5)\ndar_risk2 = calc_risk(dar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._DaR","page":"Risk value","title":"PortfolioOptimiser._DaR","text":"_DaR(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmDaR_a(bmX alpha) = undersetj in (0 T)max left mathrmDD_a(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_a(bmX j)right)  1 - alpha right\nmathrmDD_a(bmX j) = undersett in (0 j)maxleft( sumlimits_i=0^t X_i right) - sumlimits_i=0^j X_i\nmathrmDD_a(bmX) = leftj in (0T)    mathrmDD_a(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns.\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j.\nmathrmDaR_a(bmX alpha) the Drawdown at Risk of uncompounded cumulative returns.\n\nSee also: DaR, calc_risk(::DaR, ::AbstractVector), DaR_r, calc_risk(::DaR_r, ::AbstractVector), _CDaR, calc_risk(::CDaR, ::AbstractVector), _CDaR_r, calc_risk(::CDaR_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by DaR.\n\nOutputs\n\ndar::Real: Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the drawdown of uncompounded cumulative returns with default parameters\ndar1 = _DaR(returns)\n\n# Calculate with 7 % significance parameter\ndar2 = _DaR(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{MDD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::MDD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the MDD via _MDD.\n\nSee also: MDD, _MDD.\n\nInputs\n\nPositional\n\nmdd::MDD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nmdd::Real: Maximum Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of uncompounded cumulative \n# returns\nmdd_rm = MDD()\nmdd_risk = calc_risk(mdd_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._MDD","page":"Risk value","title":"PortfolioOptimiser._MDD","text":"_MDD(x::AbstractVector)\n\nDescription\n\nCompute the Maximum Drawdown (Calmar ratio) of uncompounded cumulative returns.\n\nbeginalign\nmathrmMDD_a(bmX) = maxmathrmDD_a(bmX)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nSee also: MDD, calc_risk(::MDD, ::AbstractVector), MDD_r, calc_risk(::MDD_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nmdd::Real: Maximum Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate maximum drawdown of uncompounded cumulative returns\nmdd = _MDD(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{ADD, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::ADD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the ADD via _ADD.\n\nSee also: ADD, _ADD.\n\nInputs\n\nPositional\n\nadd::ADD: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nadd::Real: Average Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of uncompounded cumulative \n# returns with default parameters\nadd_rm = ADD()\nadd_risk = calc_risk(add_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._ADD","page":"Risk value","title":"PortfolioOptimiser._ADD","text":"_ADD(x::AbstractVector)\n\nDescription\n\nCompute the Average Drawdown of uncompounded cumulative returns.\n\nbeginalign\nmathrmADD_a(bmX) = dfrac1T sumlimits_j=1^T mathrmDD_a(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR.\n\nSee also: ADD, calc_risk(::ADD, ::AbstractVector), ADD_r, calc_risk(::ADD_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nadd::Real: Average Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate average drawdown of uncompounded cumulative returns\nadd = _ADD(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{CDaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(cdar::CDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the CDaR via _CDaR.\n\nSee also: CDaR, _CDaR.\n\nInputs\n\nPositional\n\ncdar::CDaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ncdar::Real: Conditional Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the conditional drawdown at risk of uncompounded cumulative \n# returns with default parameters\ncdar_rm1 = CDaR()\ncdar_risk1 = calc_risk(cdar_rm1, w; X = returns)\n\n# Calculate the conditional drawdown at risk of uncompounded cumulative \n# returns with 50 % significance parameter\ncdar_rm2 = CDaR(; alpha = 0.5)\ncdar_risk2 = calc_risk(cdar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._CDaR","page":"Risk value","title":"PortfolioOptimiser._CDaR","text":"_CDaR(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Conditional Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmCDaR_a(bmX alpha) = mathrmDaR_a(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_a(bmX j) - mathrmDaR_a(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR.\nmathrmDaR_a(bmX alpha) is the Drawdown at Risk of uncompounded cumulative returns as defined in _DaR.\n\nSee also: CDaR, calc_risk(::CDaR, ::AbstractVector), _DaR, calc_risk(::DaR, ::AbstractVector), CDaR_r, calc_risk(::CDaR_r, ::AbstractVector), _DaR_r, calc_risk(::DaR_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by CDaR.\n\nOutputs\n\ncdar::Real: Conditional Drawdown at Risk of uncompounded cumulative returns..\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the conditional drawdown at risk of \n# uncompounded cumulative returns with default parameters\ncdar1 = _CDaR(returns)\n\n# Calculate with 7 % significance parameter\ncdar2 = _CDaR(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{UCI, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::UCI, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the UCI via _UCI.\n\nSee also: UCI, _UCI.\n\nInputs\n\nPositional\n\nuci::UCI: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nuci::Real: Ulcer Index of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the ulcer index at risk of uncompounded cumulative \n# returns with default parameters\nuci_rm = UCI()\nuci_risk = calc_risk(uci_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._UCI","page":"Risk value","title":"PortfolioOptimiser._UCI","text":"_UCI(x::AbstractVector)\n\nDescription\n\nCompute the Ulcer Index of uncompounded cumulative returns.\n\nbeginalign\nmathrmUCI_a(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_a(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR.\n\nSee also: UCI, calc_risk(::UCI, ::AbstractVector), UCI_r, calc_risk(::UCI_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nuci::Real: Ulcer Index of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate ulcer index of uncompounded cumulative returns\nuci = _UCI(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{EDaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(edar::EDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the EDaR via _EDaR.\n\nSee also: EDaR, _EDaR.\n\nInputs\n\nPositional\n\nedar::EDaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nedar::Real: Entropic Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the entropic drawdown at risk of uncompounded cumulative \n# returns with default parameters\nedar_rm1 = EDaR(; solvers = my_solvers)\nedar_risk1 = calc_risk(edar_rm1, w; X = returns)\n\n# Calculate the entropic drawdown at risk of uncompounded cumulative\n# returns with 50 % significance parameter\nedar_rm2 = EDaR(; solvers = my_solvers, alpha = 0.5)\nedar_risk2 = calc_risk(edar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._EDaR","page":"Risk value","title":"PortfolioOptimiser._EDaR","text":"_EDaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmEDaR_a(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_a(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_a(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nSee also: ERM, calc_risk(::EDaR, ::AbstractVector), _EDaR, EDaR_r, calc_risk(::EDaR_r, ::AbstractVector), _EDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EDaR.\n\nOutputs\n\nedar::Real: Entropic Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic drawdown at risk of \n# uncompounded cumulative returns with default parameters\nedar1 = _EDaR(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter\nedar2 = _EDaR(returns, Dict(\"solver\" => my_solver), 0.03)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{RLDaR, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rldar::RLDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the RLDaR via _RLDaR.\n\nSee also: RLDaR, _RLDaR.\n\nInputs\n\nPositional\n\nrldar::RLDaR: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nrldar::Real: Relativistic Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the entropic drawdown at risk of uncompounded cumulative \n# returns with default parameters\nrldar_rm1 = RLDaR(; solvers = my_solvers)\nrldar_risk1 = calc_risk(rldar_rm1, w; X = returns)\n\n# Calculate the entropic drawdown at risk of uncompounded cumulative\n# returns with 50 % significance parameter\nrldar_rm2 = RLDaR(; solvers = my_solvers, alpha = 0.5)\nrldar_risk2 = calc_risk(rldar_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._RLDaR","page":"Risk value","title":"PortfolioOptimiser._RLDaR","text":"_RLDaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nDescription\n\nCompute the Relativistic Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmRLDaR_a(bmX alpha kappa) = mathrmRRM(mathrmDD_a(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_a(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nSee also: RRM, calc_risk(::RLDaR, ::AbstractVector), _RLDaR, RLDaR_r, calc_risk(::RLDaR_r, ::AbstractVector), _RLDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: significance level, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLDaR.\n\nOutputs\n\nrldar::Real: Relativistic Drawdown at Risk of uncompounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic drawdown at risk of \n# uncompounded cumulative returns with default parameters\nrldar1 = _RLDaR(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter and 75 % deformation parameter\nrldar2 = _RLDaR(returns, Dict(\"solver\" => my_solver), 0.03, 0.75)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{DaR_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(dar_r::DaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the DaR_r via _DaR_r.\n\nSee also: DaR_r, _DaR_r.\n\nInputs\n\nPositional\n\ndar_r::DaR_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ndar_r::Real: Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of compounded cumulative \n# returns with default parameters\ndar_r_rm1 = DaR_r()\ndar_r_risk1 = calc_risk(dar_r_rm1, w; X = returns)\n\n# Calculate the drawdown at risk of compounded cumulative \n# returns with 50 % significance parameter\ndar_r_rm2 = DaR_r(; alpha = 0.5)\ndar_r_risk2 = calc_risk(dar_r_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._DaR_r","page":"Risk value","title":"PortfolioOptimiser._DaR_r","text":"DaRr(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmDaR_r(bmX alpha) = undersetj in (0 T)max left mathrmDD_r(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_r(bmX j)right)  1 - alpha right\nmathrmDD_r(bmX j) = undersett in (0 j)maxleft( prodlimits_i=0^t left(1+X_iright) right) - prodlimits_i=0^j left(1+X_iright)\nmathrmDD_r(bmX) = leftj in (0T)    mathrmDD_r(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns.\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns.\n\nSee also: DaR, calc_risk(::DaR, ::AbstractVector), DaR_r, calc_risk(::DaR_r, ::AbstractVector), _CDaR, calc_risk(::CDaR, ::AbstractVector), _CDaR_r, calc_risk(::CDaR_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by DaR.\n\nOutputs\n\ndar_r::Real: Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the drawdown of compounded cumulative returns with default parameters\ndar_r1 = _DaR_r(returns)\n\n# Calculate with 7 % significance parameter\ndar_r2 = _DaR_r(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{MDD_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::MDD_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the MDD_r via _MDD_r.\n\nSee also: MDD_r, _MDD_r.\n\nInputs\n\nPositional\n\nmdd_r::MDD_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nmdd_r::Real: Maximum Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of compounded cumulative \n# returns\nmdd_r_rm = MDD_r()\nmdd_r_risk = calc_risk(mdd_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._MDD_r","page":"Risk value","title":"PortfolioOptimiser._MDD_r","text":"_MDD_r(x::AbstractVector)\n\nDescription\n\nCompute the Maximum Drawdown of compounded cumulative returns.\n\nbeginalign\nmathrmMDD_r(bmX) = max mathrmDD_r(bmX)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nSee also: MDD, calc_risk(::MDD, ::AbstractVector), MDD_r, calc_risk(::MDD_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nmdd_r::Real: Maximum Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate maximum drawdown of compounded cumulative returns\nmdd_r = _MDD_r(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{ADD_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::ADD_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the ADD_r via _ADD_r.\n\nSee also: ADD_r, _ADD_r.\n\nInputs\n\nPositional\n\nadd_r::ADD_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nadd_r::Real: Average Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the drawdown at risk of compounded cumulative \n# returns with default parameters\nadd_r_rm = ADD_r()\nadd_r_risk = calc_risk(add_r_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._ADD_r","page":"Risk value","title":"PortfolioOptimiser._ADD_r","text":"_ADD_r(x::AbstractVector)\n\nDescription\n\nCompute the Average Drawdown of compounded cumulative returns.\n\nbeginalign\nmathrmADD_r(bmX) = dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\n\nSee also: ADD, calc_risk(::ADD, ::AbstractVector), ADD_r, calc_risk(::ADD_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nadd_r::Real: Average Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate average drawdown of compounded cumulative returns\nadd = _ADD_r(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{CDaR_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calcrisk(cdarr::CDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the CDaR_r via _CDaR_r.\n\nSee also: CDaR_r, _CDaR_r.\n\nInputs\n\nPositional\n\ncdar::CDaR_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\ncdar_r::Real: Conditional Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the conditional drawdown at risk of compounded cumulative \n# returns with default parameters\ncdar_r_rm1 = CDaR_r()\ncdar_r_risk1 = calc_risk(cdar_r_rm1, w; X = returns)\n\n# Calculate the conditional drawdown at risk of compounded cumulative \n# returns with 50 % significance parameter\ncdar_r_rm2 = CDaR_r(; alpha = 0.5)\ncdar_r_risk2 = calc_risk(cdar_r_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._CDaR_r","page":"Risk value","title":"PortfolioOptimiser._CDaR_r","text":"_CDaR_r(x::AbstractVector, α::Real = 0.05)\n\nDescription\n\nCompute the Conditional Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmCDaR_r(bmX alpha) = mathrmDaR_r(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_r(bmX j) - mathrmDaR_r(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns as defined in _DaR_r.\n\nSee also: CDaR, calc_risk(::CDaR, ::AbstractVector), _DaR, calc_risk(::DaR, ::AbstractVector), CDaR_r, calc_risk(::CDaR_r, ::AbstractVector), _DaR_r, calc_risk(::DaR_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by CDaR_r.\n\nOutputs\n\ncdar_r::Real: Conditional Drawdown at Risk of compounded cumulative returns..\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the conditional drawdown at risk of \n# compounded cumulative returns with default parameters\ncdar_r1 = _CDaR_r(returns)\n\n# Calculate with 7 % significance parameter\ncdar_r2 = _CDaR_r(returns, 0.07)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{UCI_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::UCI_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the UCI_r via _UCI_r.\n\nSee also: UCI_r, _UCI_r.\n\nInputs\n\nPositional\n\nuci_r::UCI_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nuci_r::Real: Ulcer Index of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the ulcer index at risk of compounded cumulative \n# returns with default parameters\nuci_r_rm = UCI_r()\nuci_r_risk = calc_risk(uci_r_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._UCI_r","page":"Risk value","title":"PortfolioOptimiser._UCI_r","text":"_UCI_r(x::AbstractVector)\n\nDescription\n\nCompute the Ulcer Index of compounded cumulative returns.\n\nbeginalign\nmathrmUCI_r(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\n\nSee also: UCI, calc_risk(::UCI, ::AbstractVector), UCI_r, calc_risk(::UCI_r, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\n\nOutputs\n\nuci_r::Real: Ulcer Index of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate ulcer index of compounded cumulative returns\nuci_r = _UCI_r(returns)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{EDaR_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(edar_r::EDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the EDaR_r via _EDaR_r.\n\nSee also: EDaR_r, _EDaR_r.\n\nInputs\n\nPositional\n\nedar_r::EDaR_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nedar_r::Real: Entropic Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the entropic drawdown at risk of compounded cumulative \n# returns with default parameters\nedar_r_rm1 = EDaR_r(; solvers = my_solvers)\nedar_r_risk1 = calc_risk(edar_r_rm1, w; X = returns)\n\n# Calculate the entropic drawdown at risk of compounded cumulative\n# returns with 50 % significance parameter\nedar_r_rm2 = EDaR_r(; solvers = my_solvers, alpha = 0.5)\nedar_r_risk2 = calc_risk(edar_r_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._EDaR_r","page":"Risk value","title":"PortfolioOptimiser._EDaR_r","text":"_EDaR_r(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmEDaR_r(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_r(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_r(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nSee also: ERM, calc_risk(::EDaR, ::AbstractVector), _EDaR, EDaR_r, calc_risk(::EDaR_r, ::AbstractVector), _EDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EDaR_r.\n\nOutputs\n\nedar_r::Real: Entropic Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic drawdown at risk of \n# compounded cumulative returns with default parameters\nedar_r1 = _EDaR_r(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter\nedar_r2 = _EDaR_r(returns, Dict(\"solver\" => my_solver), 0.03)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{RLDaR_r, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rldar_r::RLDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the RLDaR_r via _RLDaR_r.\n\nSee also: RLDaR_r, _RLDaR_r.\n\nInputs\n\nPositional\n\nrldar_r::RLDaR_r: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nrldar_r::Real: Relativistic Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the relativistic drawdown at risk of compounded cumulative \n# returns with default parameters\nrldar_r_rm1 = RLDaR_r(; solvers = my_solvers)\nrldar_r_risk1 = calc_risk(rldar_r_rm1, w; X = returns)\n\n# Calculate the relativistic drawdown at risk of compounded cumulative\n# returns with 50 % significance parameter\nrldar_r_rm2 = RLDaR_r(; solvers = my_solvers, alpha = 0.5)\nrldar_r_risk2 = calc_risk(rldar_r_rm2, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._RLDaR_r","page":"Risk value","title":"PortfolioOptimiser._RLDaR_r","text":"_RLDaR_r(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nDescription\n\nCompute the Relativistic Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nSee also: RRM, calc_risk(::RLDaR, ::AbstractVector), _RLDaR, RLDaR_r, calc_risk(::RLDaR_r, ::AbstractVector), _RLDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: significance level, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLDaR.\n\nOutputs\n\nrldar_r::Real: Relativistic Drawdown at Risk of compounded cumulative returns.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic drawdown at risk of \n# compounded cumulative returns with default parameters\nrldar_r1 = _RLDaR_r(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter and 75 % deformation parameter\nrldar_r2 = _RLDaR_r(returns, Dict(\"solver\" => my_solver), 0.03, 0.75)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#Linear-moments-(L-moments)","page":"Risk value","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"This is used to measure linear moments of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::OWA, ::AbstractVector)\nPortfolioOptimiser._OWA","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{OWA, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(owa::OWA, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nDescription\n\nCompute the OWA via _OWA.\n\nSee also: OWA, _OWA.\n\nInputs\n\nPositional\n\nowa::OWA: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix: T×N matrix of asset returns.\n\nOutputs\n\nowa::Real: Ordered Weight Array risk.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the ordered weight array risk for the default L-moment\nowa_rm = OWA(; w = owa_l_moment_crm(size(returns, 1)))\nowa_risk = calc_risk(owa_rm, w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser._OWA","page":"Risk value","title":"PortfolioOptimiser._OWA","text":"_OWA(x::AbstractVector, w::AbstractVector)\n\nDescription\n\nCompute the Ordered Weight Array risk measure.\n\nSee also: OWA, calc_risk(::OWA, ::AbstractVector).\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nw::AbstractVector: T×1 precomputed vector of OWA weights. Can be computed with owa_gmd, owa_rg, owa_rcvar, owa_tg, owa_rtg, owa_l_moment or owa_l_moment_crm.\n\nBehaviour\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nowa::Real: Ordered Weight Array risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\nw = owa_l_moment_crm(length(returns))\n\n# Calculate the tail gini range with default parameters\nowa = _OWA(returns, w)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#Equal-risk-contribution","page":"Risk value","title":"Equal risk contribution","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"This assumes the risk is equally distributed among the variables.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk(::Equal, ::AbstractVector)","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk-Tuple{Equal, AbstractVector}","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::Equal, w::AbstractVector; delta::Real = 0, kwargs...)\n\nDescription\n\nCompute the risk as the inverse of the length of w.\n\nInputs\n\nPositional\n\nequal::Equal: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\ndelta::Real: is a displacement, used in risk_contribution and factor_risk_contribution.\n\nOutputs\n\nequal::Real: Equal Risk.\n\nExamples\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the equal risk measure\nequal_rm = Equal()\nequal_risk = calc_risk(equal_rm, w)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClusterNode","page":"Clustering","title":"PortfolioOptimiser.ClusterNode","text":"struct ClusterNode{tid, tl, tr, td, tcnt}\n    id::tid\n    left::tl\n    right::tr\n    height::td\n    level::tcnt\n\n    function ClusterNode(id, left::Union{ClusterNode, Nothing} = nothing,\n                         right::Union{ClusterNode, Nothing} = nothing, height::Real = 0.0,\n                         level::Int = 1)\n        ilevel = isnothing(left) ? level : (left.level + right.level)\n\n        return new{typeof(id), typeof(left), typeof(right), typeof(height), typeof(level)}(id,\n                                                                                         left,\n                                                                                         right,\n                                                                                         height,\n                                                                                         ilevel)\n    end\nend\n\nStructure for definining a cluster node. This is used for turning a clustering result into a tree, is_leaf, pre_order, to_tree.\n\nParameters\n\nid: node ID.\nleft: node to the left.\nright: node to the right.\nheight: node height.\nlevel: node level.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHT","page":"Clustering","title":"PortfolioOptimiser.DBHT","text":"mutable struct DBHT <: HClustAlg\n    distance::DistMethod\n    similarity::DBHTSimilarity\n    root_method::DBHTRootMethod\nend\n\nDefines the parameters for computing DBHTs [4].\n\nParameters\n\ndistance: method for computing the distance matrix from correlation ones DistMethod.\nsimilarity: method for computing the similarity matrix from the correlation and/or distance ones DBHTSimilarity, dbht_similarity.\nroot_method: method for choosing clique roots DBHTRootMethod.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTExp","page":"Clustering","title":"PortfolioOptimiser.DBHTExp","text":"struct DBHTExp <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise exponential decay of the dissimilarity matrix in dbht_similarity.\n\nbeginalign\nS_ij = exp(-D_ij)\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTMaxDist","page":"Clustering","title":"PortfolioOptimiser.DBHTMaxDist","text":"struct DBHTMaxDist <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise squared distance from the maximum value of the dissimilarity matrix dbht_similarity.\n\nbeginalign\nS_ij = leftlceil (max mathbfD)^2 rightrceil - D_ij ^ 2\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\nmathbfD is the distance matrix.\n\n\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.EqualDBHT","page":"Clustering","title":"PortfolioOptimiser.EqualDBHT","text":"struct EqualDBHT <: DBHTRootMethod end\n\nCreate a clique's root from its adjacency tree in CliqueRoot.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HAC","page":"Clustering","title":"PortfolioOptimiser.HAC","text":"@kwdef mutable struct HAC <: HClustAlg\n    linkage::Symbol = :ward\nend\n\nUse a hierarchical clustering algorithm from Clustering.jl.\n\nParameters\n\nlinkage: linkage type supported by hclust.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HCOpt","page":"Clustering","title":"PortfolioOptimiser.HCOpt","text":"@kwdef mutable struct HCOpt{T1 <: Integer, T2 <: Integer}\n    branchorder::Symbol = :optimal\n    k_method::NumClusterMethod = TwoDiff()\n    k::T1 = 0\n    max_k::T2 = 0\nend\n\nDefines the options for processing clustering results in an instance of Clustering.Hclust.\n\nParameters\n\nbranchorder: parameter for ordering a dendrogram's branches accepted by Clustering.jl.\nk_method: method subtyping NumClusterMethod for computing the number of clusters.\nk:\nif iszero(k): use k_method for computing the number of clusters.\nelse: directly provide the number of clusters.\nmax_k: maximum number of clusters, capped to ⌈sqrt(N)⌉.\nif 0: defaults to ⌈sqrt(N)⌉.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.StdSilhouette","page":"Clustering","title":"PortfolioOptimiser.StdSilhouette","text":"@kwdef mutable struct StdSilhouette <: NumClusterMethod\n    metric::Union{Distances.SemiMetric, Nothing} = nothing\nend\n\nUse the standardised silhouette score for computing the number of clusters in calc_k_clusters.\n\nParameters\n\nmetric: metric for computing the silhouettes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.TwoDiff","page":"Clustering","title":"PortfolioOptimiser.TwoDiff","text":"struct TwoDiff <: NumClusterMethod end\n\nUse the two difference gap statistic for computing the number of clusters in calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.UniqueDBHT","page":"Clustering","title":"PortfolioOptimiser.UniqueDBHT","text":"struct UniqueDBHT <: DBHTRootMethod end\n\nCreate a unique root for a clique in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.calc_k_clusters-Tuple{HCOpt, AbstractMatrix, Any}","page":"Clustering","title":"PortfolioOptimiser.calc_k_clusters","text":"calc_k_clusters(hclust_opt::HCOpt, dist::AbstractMatrix, clustering)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTExp, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTExp, S, D)\n\nComputes the DBHTExp similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTMaxDist, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTMaxDist, S, D)\n\nComputes the DBHTMaxDist similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.is_leaf-Tuple{ClusterNode}","page":"Clustering","title":"PortfolioOptimiser.is_leaf","text":"is_leaf(a::ClusterNode)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.pre_order","page":"Clustering","title":"PortfolioOptimiser.pre_order","text":"pre_order(a::ClusterNode, func::Function = x -> x.id)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.to_tree-Tuple{Clustering.Hclust}","page":"Clustering","title":"PortfolioOptimiser.to_tree","text":"to_tree(a::Hclust)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTs-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DBHTs","text":"DBHTs(D::AbstractMatrix{<:Real}, S::AbstractMatrix{<:Real}; branchorder::Symbol = :optimal,\n      method::Symbol = :Unique)\n\nPerform Direct Bubble Hierarchical Tree clustering, a deterministic clustering algorithm [4]. This version uses a graph-theoretic filtering technique called Triangulated Maximally Filtered Graph (TMFG).\n\nArguments\n\nD: N×N dissimilarity matrix, e.g. a distance matrix.\nS: N×N non-negative similarity matrix, examples include:\nmathbfS = mathbfC + lvert min mathbfC rvert.\nmathbfS = lceilmax left(mathbfD^odot 2right)rceil - mathbfD^odot 2.\nmathbfS = exp odot (-mathbfD).\nWhere mathbfC is the correlation matrix, mathbfD the dissimilarity matrix D, and odot the Hadamard (elementwise) operator.\nbranchorder: parameter for ordering the final dendrogram's branches accepted by Clustering.jl.\nmethod: method for finding the root of a Direct Bubble Hierarchical Clustering Tree in case there is more than one candidate DBHTRootMethod.\n:Unique: create a unique root.\n:Equal: the root is created from the candidate's adjacency tree.\n\nOutputs\n\nT8: N×1 cluster membership vector.\nRpm: N×N adjacency matrix of the Planar Maximally Filtered Graph (PMFG).\nAdjv: Bubble cluster membership matrix from BubbleCluster8s.\nDpm: N×N shortest path length matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\nZ_hclust: Z matrix in Clustering.Hclust format.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.J_LoGo-Tuple{Any, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.J_LoGo","text":"J_LoGo(sigma, separators, cliques)\n\nCompute the sparse inverse covariance from a clique tree and separators [6].\n\nInputs\n\nsigma: N×N covariance matrix.\nseparators: list of 3-cliques that are not triangular faces.\ncliques: list of all 4-cliques.\n\nOutputs\n\njlogo: J_LoGo covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.PMFG_T2s","page":"Clustering","title":"PortfolioOptimiser.PMFG_T2s","text":"PMFG_T2s(W::AbstractMatrix{<:Real}, nargout::Integer = 3)\n\nConstructs a Triangulated Maximally Filtered Graph (TMFG) starting from a tetrahedron and recursively inserting vertices inside existing triangles (T2 move) in order to approximate a Maximal Planar Graph with the largest total weight, aka Planar Maximally Filtered Graph (PMFG). All weights are non-negative [7].\n\nArguments\n\nW: N×N matrix of non-negative weights.\nnargout: number of output arguments, the same arguments are always returne, this only controls whether some arguments are empty or not.\n\nOutputs\n\nA: adjacency matrix of the PMFG with weights.\ntri: list of triangles (triangular faces).\nclique3: list of 3-cliques taht are not triangular faces, all 3-cliques are given by [tri; clique3].\ncliques: list of all 4-cliques, if nargout <= 3, this will be returned as an empty array.\ncliqueTree: 4-cliques tree structure (adjacency matrix), if nargout <= 4, it is returned as an empty array.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTRootMethod","page":"Clustering","title":"PortfolioOptimiser.DBHTRootMethod","text":"abstract type DBHTRootMethod end\n\nAbstract type for subtyping methods creating roots of cliques in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTSimilarity","page":"Clustering","title":"PortfolioOptimiser.DBHTSimilarity","text":"abstract type DBHTSimilarity end\n\nAbstract type for subtyping methods for defining functions for computing similarity matrices from used in DBHT clustering PMFG_T2s [4, 7].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HClustAlg","page":"Clustering","title":"PortfolioOptimiser.HClustAlg","text":"abstract type HClustAlg end\n\nAbstract type for subtyping hierarchical clustering methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.NumClusterMethod","page":"Clustering","title":"PortfolioOptimiser.NumClusterMethod","text":"abstract type NumClusterMethod end\n\nAbstract type for subtyping methods for determining the number of clusters in a Clustering.Hclust when calling calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.AdjCliq-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.AdjCliq","text":"AdjCliq(A::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real},\n        CliqRoot::AbstractVector{<:Real})\n\nFind adjacent clique to the root candidates.\n\nInputs\n\nA: N×N adjacency matrix.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nCliqRoot: Nc×1 vector of root cliques.\n\nOutputs\n\nAdj: Nc×Nc adjacency matrix of the cliques with the root cliques.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleCluster8s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleCluster8s","text":"BubbleCluster8s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                Hb::AbstractMatrix{<:Real}, Mb::AbstractMatrix{<:Real},\n                Mv::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real})\n\nObtains non-discrete and discrete clusterings from the bubble topology of the Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nHb: undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nAdjv: N×Nk cluster membership matrix for vertices for non-discrete clustering via the bubble topology. Adjv[n, k] = 1 indicates cluster membership of vertex n to the k'th non-discrete cluster.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleHierarchy-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleHierarchy","text":"BubbleHierarchy(Pred::AbstractVector{<:Real}, Sb::AbstractVector{<:Real})\n\nBuild the bubble hierarchy.\n\nInputs\n\nPred: Nc×1 vector of predicted hierarchies.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\nOutputs\n\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleMember-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleMember","text":"BubbleMember(Rpm::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n             Mc::AbstractMatrix{<:Real})\n\nAssigns each vertex in the to a specific bubble.\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nMc: Matrix of the bubbles which coincide with the cluster.\n\nOutputs\n\nMvv: Matrix of the vertices belonging to the bubble.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BuildHierarchy-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BuildHierarchy","text":"BuildHierarchy(M::AbstractMatrix{<:Real})\n\nBuilds the predicted hierarchy.\n\nInputs\n\nM: N×Nc matrix of nodes and 3-cliques.\n\nOutputs\n\nPred: Nc×1 vector of predicted hierarchies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqHierarchyTree2s","page":"Clustering","title":"PortfolioOptimiser.CliqHierarchyTree2s","text":"CliqHierarchyTree2s(Apm::AbstractMatrix{<:Real}, method::Symbol = :Unique)\n\nLooks for 3-cliques of a Maximal Planar Graph (MPG), then construct a hierarchy of the cliques with the definition of \"inside\" a clique being a subgraph of smaller size when the entire graph is made disjoint by removing the clique [5].\n\nInputs\n\nApm: N×N adjacency matrix of an MPG.\nmethod: method for finding the root of the graph DBHTRootMethod. Uses Voronoi tesselation between tiling triangles.\nUniqueDBHT(): create a unique root.\nEqualDBHT(): the root is created from the candidate's adjacency tree.\n\nOutputs\n\nH1: Nc×Nc adjacency matrix for 3-clique hierarchical tree where Nc is the number of 3-cliques.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqueRoot-Tuple{UniqueDBHT, Any, Any, Any, Vararg{Any}}","page":"Clustering","title":"PortfolioOptimiser.CliqueRoot","text":"CliqueRoot(::UniqueDBHT, Root, Pred, Nc, args...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DendroConstruct-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Union{Real, AbstractVector{<:Real}}}","page":"Clustering","title":"PortfolioOptimiser.DendroConstruct","text":"DendroConstruct(Zi::AbstractMatrix{<:Real}, LabelVec1::AbstractVector{<:Real},\n                LabelVec2::AbstractVector{<:Real},\n                LinkageDist::Union{<:Real, AbstractVector{<:Real}})\n\nConstruct the linkage matrix by continuially adding rows to the matrix.\n\nInputs\n\nZi: Linkage matrix at iteration i in the same format as the output from Matlab.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: Linkage matrix at iteration i + 1 in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DirectHb-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DirectHb","text":"DirectHb(Rpm::AbstractMatrix{<:Real}, Hb::AbstractMatrix{<:Real},\n         Mb::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n         CliqList::AbstractMatrix{<:Real})\n\nComputes the directions on each separating 3-clique of a Maximal Planar Graph (MPH), hence computes the Directed Bubble Hierarchy Tree (DBHT).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the Planar Maximally Filtered Graph (MPFG).\nHb: Undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nHc: Nb×Nb unweighted directed adjacency matrix of the DBHT. Hc[i, j]=1 indicates a directed edge from bubble i to bubble j.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.FindDisjoint-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.FindDisjoint","text":"FindDisjoint(Adj::AbstractMatrix{<:Real}, Cliq::AbstractVector{<:Real})\n\nFinds disjointed cliques in adjacency matrix.\n\nInputs\n\nAdj: N×N adjacency matrix.\nCliq: 3×1 vector of 3-cliques.\n\nOutputs\n\nT: N×1 vector containing the adjacency number of each node.\nIndxNot: N×1 vector of nodes with no adjacencies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HierarchyConstruct4s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.HierarchyConstruct4s","text":"HierarchyConstruct4s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                     Tc::AbstractVector{<:Real}, Mv::AbstractMatrix{<:Real})\n\nConstructs the intra- and inter-cluster hierarchy by utilizing Bubble Hierarchy structure of a Maximal Planar graph, in this a Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\n\nOutputs\n\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.LinkageFunction-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.LinkageFunction","text":"LinkageFunction(d::AbstractMatrix{<:Real}, labelvec::AbstractVector{<:Real})\n\nLooks for the pair of clusters with the best linkage.\n\nInputs\n\nd: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nlabelvec: label vector for the vertices in the bubble.\n\nOutputs\n\nPairLink: pair of links with the best linkage.\ndvu: value of the best linkage.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser._build_link_and_dendro-Tuple{AbstractRange, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser._build_link_and_dendro","text":"_build_link_and_dendro(rg::AbstractRange, dpm::AbstractMatrix{<:Real},\n                       LabelVec::AbstractVector{<:Real}, LabelVec1::AbstractVector{<:Real},\n                       LabelVec2::AbstractVector{<:Real}, V::AbstractVector{<:Real},\n                       nc::Real, Z::AbstractMatrix{<:Real})\n\nComputes iterates over the vertices to construct the linkage matrix iteration by iteration.\n\nInputs\n\nrg: range of indices of the vertices in a bubble.\ndpm: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nLabelVec: vector labels of all vertices.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: updated linkage matrix in the same format as the output from Matlab.\nnc: updated inverse of the linkage distance.\nLabelVec1: updated LabelVec1 for the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.breadth-Tuple{AbstractMatrix{<:Real}, Integer}","page":"Clustering","title":"PortfolioOptimiser.breadth","text":"breadth(CIJ::AbstractMatrix{<:Real}, source::Integer)\n\nBreadth-first search.\n\nInputs\n\nCIJ: binary (directed/undirected) connection matrix.\nsource: source vertex.\n\nOutputs\n\ndistance: distance between source and i'th vertex (0 for source vertex).\nbranch: vertex that precedes i in the breadth-first search tree (-1 for source vertex).\n\nnote: Note\nBreadth-first search tree does not contain all paths (or all shortest paths), but allows the determination of at least one path with minimum distace. The entire graph is explored, starting from source vertex source.    # ColoursOriginal written by: Olaf Sporns, Indiana University, 2002/2007/2008\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.clique3-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.clique3","text":"clique3(A::AbstractMatrix{<:Real})\n\nComputes the list of 3-cliques.\n\nInputs\n\nA: N×N adjacency matrix of a Maximal Planar Graph (MPG).\n\nOutputs\n\nK3: vector of vectors with the corresponding indices of candidate cliques.\nE: matrix with non-zero indices and entries of candidate cliques.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.distance_wei-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.distance_wei","text":"distance_wei(L::AbstractMatrix{<:Real})\n\nThe distance matrix contains lengths of shortest paths between all node pairs. An entry [u, v] represents the length of the shortest path from node u to node v. The average shortest path length is the characteristic path length of the network. The function uses Dijkstra's algorithm.\n\nInputs\n\nL: Directed/undirected connection-length matrix.\nLengths between disconnected nodes are set to Inf.\nLengths on the main diagonal are set to 0.\n\nnote: Note\nThe input matrix must be a connection-length matrix typically obtained via a mapping from weight to length. For instance, in a weighted correlation network, higher correlations are more naturally interpreted as shorter distances, and the input matrix should therefore be some inverse of the connectivity matrix, i.e. a distance matrix.The number of edges in the shortest weighted path may in general exceed the number of edges in the shortest binary paths (i.e. the shortest weighted paths computed on the binarised connectivity matrix), because the shortest weighted paths have the minimal weighted distance, not necessarily the minimal number of edges.\n\nOutputs\n\nD: distance (shortest weighted path) matrix.\nB: number of edged in the shortest weigthed path matrix.\n\nnote: Note\nBased on a Matlab implementation by:Mika Rubinov, UNSW/U Cambridge, 2007-2012.\nRick Betzel and Andrea Avena, IU, 2012\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.turn_into_Hclust_merges-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.turn_into_Hclust_merges","text":"turn_into_Hclust_merges(Z::AbstractMatrix{<:Real})\n\nTurns a Matlab-style linkage matrix to a useable format for Hclust.\n\nInputs\n\nZ: Matlab-style linkage matrix.\n\nOutputs\n\nZ: Hclust-style linkage matrix.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PortfolioOptimiser","category":"page"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser","category":"page"},{"location":"#PortfolioOptimiser.PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser.PortfolioOptimiser","text":"PortfolioOptimiser\n\nCategory Badge\nDocs (Image: Stable) (Image: Dev)\nExamples (Image: Binder)\nCI (Image: Tests) (Image: Documentation) (Image: Aqua)\nCoverage (Image: Codecov) (Image: Coveralls)\n\nDescription\n\nPortfolioOptimiser is a library for portfolio optimisation. It was written with composability and extensibility in mind. It offers a broad range of functionality out of the box. It wraps a lot of external functionality in types for dispatch purposes and to allow easy development and extensibility.\n\nParameter estimation\n\nMatrix processing\n\nThese only apply to covariance, correlation, and cokurtosis estimators. Dissimilarity and similarity matrices use the results of correlation estimators, so they are indirectly used there.\n\nSparsification\n\nLocal/Global parsimonious estimator (LoGo), LoGo.\n\nFixing non-positive definite matrices\n\nNearest correlation matrix, PosdefNearest.\n\nDenoising methods\n\nFixed, DenoiseFixed.\nSpectral, DenoiseSpectral.\nShrink, DenoiseShrink.\n\nExpected mean returns estimators\n\nSimple mean, MuSimple.\nJames-Stein (JS), MuJS.\nBayes-Stein (BS), MuBS.\nBodnar-Okhrin-Parolya (BOP), MuBOP.\n\nThe JS, BS and BOP estimators also use a target for correcting their estimates.\n\nGrand mean (GM), GM.\nVolatility-weighted grand mean (VW), VW.\nMean square error of sample mean (SE), SE.\n\nCovariance estimators\n\nFull, CovFull.\nSemi, CovSemi.\nMutual information, CorMutualInfo.\nBrownian distance, CovDistance.\nLower tail dependence, CorLTD.\nGerber type 0, CorGerber0.\nGerber type 1, CorGerber1.\nGerber type 2, CorGerber2.\nSmyth-Broby modification of Gerber type 0, CorSB0.\nSmyth-Broby modification of Gerber type 1, CorSB1.\nSmyth-Broby modification with vote counting of Gerber type 0, CorGerberSB0.\nSmyth-Broby modification with vote counting of Gerber type 1, CorGerberSB1.\n\nCorrelation estimators\n\nAll covariance estimators can be used for correlation estimation.\n\nSpearman rank, CorSpearman.\nKendall rank, CorKendall.\n\nDisimilarity/distance matrix functions\n\nMarcos López de Prado, DistMLP.\nMarcos López de Prado distance of distance, DistDistMLP.\nNegative log, DistLog.\nVariation of information, DistVarInfo.\n\nTriangulated maximally filtered graph similarity matrix functions\n\nExponential decay, DBHTExp.\nSquare distance from maximum, DBHTMaxDist.\n\nBin width estimation functions\n\nKnuth, require PyCall and astropy to be installed, Knuth.\nFreedman, require PyCall and astropy to be installed, Freedman.\nScott, require PyCall and astropy to be installed, Scott.\nHacine-Gharbi and Ravier, HGR.\n\nCokurtosis estimators\n\nFull cokurtosis, KurtFull.\nSemi cokurtosis, KurtSemi.\n\nCoskewness estimators\n\nFull coskewness, SkewFull.\nSemi coskewness, SkewSemi.\n\nClustering\n\nHierarchical clustering, HAC.\nDirect Bubble Hierarchy Trees clustering, DBHT.\n\nDetermining number of clusters\n\nTwo different gap statistic, TwoDiff.\nStandardised silhouette scores, StdSilhouette.\n\nNetworks\n\nTriangular maximally filtered graphs (TMFG), TMFG.\nMinimum spanning tree (MST), MST.\n\nCentrality measures\n\nBetweenness, BetweennessCentrality.\nCloseness, ClosenessCentrality.\nDegree, DegreeCentrality.\nEigenvector, EigenvectorCentrality.\nKatz, KatzCentrality.\nPagerank, Pagerank.\nRadiality, RadialityCentrality.\nStress, StressCentrality.\n\nMinimum spanning tree algorithms\n\nKruskal, KruskalTree.\nBoruvka, BoruvkaTree.\nPrim, PrimTree.\n\nWorst case expected mean returns sets and covariance\n\nBox sets, Box.\nEllipse, Ellipse.\n\nBootstrapping methods\n\nARCH methods, require PyCall and ARCH to be installed, ArchWC.\nStationary bootstrap, StationaryBS.\nCircular bootstrap, CircularBS.\nMoving bootstrap, MovingBS.\nNormal, NormalWC.\nDelta, DeltaWC.\n\nElliptical constraint error size estimation\n\nNormal, KNormalWC.\nGeneral, KGeneralWC\n\nRegression methods\n\nStepwise methods\n\nForward regression, FReg.\nBackward regression, BReg.\n\nRegression criteria\n\np-value threshold, PVal.\nModel quality indicators.\nAkaike's Information Criterion, AIC.\nCorrected Akaike's Information Criterion for small sample sizes, AICC.\nBayesian Information Criterion, BIC.\nR² of a linear model, RSq.\nadjusted R² for a linear model, AdjRSq.\n\nDimensionality reduction\n\nPrincipal component analysis (PCA) based regression, PCAReg.\nPCA target, PCATarget.\nProbabilistic PCA target, PPCATarget.\n\nBlack Litterman models\n\nBlack Litterman, BLType.\n\nBlack Litterman factor models\n\nAugmented Black Litterman, ABLType.\nBayesian Black Litterman, BBLType.\n\nLinear moments (L-moments)\n\nNormalised constant relative risk aversion coefficients, CRRA.\nMaximum entropy, MaxEntropy.\nMinimum Sum of Squares, MinSumSq.\nMinimum Square Distance, MinSqDist.\n\nPortfolio optimisation\n\nThese types of optimisations act on instances of Portfolio.\n\nTraditional, Trad\n\nThis type of optimisation is the traditional efficient frontier optimisation.\n\nClasses, PortClass\n\nClassic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.\n\nExpected returns\n\nArithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.\n\nObjective functions\n\nMinimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.\n\nConstraints\n\nMaximum expected risk constraints.\nMinimum expected return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.\n\nRisk measures\n\nDispersion\n\nFull dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.\n\nDownside\n\nWorst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.\n\nDrawdown\n\nMaximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\n\nLinear moments (L-moments)\n\nL-moment ordered weight array, OWA.\n\nWorst case mean variance, WC\n\nThis type of optimisation requires worst case sets for the covariance and expected returns. The optimisation uses these sets to perform a mean variance optimisation.\n\nConstraints\n\nMaximum expected worst case standard deviation constraint.\nMinimum expected worst case return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.\n\nRisk parity, RP\n\nThis type of optimisation requires a risk budget per asset or factor. The optimisation attempts to minimise the difference between the risk budget and risk contribution of the asset or factor in the optimised portfolio.\n\nClasses, PortClass\n\nClassic, Classic.\nFactor model, FM.\nFactor risk contribution, FC.\n\nConstraints\n\nMinimum expected return constraint.\nLinear weight constraints.\n\nRisk measures\n\nDispersion\n\nFull dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.\n\nDownside\n\nWorst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.\n\nDrawdown\n\nMaximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\n\nLinear moments (L-moments)\n\nL-moment ordered weight array, OWA.\n\nRelaxed risk parity mean variance, RRP\n\nThis type of optimisation requires a risk budget per asset. The optimisation attempts to minimise the difference between the risk budget and relaxed formulation of the standard deviation risk measure.\n\nClasses, PortClass\n\nClassic, Classic.\nFactor model, FM.\n\nConstraints\n\nMinimum expected return constraint.\nLinear weight constraints.\n\nNear Optimal Centering, NOC\n\nNear optimal centering utilise the weights of an optimised portfolio. It computes a region of near optimality using the bounds of the efficient frontier, the expected risk and return of the optimal portfolio, and a user-provided parameter. It then optimises for a portfolio that best describes the region. It provides more diversification and robustness than Trad and smooths out the weight transitions as the efficient frontier is traversed.\n\nClasses, PortClass\n\nClassic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.\n\nConstraints\n\nMinimum expected return constraint.\nLinear weight constraints.\n\nClasses, PortClass\n\nClassic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.\n\nExpected returns\n\nArithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.\n\nConstraints\n\nMaximum expected risk constraints.\nMinimum expected return constraint.\n\nRisk measures\n\nDispersion\n\nFull dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.\n\nDownside\n\nWorst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.\n\nDrawdown\n\nMaximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\n\nLinear moments (L-moments)\n\nL-moment ordered weight array, OWA.\n\nHierarchical portfolio optimisation\n\nThese types of optimisations act on instances of HCPortfolio.\n\nHierarchical risk parity, HRP, and hierarchical equal risk parity, HERC\n\nHierarchical risk parity, HRP\n\nHierarchical risk parity optimisations use the hierarchical clustering of assets to assign risk contributions by iteratively splitting the dendrogram in half and assigning weights to each half according to the relative risk each half represents with respect to the other. It does this until it splits the dendrogram all the way down to single leaves.\n\nHierarchical equal risk parity, HERC\n\nHierarchical equal risk parity optimisations use the hierarchical clustering relationships between assets to assign risk contributions by splitting the dendrogram into k clusters. It starts with the full dendrogram and progressively cuts it into k-1 levels (since the comparison for each side belongs to the k-th level). At each step, it loops through the clusters and checks to which side of the sub-dendrogram the cluster belongs. It accumulates the risk of that cluster to the risk of the side it belongs to. The weights for the assets on each side of the dendrogram are assigned based on the relative (with respect to the other side) aggregate risk from all clusters belonging to it, these are the inter-cluster weights. It then computes the risk for each cluster, assigning weights to each asset according to the relative risk it represents with respect to other assets, these are the intra-cluster weights. It then elementwise multiplies both weights to get the final asset weights.\n\nHERC can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.\n\nConstraints\n\nMinimum and maximum weights per asset.\n\nRisk measures\n\nDispersion\n\nFull dispersion.\nVariance, Variance.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi Variance, Variance.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.\n\nDownside\n\nWorst case realisation (Minimax), WR.\nValue at risk (VaR), VaR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.\n\nDrawdown\n\nMaximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nDrawdown at for uncompounded cumulative returns risk (DaR), DaR.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\nMaximum drawdown (Calmar ratio) for compounded cumulative returns, MDD_r.\nAverage drawdown for compounded cumulative returns, ADD_r.\nUlcer index for compounded cumulative returns, UCI_r.\nDrawdown at for compounded cumulative returns risk (DaR), DaR_r.\nConditional drawdown at risk for compounded cumulative returns (CDaR), CDaR_r.\nEntropic drawdown at risk for compounded cumulative returns (EDaR), EDaR_r.\nRelativistic drawdown at risk for compounded cumulative returns (RLDaR), RLDaR_r.\n\nLinear moments (L-moments)\n\nL-moment ordered weight array, OWA.\n\nEqual Risk Contribution\n\nEqual risk contribution, Equal.\n\nNested clustered optimisation, NCO\n\nNested clustered optimisation combines the ideas of hierarchical equal risk parity optimisations and portfolio optimisations. They use the hierarchical clustering relationships between assets and splitting the dendrogram into k clusters. It then treats each cluster as its own isntance of Portfolio which is optimised in the usual way. The weights of each cluster are saved in a matrix, these are the intra-cluster weights. Then each cluster as a whole is treated as a synthetic asset, it statistics are internally computed from the fields in the NCO type. An instance of Portfolio is created from these synthetic assets and then optimised, these are the inter-cluster weights. The inter-cluster and intra-cluster weights are multiplied to give the asset weights.\n\nNCO can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.\n\nSub-types\n\nNCO can take keyword arguments that define the supported by optimisations of Portfolio. Since there are intra- and inter-cluster optimisations, it can take individual arguments for both. This means it can perform any combination of Portfolio optimisations, except for WC.\n\nNCO-Trad, NCO-NOC-Trad\n\nObjective functions\n\nMinimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.\n\nConstraints\n\nWhen applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.\n\nMaximum expected risk constraints.\nMinimum expected return constraint.\nLeverage constraints.\n\nNCO-RP, NCO-RRP, NCO-NOC-RP, NCO-NOC-RRP\n\nConstraints\n\nWhen applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.\n\nMinimum expected return constraint.\n\n\n\n\n\n","category":"module"},{"location":"Portfolio/PortfolioTypes/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#Public","page":"Types","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.HCPortfolio","page":"Types","title":"PortfolioOptimiser.HCPortfolio","text":"mutable struct HCPortfolio{ast, dat, r, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv,\n                           tsskew, tsv, wmi, wma, tco, tdist, tcl, tk, topt, tsolv, tf, tlp,\n                           taopt, talo, tasolv, taf, tamod} <: AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    w_min::wmi\n    w_max::wma\n    cor::tco\n    dist::tdist\n    clusters::tcl\n    k::tk\n    optimal::topt\n    solvers::tsolv\n    fail::tf\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a hierarchical clustering portfolio.\n\nParameters\n\nassets: N×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×N matrix of asset returns.\nmu: N×1 vector of asset expected returns.\ncov: N×N asset covariance matrix.\nkurt: N^2×N^2 cokurtosis matrix.\nskurt: N^2×N^2 semi cokurtosis matrix.\nL_2: (N^2)×((N^2 + N)/2) elimination matrix.\nS_2: ((N^2 + N)/2)×(N^2) summation matrix.\nskew: N×N^2 coskew matrix.\nV: N×N sum of the symmetric negative spectral slices of coskewness.\nsskew: N×N^2 semi coskew matrix.\nSV: N×N sum of the symmetric negative spectral slices of semi coskewness.\nw_min: minimum allowable asset weights.\nif isa vector: N×1 vector of minimum allowable weight per asset.\nif isa scalar: minimum asset weight for all assets.\nw_max: maximum allowable asset weights.\nif isa vector: N×1 vector of maximum allowable weight per asset.\nif isa scalar: maximum asset weight for all assets.\ncor: N×N asset correlation matrix.\ndist: N×N asset distance matrix.\nclusters: Clustering.Hclust of asset clusters.\nk: number of asset clusters.\nif is zero: compute the number of clusters via one of the cluster number methods NumClusterMethod.\nif is not zero: use this value directly.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.HCPortfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.HCPortfolio","text":"HCPortfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n              returns::DataFrame = DataFrame(),\n              ret::Matrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              timestamps::Vector{<:Dates.AbstractTime} = Vector{Date}(undef, 0),\n              assets::AbstractVector = Vector{String}(undef, 0),\n              mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n              cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              V = Matrix{eltype(returns)}(undef, 0, 0),\n              sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              SV = Matrix{eltype(returns)}(undef, 0, 0),\n              w_min::Union{<:Real, <:AbstractVector{<:Real}} = 0.0,\n              w_max::Union{<:Real, <:AbstractVector{<:Real}} = 1.0,\n              cor::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              dist::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              clusters::Clustering.Hclust = Hclust{Float64}(Matrix{Int64}(undef, 0, 2),\n                                                          Float64[], Int64[],\n                                                          :nothing),\n              k::Integer = 0, optimal::AbstractDict = Dict(),\n              solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n              latest_prices::AbstractVector = Vector{Float64}(undef, 0),\n              alloc_optimal::AbstractDict = Dict(),\n              alloc_leftover::AbstractDict = Dict(),\n              alloc_solvers::AbstractDict = Dict(),\n              alloc_fail::AbstractDict = Dict(),\n              alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for HCPortfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of HCPortfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"mutable struct Portfolio{ast, dat, r, tfa, tfdat, tretf, l, lo, s, us, ul, nal, nau, naus,\n                         mnak, mnaks, rb, to, kte, blbw, ami, bvi, rbv, frbv, nm, amc, bvc,\n                         ler, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv, tsskew, tsv,\n                         tmuf, tcovf, trfm, tmufm, tcovfm, tmubl, tcovbl, tmublf, tcovblf,\n                         tcovl, tcovu, tcovmu, tcovs, tdmu, tkmu, tks, topt, tlim, tfront,\n                         tsolv, tf, tmod, tlp, taopt, talo, tasolv, taf, tamod} <:\n               AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    f_assets::tfa\n    f_timestamps::tfdat\n    f_returns::tretf\n    loadings::l\n    regression_type::lo\n    short::s\n    short_u::us\n    long_u::ul\n    num_assets_l::nal\n    num_assets_u::nau\n    num_assets_u_scale::naus\n    max_num_assets_kurt::mnak\n    max_num_assets_kurt_scale::mnaks\n    rebalance::rb\n    turnover::to\n    tracking_err::kte\n    bl_bench_weights::blbw\n    a_mtx_ineq::ami\n    b_vec_ineq::bvi\n    risk_budget::rbv\n    f_risk_budget::frbv\n    network_adj::nm\n    a_vec_cent::amc\n    b_cent::bvc\n    mu_l::ler\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    f_mu::tmuf\n    f_cov::tcovf\n    fm_returns::trfm\n    fm_mu::tmufm\n    fm_cov::tcovfm\n    bl_mu::tmubl\n    bl_cov::tcovbl\n    blfm_mu::tmublf\n    blfm_cov::tcovblf\n    cov_l::tcovl\n    cov_u::tcovu\n    cov_mu::tcovmu\n    cov_sigma::tcovs\n    d_mu::tdmu\n    k_mu::tkmu\n    k_sigma::tks\n    optimal::topt\n    limits::tlim\n    frontier::tfront\n    solvers::tsolv\n    fail::tf\n    model::tmod\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a traditional portfolio. Na is the number of assets, and Nf is the number of factors. For details on how some of these parameters are computed see asset_statistics!, wc_statistics!, factor_statistics!, black_litterman_statistics!, and black_litterman_factor_statistics!.\n\nParameters\n\nassets: Na×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×Na matrix of asset returns.\nf_assets: Nf×1 vector of factor names.\nf_timestamps: T×1 vector of factor returns timestamps.\nf_returns: T×Nf matrix of asset returns.\nloadings: loadings matrix for working with factor models.\nregression_type: RegressionType used for computing the loadings matrix.\nshort:\nif true: shorting is enabled.\nelse: long-only portfolio.\nshort_u: upper bound for the absolute value of the sum of the negative weights.\nlong_u: upper bound for the sum of the positive weights.\nnum_assets_l: lower bound for the minimum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u: upper bound for the maximum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u_scale: scaling factor for the decision variable used for applying the num_assets_u constraint when optimising the Sharpe objective function.\nmax_num_assets_kurt: maximum number of assets to use the complete kurtosis model.\nif > 0: the approximate model will be used if the number of assets in the portfolio exceeds max_number_assets_kurt.\nmax_num_assets_kurt_scale: multipies Na to find the number of eigenvalues when computing the approximate kurtosis model, must be ∈ [1, Na].\nrebalance: AbstractTR for defining the portfolio rebalancing penalty.\nbeginalign\np_r = sumlimits_i=1^N r_i lvert w_i - b_i rvert\nendalign\nWhere:\np_r is the portfolio rebalancing penalty.\nN is the number of assets.\nr_i is the rebalancing penalty for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nturnover: AbstractTR for defining the asset turnover constraint.\nbeginalign\nlvert w_i - b_i rvert leq t_iquad forall i = 1ldotsN\nendalign\nWhere:\nt_i is the turnover constraint for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nN is the number of assets.\ntracking_err: TrackingErr for defining the tracking error constraint.\nbeginalign\nleftlVert dfracmathbfX bmw - bmbT - 1 rightrVert_2 leq epsilon\nendalign\nWhere:\nlVert cdot rVert_2 is the L2 norm.\nmathbfX is the T times N matrix of asset returns.\nT is the number of returns observations.\nN is the number of assets.\nbmw is the N times 1 vector of asset weights.\nbmb is the T times 1 vector of benchmark returns.\nepsilon is the tracking error.\nbl_bench_weights: benchmark weights for Black-Litterman models BlackLittermanClass.\na_mtx_ineq: C×N matrix of asset weight linear constraints.\nif isempty: the constraint is not set.\nb_vec_ineq: C×1 vector of asset weight linear constraints.\nif isempty: the constraint is not set.\nThe linear weight constraint is defined as.\nbeginalign\nmathbfA bmw geq bmb\nendalign\nWhere:\nmathbfA is the CN matrix of asset weight linear constraints.\nbmb is the C1 vector of asset weight linear constraints.\nC is the number of constraints.\nN is the number of assets.\nrisk_budget: Na×1 vector of asset risk budgets.\nf_risk_budget: Nf×1 vector of factor risk budgets.\nnetwork_adj: AdjacencyConstraint for defining the asset network constraint. This can be defined in two ways, using an exact mixed-integer approach IP or an approximate semi-definite one SDP. See their docs for the constraint definition for each case.\nif NoAdj: the constraint is not set.\na_vec_cent: centrality vector for defining the centrality constraint.\nif isempty: the constraint is not set.\nb_cent: average centrality of the assets the portfolio.\nif isinf: the constraint is not set.\nThe centrality constraint is defined as.\nbeginalign\nbmC cdot bmw = barc\nendalign\nWhere:\nbmw is the Ntimes 1 vector of asset weights.\nbmC is the N times 1 centrality vector of the asset adjacency matrix.\ncdot is the dot product.\nbarc is the desired average centrality measure of the portfolio.\nmu_l: lower bound for the expected return of the portfolio.\nif is Inf: the constraint is not applied.\nmu: Na×1 vector of asset expected returns.\ncov: Na×Na asset covariance matrix.\nkurt: Na^2×Na^2 cokurtosis matrix.\nskurt: Na^2×Na^2 semi cokurtosis matrix.\nL_2: (Na^2)×((Na^2 + Na)/2) elimination matrix.\nS_2: ((Na^2 + Na)/2)×(Na^2) summation matrix.\nskew: Na×Na^2 coskew matrix.\nV: Na×Na sum of the symmetric negative spectral slices of coskewness.\nsskew: Na×Na^2 semi coskew matrix.\nSV: Na×Na sum of the symmetric negative spectral slices of semi coskewness.\nf_mu: Nf×1 vector of factor expected returns.\nf_cov: Nf×Nf factor covariance matrix.\nfm_returns: T×Na factor model adjusted returns matrix.\nfm_mu: Na×1 factor model adjusted asset expected returns.\nfm_cov: Na×Na factor model adjusted asset covariance matrix.\nbl_mu: Na×1 Black Litterman model adjusted asset expected returns.\nbl_cov: Na×Na Black Litterman model adjusted asset covariance matrix.\nblfm_mu: Na×1 Black Litterman factor model adjusted asset expected returns.\nblfm_cov: Na×Na Black Litterman factor model adjusted asset covariance matrix.\ncov_l: Na×Na lower bound for the worst case covariance matrix.\ncov_u: Na×Na upper bound for the worst case covariance matrix.\ncov_mu: Na×Na matrix of the estimation errors of the asset expected returns vector set.\ncov_sigma: Na×Na matrix of the estimation errors of the asset covariance matrix set.\nd_mu: absolute deviation of the worst case upper and lower asset expected returns vectors.\nk_mu: distance parameter of the uncertainty in the asset expected returns vector for the worst case optimisation.\nk_sigma: distance parameter of the uncertainty in the asset covariance matrix for the worst case optimisation.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nlimits: collection capable of storing key value pairs for storing the minimal and maximal risk portfolios.\nfrontier: collection capable of storing key value pairs for containing points in the efficient frontier.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nmodel: JuMP.Model which defines the optimisation model.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"Portfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n            returns::DataFrame = DataFrame(),\n            ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            timestamps::AbstractVector = Vector{Date}(undef, 0),\n            assets::AbstractVector = Vector{String}(undef, 0),\n            f_prices::TimeArray = TimeArray(TimeType[], []),\n            f_returns::DataFrame = DataFrame(),\n            f_ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_timestamps::AbstractVector = Vector{Date}(undef, 0),\n            f_assets::AbstractVector = Vector{String}(undef, 0),\n            loadings::DataFrame = DataFrame(),\n            regression_type::Union{<:RegressionType, Nothing} = nothing,\n            short::Bool = false, short_u::Real = 0.2, long_u::Real = 1.0,\n            num_assets_l::Integer = 0, num_assets_u::Integer = 0,\n            num_assets_u_scale::Real = 100_000.0, max_num_assets_kurt::Integer = 0,\n            max_num_assets_kurt_scale::Integer = 2, rebalance::AbstractTR = NoTR(),\n            turnover::AbstractTR = NoTR(), tracking_err::TrackingErr = NoTracking(),\n            bl_bench_weights::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            a_mtx_ineq::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            b_vec_ineq::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            network_adj::AdjacencyConstraint = NoAdj(),\n            a_vec_cent::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            b_cent::Real = Inf, mu_l::Real = Inf,\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_returns::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            fm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            bl_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            bl_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            blfm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            blfm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_l::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_u::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_mu::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_sigma::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            d_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            k_mu::Real = Inf, k_sigma::Real = Inf, optimal::AbstractDict = Dict(),\n            limits::AbstractDict = Dict(), frontier::AbstractDict = Dict(),\n            solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n            model::JuMP.Model = JuMP.Model(),\n            latest_prices::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            alloc_optimal::AbstractDict = Dict(),\n            alloc_leftover::AbstractDict = Dict(),\n            alloc_solvers::AbstractDict = Dict(), alloc_fail::AbstractDict = Dict(),\n            alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for Portfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\ntimestamps: set timestamps.\nassets: set assets.\nf_prices: (T+1)×Nf TimeArray of factor prices.\nIf provided: will take precedence over f_returns, f_ret, f_timestamps, and f_assets because they will be automatically computed from f_prices.\nf_returns: T×Nf DataFrame of factor returns.\nIf provided: will take precedence over f_ret, f_timestamps, and f_assets because they will be automatically computed from returns.\nf_ret: set the f_returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of Portfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#Private","page":"Types","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.AbstractPortfolio","page":"Types","title":"PortfolioOptimiser.AbstractPortfolio","text":"abstract type AbstractPortfolio end\n\nAbstract type for subtyping portfolios.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#Public","page":"Constraints","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AKelly","page":"Constraints","title":"PortfolioOptimiser.AKelly","text":"@kwdef mutable struct AKelly <: RetType\n    formulation::SDSquaredFormulation = SOCSD()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.EKelly","page":"Constraints","title":"PortfolioOptimiser.EKelly","text":"struct EKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.IP","page":"Constraints","title":"PortfolioOptimiser.IP","text":"@kwdef struct IP{T1 <: AbstractMatrix{<:Real},\n                 T2 <: Union{<:Integer, <:AbstractVector{<:Integer}}, T3 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    k::T2 = 1\n    scale::T3 = 100_000.0\nend\n\nDefines the exact network constraint using mixed-integer programming.\n\nbeginalign\nleft(mathbfA + mathbfIright)bmy leq bmk\nw_i leq b_u y_i quad forall i = 1ldotsN \nw_i geq b_l y_i quad forall i = 1ldotsN\nendalign\n\nWhere:\n\nmathbfA is the N times N adjacency matrix.\nmathbfI is the identity matrix.\n\nSince each row of left(mathbfA + mathbfIright) corresponds to a path, duplicate rows add no new information whilst increasing the problem's size, therefore we only store unique rows.\n\nbmy is an N times 1 vector of binary 01 decision variables, which decide whether or not the asset should be included in the portfolio.\nbmk:\nif is a vector: Mtimes 1 vector defining the maximum number of assets allowed per unique path, where M is the number of unique paths.\nif is a scalar: defines the maximum number of assets allowed for all unique paths.\nw_i is the i-th asset weight.\nb_ub_l are the upper and lower bounds of the sum of the long and sum of the short asset weights, respectively.\nThus the constraint means we will invest in at most bmk assets per corresponding unique path.\n\nThis approach can be appied to any risk measure without work arounds like SDP. However it is more computationally costly to optimise, and may fail when mathbfA is close to the all ones matrix.\n\nParameters\n\nA: adjacency matrix, only stores unique(A + I, dims = 1).\nk:\nif is a vector: maximum number of assets per unique path.\nif A is not empty, checks that the length of k is equal to the size of unique(A + I, dims = 1).\nif is a scalar: maximum number of assets for all unique paths.\nscale: scaling variable for an auxiliary binary decision variable when optimising the Sharpe objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoAdj","page":"Constraints","title":"PortfolioOptimiser.NoAdj","text":"struct NoAdj <: AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoKelly","page":"Constraints","title":"PortfolioOptimiser.NoKelly","text":"struct NoKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTR","page":"Constraints","title":"PortfolioOptimiser.NoTR","text":"struct NoTR <: AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTracking","page":"Constraints","title":"PortfolioOptimiser.NoTracking","text":"struct NoTracking <: TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.SDP","page":"Constraints","title":"PortfolioOptimiser.SDP","text":"@kwdef mutable struct SDP{T1 <: AbstractMatrix{<:Real}, T2 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    penalty::T2 = 0.05\nend\n\nDefines an approximate network constraint using semi-definite programming.\n\nbeginalign\nbeginbmatrix\nmathbfW  bmw\nbmw^intercal  1\nendbmatrix succeq 0\nmathbfW = mathbfW^intercal\nmathbfA odot mathbfW = bm0\nendalign\n\nWhere:\n\nmathbfW is an auxiliary variable that approximates the outer product of asset weights bmw otimes bmw.\nmathbfA is the Ntimes N adjacency matrix. It tells us which assets are connected. The matrix can only take values of 1 or 0. If entry (ij) is equal to 1, assets i and j are connected.\nodot is the Hadamard (element-wise) product.\n\nWhen the variance risk measure SD is being used, whether in the objective function or as one of the risk constraints. Its definition will change when this constraint is active. The new definition is this.\n\nbeginalign\nphi_mathrmvar(bmw) = mathrmTrleft(mathbfSigmamathbfWright)\nendalign\n\nWhere:\n\nmathrmTr(cdot) is the trace operator.\nmathbfSigma is the covariance matrix.\n\nHowever, this will not work if the variance is not being constrained, or if it is not in the objective function. For that we add/subtract the following penalty factor to the objective function.\n\nbeginalign\nundersetbmwmathrmopt quad phi(bmw) pm lambda mathrmTrleft(mathbfXright)\nendalign\n\nWhere:\n\nmathrmopt is mathrmmin when the objective is convex and mathrmmax when it is concave.\npm is + when the objective is convex and - when it is concave.\nlambda is a penalty factor.\n\nThis approach works better than IP when mathbfA is close to the all ones matrix, even though it's an approximation.\n\nParameters\n\nA: N×N adjacency matrix.\npenalty: penalty factor when the variance SD risk measure isn't being used, either in a constraint or in the objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TR","page":"Constraints","title":"PortfolioOptimiser.TR","text":"@kwdef mutable struct TR{T1 <: Union{<:Real, <:AbstractVector{<:Real}},\n                         T2 <: AbstractVector{<:Real}} <: AbstractTR\n    val::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackRet","page":"Constraints","title":"PortfolioOptimiser.TrackRet","text":"@kwdef mutable struct TrackRet{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackWeight","page":"Constraints","title":"PortfolioOptimiser.TrackWeight","text":"@kwdef mutable struct TrackWeight{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Private","page":"Constraints","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AbstractTR","page":"Constraints","title":"PortfolioOptimiser.AbstractTR","text":"abstract type AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AdjacencyConstraint","page":"Constraints","title":"PortfolioOptimiser.AdjacencyConstraint","text":"abstract type AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.RetType","page":"Constraints","title":"PortfolioOptimiser.RetType","text":"abstract type RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackingErr","page":"Constraints","title":"PortfolioOptimiser.TrackingErr","text":"abstract type TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"EditURL = \"../../../examples/8_relaxed_risk_parity_variance_portfolios.jl\"","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#Distance-matrices","page":"Distance matrices","title":"Distance matrices","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#Public","page":"Distance matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistCanonical","text":"struct DistCanonical <: DistMethod end\n\nStruct for computing the canonical distance for a given correlation estimator in get_default_dist.\n\nCorrelation estimator Canonical distance\nCorMutualInfo DistVarInfo\nCorLTD DistLog\nCovDistance DistCor\nAny other estimator DistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistCor","text":"struct DistCor <: DistMethod end\n\nDefines the distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCanonical","text":"struct DistDistCanonical <: DistMethod end\n\nStruct for computing the canonical distance for a given correlation estimator in get_default_dist.\n\nCorrelation estimator Canonical distance\nCorMutualInfo DistDistVarInfo\nCorLTD DistDistLog\nCovDistance DistDistCor\nAny other estimator DistDistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistDistLog","text":"@kwdef mutable struct DistDistLog <: DistMethod\n    distance::Distances.Metric\n    args::Tuple\n    kwargs::NamedTuple\nend\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistDistMLP","text":"@kwdef mutable struct DistDistMLP <: DistMethod\n    absolute::Bool = false\n    distance::Distances.Metric = Distances.Euclidean()\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the distance of distances matrix from a correlation matrix [2] in dist.\n\nbeginalign\ntildeD_ij = f_mleft(bmD_i bmD_jright)\nendalign\n\nWhere:\n\nbmD_i: is the i-th column/row of the N×N distance matrix defined in DistMLP.\nf_m: is the pairwise distance function for metric m. We use the Distances.pairwise function which computes the entire matrix at once.\ntildeD_ij: is the (ij)-th entry of the N×N distances of distances matrix.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistDistVarInfo","text":"@kwdef mutable struct DistDistVarInfo <: DistMethod\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance of distances matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistLog","text":"struct DistLog <: DistMethod end\n\nDefines the log-distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistMLP","text":"@kwdef mutable struct DistMLP <: DistMethod\n    absolute::Bool = false\nend\n\nDefines the distance matrix from a correlation matrix [2] in dist.\n\nbeginalign\nD_ij = \n    begincases\n        sqrtdfrac12 left(1 - C_ijright) quad mathrmif absolute = false\n        sqrt1 - lvert C_ij rvert quad mathrmif absolute = true\n    endcases\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix mathbfC.\nC_ij: is the (ij)-th entry of the N×N correlation matrix mathbfD.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistVarInfo","text":"@kwdef mutable struct DistVarInfo <: DistMethod\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Freedman","page":"Distance matrices","title":"PortfolioOptimiser.Freedman","text":"struct Freedman <: AstroBins end\n\nFreedman's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.HGR","page":"Distance matrices","title":"PortfolioOptimiser.HGR","text":"struct HGR <: AbstractBins end\n\nHacine-Gharbi and Ravier's bin width algorithm [3].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Knuth","page":"Distance matrices","title":"PortfolioOptimiser.Knuth","text":"struct Knuth <: AstroBins end\n\nKnuth's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Scott","page":"Distance matrices","title":"PortfolioOptimiser.Scott","text":"struct Scott <: AstroBins end\n\nScott's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.dist-Tuple{PortfolioOptimiser.DistMethod, Any, Any}","page":"Distance matrices","title":"PortfolioOptimiser.dist","text":"dist(de::DistMethod, X, Y)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/DistanceMatrices/#Private","page":"Distance matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AbstractBins","page":"Distance matrices","title":"PortfolioOptimiser.AbstractBins","text":"abstract type AbstractBins end\n\nAbstract type for defining the bin width estimation functions when computing DistVarInfo and CorMutualInfo distance and correlation matrices respectively.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AstroBins","page":"Distance matrices","title":"PortfolioOptimiser.AstroBins","text":"abstract type AstroBins <: AbstractBins end\n\nAbstract type for defining which bin width function to use from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCor","text":"struct DistdistCor <: DistMethod end\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMethod","page":"Distance matrices","title":"PortfolioOptimiser.DistMethod","text":"abstract type DistMethod end\n\nAbstract type for subtyping methods for computing distance matrices from correlation ones.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.get_default_dist-Tuple{PortfolioOptimiser.DistMethod, PortfolioOptimiser.PortfolioOptimiserCovCor}","page":"Distance matrices","title":"PortfolioOptimiser.get_default_dist","text":"get_default_dist(dist_type::DistMethod, cor_type::PortfolioOptimiserCovCor)\n\nInputs\n\nif isa(cor_type, PortCovCor): operates on the internal correlation estimator cor_type.ce.\nelse: directly operates on the correlation estimator cor_type.\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/PortfolioClasses/#Portfolio-classes","page":"Portfolio classes","title":"Portfolio classes","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#Public","page":"Portfolio classes","title":"Public","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BL","page":"Portfolio classes","title":"PortfolioOptimiser.BL","text":"@kwdef mutable struct BL{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BLFM","page":"Portfolio classes","title":"PortfolioOptimiser.BLFM","text":"@kwdef mutable struct BLFM{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.Classic","page":"Portfolio classes","title":"PortfolioOptimiser.Classic","text":"struct Classic <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FC","page":"Portfolio classes","title":"PortfolioOptimiser.FC","text":"@kwdef mutable struct FC <: PortClass\n    flag::Bool = true\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FM","page":"Portfolio classes","title":"PortfolioOptimiser.FM","text":"@kwdef mutable struct FM{T1 <: Integer} <: PortClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#Private","page":"Portfolio classes","title":"Private","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BlackLittermanClass","page":"Portfolio classes","title":"PortfolioOptimiser.BlackLittermanClass","text":"abstract type BlackLittermanClass <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.PortClass","page":"Portfolio classes","title":"PortfolioOptimiser.PortClass","text":"abstract type PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioClustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets!-Tuple{HCPortfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets!","text":"cluster_assets!(port::HCPortfolio; hclust_alg::HClustAlg = HAC(),\n                hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. Save the results in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{HCPortfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::HCPortfolio; hclust_alg::HClustAlg = HAC(),\n               hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::Portfolio; cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\nS: N×N asset correlation matrix.\nD: N×N asset distance matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser._hcluster","page":"Clustering","title":"PortfolioOptimiser._hcluster","text":"_hcluster(ca::DBHT, port::HCPortfolio, hclust_opt::HCOpt = HCOpt())\n\nUse DBHTs to hierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: [DBHT] options for clustering with DBHTs.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser._hcluster-2","page":"Clustering","title":"PortfolioOptimiser._hcluster","text":"_hcluster(ca::HAC, port::HCPortfolio, hclust_opt::HCOpt = HCOpt())\n\nUse Clustering.hclust to hierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: linkage for Clustering.hclust.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Optimisation/ObjectiveFunctions/#Objective-functions","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#Public","page":"Objective functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MaxRet","page":"Objective functions","title":"PortfolioOptimiser.MaxRet","text":"struct MaxRet <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MinRisk","page":"Objective functions","title":"PortfolioOptimiser.MinRisk","text":"struct MinRisk <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Sharpe","page":"Objective functions","title":"PortfolioOptimiser.Sharpe","text":"@kwdef mutable struct Sharpe{T1 <: Real} <: ObjectiveFunction\n    rf::T1 = 0.0\nend\n\nMaximum risk-adjusted return (Sharpe) ratio objective function.\n\nParameters\n\nrf: risk free rate.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Utility","page":"Objective functions","title":"PortfolioOptimiser.Utility","text":"@kwdef mutable struct Utility{T1 <: Real} <: ObjectiveFunction\n    l::T1 = 2.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#Private","page":"Objective functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.ObjectiveFunction","page":"Objective functions","title":"PortfolioOptimiser.ObjectiveFunction","text":"abstract type ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"EditURL = \"../../../examples/7_worst_case_statistics.jl\"","category":"page"},{"location":"examples/7_worst_case_statistics/#Example-7:-Worst-case-statistics","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This example focuses on the wc_statistics! used in the WC optimisation type of Portfolio.","category":"page"},{"location":"examples/7_worst_case_statistics/#7.1-Downloading-the-data","page":"Example 7: Worst case statistics","title":"7.1 Downloading the data","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables, Random\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/7_worst_case_statistics/#7.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 7: Worst case statistics","title":"7.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/7_worst_case_statistics/#7.3-Effect-of-the-Worst-Case-Mean-Variance-statistics","page":"Example 7: Worst case statistics","title":"7.3 Effect of the Worst Case Mean Variance statistics","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The previous tutorial showed how to perform worst case mean variance optimisations. This one goes into more detail on computing the uncertainty sets needed for this optimisation type.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The function in charge of doing so is wc_statistics! via the WCType type. Consult the docs for details.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"There are a lot of combinations for this, so we will not be showing an exhaustive list. We will explore a representative subset. Since we used the default values for our previous tutorial we will explore a few of the other options.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll first use the default statistics for computing the optimised worst case mean variance portfolio.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"# Set random seed for reproducible results.\nRandom.seed!(123)\nwc_statistics!(portfolio)","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll use the box set for the expected returns vector and the elliptical set for the covariance matrix. We'll maximise the risk-adjusted return ratio.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"type = WC(; mu = Box(), cov = Ellipse())\nobj = Sharpe(3.5 / 100 / 252)\nw1 = optimise!(portfolio; type = type, obj = obj);\nnothing #hide","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"WCType can produce a wealth of uncertainty sets depending on the user provided parameters. You can experiment by changing the values of wc and computing the statistics again.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll now use a completely different set of parameters for computing the worst case statistics, but we will optimise the same problem.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"wc_type = WCType(; cov_type = PortCovCor(; ce = CorGerber1(; normalise = true)),\n                 mu_type = MuBOP(), box = NormalWC(), ellipse = ArchWC(),\n                 k_sigma = KNormalWC(), k_mu = KGeneralWC(), diagonal = false)\nwc_statistics!(portfolio; wc_type = wc_type)\nw2 = optimise!(portfolio; type = type, obj = obj)\n\npretty_table(DataFrame(; tickers = w1.tickers, w1 = w1.weights, w2 = w2.weights);\n             formatters = fmt1)","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"When compared to the previous tutorial, the takeaway here is that the type of uncertainty set used has much more of an impact on the results of the optimisation 6.4 Optimising the portfolio than the parameters used to compute the worst case sets. However, more robust statistics will produce more robust uncertainty sets.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"EditURL = \"../../../examples/1_basic_use.jl\"","category":"page"},{"location":"examples/1_basic_use/#Example-1:-Basic-use","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This example should serve as a minimum working example for using PortfolioOptimiser.jl.","category":"page"},{"location":"examples/1_basic_use/#1.1-Downloading-the-data","page":"Example 1: Basic use","title":"1.1 Downloading the data","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"PortfolioOptimiser does not ship with supporting packages that are not integral to its internal functionality. This means users are responsible for installing packages to load and download data, JuMP-compatible solvers, pretty printing, and the plotting functionality is an extension which requires GraphRecipes and StatsPlots.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Which means we need a few extra packages to be installed. Uncomment the first two lines if these packages are not in your Julia environment.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"PrettyTables\"])\nusing Clarabel, DataFrames, Dates, GraphRecipes, HiGHS, YFinance, PortfolioOptimiser,\n      PrettyTables, Statistics, StatsBase, StatsPlots, TimeSeries\n\n# These are helper functions for formatting tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\nfmt2 = (v, i, j) -> begin\n    if j == 5\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    else\n        return v\n    end\nend;\n\nfmt3 = (v, i, j) -> begin\n    if j ∈ (2, 6, 7)\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    else\n        return v\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We define our list of meme stonks and a generous date range. We will only be keeping the adjusted close price. In practice it doesn't really matter because we're using daily data.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"function stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))","category":"page"},{"location":"examples/1_basic_use/#1.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 1: Basic use","title":"1.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Now that we have our data we can instantiate a portfolio. We also need to give it an optimiser for the continuous optimisation and an MIP optimiser for the discrete allocation of funds, we'll use Clarabel.jl and HiGHS.jl.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The constructor automatically computes the returns, sets the assets, and timestamps if you give it the price data. Users can also provide these directly, the timestamps aren't needed anywhere but plotting so they are not required. This structure contains a lot of data. But we will only show the basics for now.","category":"page"},{"location":"examples/1_basic_use/#1.3-Computing-statistics","page":"Example 1: Basic use","title":"1.3 Computing statistics","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are myriad of statistics and methods for computing said statistics. Users can define their own methods with Julia's multiple dispatch and StatsAPI.jl interface.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We will do a simple Mean-Variance optimisation, using the simplest methods for computing the expected returns vector and covariance matrices. Later tutorials will go more in-depth.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# T is the number of observations, N the number of assets.\nT, N = size(portfolio.returns)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Simple mean, it also accepts weights for computing weighted means. This will compute the weighted mean for lambda = 1/T.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"mu_type = MuSimple(;)\n# mu_type = MuSimple(; w = eweights(1:T, 1/T, scale=true))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"PortCovCor is quite special because it accepts covariance estimators, methods for fixing non positive definite matrices, denoising methods, and a graph-based approach for computing the covariance by identifying related asset groups.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The estimators are all different, and PortfolioOptimiser offers a few of them. They all have their own parameters. They all subtype StatBase.CovarianceEstimator, meaning PortCovCor works with external estimators such as those in CovarianceEstimation.jl, as well as user-defined methods.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This defaults to the full sample covariance estimator. We can provide the estimator with some weights to compute a weighted covariance too. We'll leave other estimators for future tutorials. For the time being, feel free to play around with the weights. There is some nesting involved, but that is due to the fact that we are composing various estimators to get our desired outcome.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"cov_type = PortCovCor(;)\n# cov_type = PortCovCor(;\n#                       ce = CovFull(; ce = StatsBase.SimpleCovariance(; corrected = false),\n#                                    w = eweights(1:T, 1 / T; scale = true)))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We can then call asset_statistics! which computes all the asset statistics. It will also compute other statistics by default but we can set some flags to stop this from happening.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"asset_statistics!(portfolio; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false);\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/#1.4-Optimising-the-portfolio","page":"Example 1: Basic use","title":"1.4 Optimising the portfolio","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We will only look at a vanilla optimisation in this tutorial.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are quite a few risk measures, some require statistics we have not computed, others don't require any precomputed statistics at all. You can see the risk measure has a few internal parameters, they all do. We'll only show the classic mean variance risk measure, but you can uncomment each of the next few lines in turn and try some of the others.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"rm = SD() # Variance\n# rm = MAD() # Mean absolute deviation\n# rm = SSD() # Semi variance\n# rm = CVaR() # Critical Value at Risk\n# rm = CDaR() # Critical Drawdown at Risk","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are four objective functions we can use they all serve their purpose but for the tutorial, we'll be minimising the risk. Try the other objective functions and change the parameters to see their effects.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"obj = MinRisk()\n# obj = MaxRet() # Only useful for maximising the return while constraining the risk to be under a given value.\n# obj = Utility(; l = 2) # Maximises the utility = return - l * risk\n# obj = Sharpe(; rf = 3.5/100/254) # Maximises the sharpe ratio = (mu - rf)/risk, where mu is the expected return.\n\nw1 = optimise!(portfolio; rm = rm, obj = obj)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We now have the portfolio for these assets and this period of time that minimises the variance. PortfolioOptimiser also lets you constrain the optimisation such that you have a minimum required return. However this will be explored in a later tutorial.","category":"page"},{"location":"examples/1_basic_use/#1.5-Asset-allocation","page":"Example 1: Basic use","title":"1.5 Asset allocation","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"For now we want to know how many assets we need to buy, this only gives us the mathematically optimal weights. We have a function for this. Given that we used the price data directly, Portfolio will take the last entry in the prices and use that as the current price for each asset. You can of course change this, or directly provide them as a vector to the allocate! function, though the order of the prices must be the same as the original asset order.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"For this example, lets say we have 1000 dollars. Change this value to see how the allocation changes. The larger it becomes, the closer they get to the optimal value.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"investment = 1000;\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are two methods we can use for allocating. The one we have chosen uses mixed-integer linear programming to discretly allocate assets. This however can only allocate discrete quantities. The second method is a greedy algorithm that allocates based on which asset has the highest difference between its mathematical optimum and current weight, it only tries to allocate based on whether you can afford it. However, it can allocate fractional shares up to an integer multiple of the value in rounding (defaults to 1). Given it is a greedy algorithm, it is not guaranteed to give an optimum solution, but will always find a solution, unlike the LP() method which can fail. Also the higher the investment, the more accurate it gets.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"method = LP()\n# method = Greedy(; rounding=0.5)\n\nw2 = allocate!(portfolio; investment = investment)\npretty_table(w2; formatters = fmt2)","category":"page"},{"location":"examples/1_basic_use/#1.6-Plotting-the-portfolio","page":"Example 1: Basic use","title":"1.6 Plotting the portfolio","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This section is the one most bound to change as the plotting functions are still somewhat preliminary. There are a variety of plots but we'll only show the most basic ones. By default, the plots will take the mathematically optimal portfolio. Lets see what it looks like.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns per asset.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; per_asset = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_bar(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the returns histogram.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_hist(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio range of returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_range(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio drawdown.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_drawdown(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This is, however not our actual portfolio, it is the optimal one. To plot the allocated portfolio we need to know the key it is stored under and pass that on to the plotting functions along with a flag. The key is the symbol composed of the allocation method, in this case LP() and the portfolio type, which is something we have not discussed, but defaults to Trad(), as a Symbol.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Side by side optimal portfolio vs allocated portfolio.\npretty_table(hcat(portfolio.optimal[:Trad],\n                  DataFrames.rename!(portfolio.alloc_optimal[:LP_Trad][!, 2:end],\n                                     Dict(:weights => :alloc_weights)),\n                  DataFrame(;\n                            weight_diff = portfolio.optimal[:Trad].weights -\n                                          portfolio.alloc_optimal[:LP_Trad].weights));\n             formatters = fmt3)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns per asset.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; type = :LP_Trad, allocated = true, per_asset = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_bar(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the returns histogram.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_hist(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio range of returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_range(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio drawdown.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_drawdown(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/#1.7-Efficient-frontier","page":"Example 1: Basic use","title":"1.7 Efficient frontier","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We have seen how you can optimise a single portfolio, but in reality there are an infinite number of optimal portfolios which exist along what is called the efficient frontier. We can compute and view this frontier, as well as viewing its composition very easily using PortfolioOptimiser.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The idea is to first compute the minimum risk and maximum return portfolios. From these we generate a range of risks and returns. We then loop over all these values. At each step we maximise the expected return whilst constraining the risk to be lower than or equal to current risk value in the range of risks. If an optimisation fails, we instead minimise the risk whilst constraining the expected return to be bigger than or equal to the corresponding value in the range of expected returns. We save the results for each step. We can then use these to plot the efficient frontier and its composition at each point.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Compute 50 points in the efficient frontier.\npoints = 50\nfrontier = efficient_frontier!(portfolio; rm = rm, points = points)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the efficient frontier.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_frontier(portfolio; rm = rm)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot frontier asset composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_frontier_area(portfolio; rm = rm)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The efficient frontier is outputted by efficient_frontier!, but also saves it in the portfolio instance. It is a dictionary whose keys are the symbols of the risk measure used to compute the efficient frontier. We've only computed the efficient frontier for the SD, so we can access the efficient frontier data by indexing into the :SD key. The documentation for Portfolio contains more details.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"As the last demo we will display a heatmap of the portfolio composition of the efficient frontier in SD().","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Check if the sharpe ratio is found in the frontier.\nif portfolio.frontier[:SD][:sharpe]\n    risks = portfolio.frontier[:SD][:risks]\n    weights = DataFrames.rename(portfolio.frontier[:SD][:weights],\n                                Symbol.(1:length(risks)) .=>\n                                    Symbol.(round.(risks * 100, digits = 2)))\n    idx = sortperm(portfolio.frontier[:SD][:risks])\n    weights = weights[!, [1; idx .+ 1]]\n    risks = risks[idx]\nelse\n    weights = Matrix(portfolio.frontier[:SD][:weights])\n    risks = portfolio.frontier[:SD][:risks]\nend\n\nplot(Matrix(weights[!, 2:end]); st = :heatmap, clim = (0, 1),\n             yticks = (1:N, portfolio.assets), yflip = true,\n             xticks = (1:3:length(risks), round.(risks * sqrt(252), digits = 2)[1:3:end]),\n             xrotation = 60, xtickfontsize = 10, xlabel = \"Expected Anualised Risk (SD)\",\n             color = cgrad(:Spectral), size = (600, 600), colorbar_title = \"\\nAsset Weight\")","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Miscelaneous-Functions","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Public","page":"Miscelaneous Functions","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Private","page":"Miscelaneous Functions","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser._set_rm_solvers!-Tuple{Union{EDaR, EDaR_r, EVaR, RLDaR, RLDaR_r, RLVaR}, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser._set_rm_solvers!","text":"_set_rm_solvers!(rm::RMSolvers, solvers)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser._unset_rm_solvers!-Tuple{Union{EDaR, EDaR_r, EVaR, RLDaR, RLDaR_r, RLVaR}, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser._unset_rm_solvers!","text":"_unset_rm_solvers!(rm::RMSolvers, flag)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_first_rm-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_first_rm","text":"get_first_rm(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet the first risk measure, used in efficient_frontier!.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_rm_symbol-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_rm_symbol","text":"get_rm_symbol(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet a symbol for the risk measure(s). If multiple measures are given, they are concatenated by underscores.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractDict, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.set_rm_properties!","text":"set_rm_properties!(rm::AbstractRiskMeasure, solvers::AbstractDict,\n                   sigma::Union{Nothing, <:AbstractMatrix{<:Real}})\n\nSet properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, Vararg{Bool, 4}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.unset_set_rm_properties!","text":"unset_set_rm_properties!(rm::AbstractRiskMeasure, solver_flag::Bool, sigma_flag::Bool)\n\nUnset properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Network","page":"Network","title":"Network","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/#Public","page":"Network","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.centrality_vector-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.centrality_vector","text":"centrality_vector(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistMethod = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the centrality vector centrality_vector. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nC: N×1 centrality vector.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.cluster_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.cluster_matrix","text":"cluster_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nCompute the centrality vector cluster_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nhclust_alg: method for hierarhically clustering assets HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nC: N×N cluster-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connected_assets-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connected_assets","text":"connected_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                 cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                 dist_type::DistMethod = DistCanonical(),\n                 network_type::NetworkType = MST())\n\nCompute the percentage of the portfolio comprised of connected assets connected_assets via a connection-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nc: percentage of the portfolio comprised of assets connected via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connection_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connection_matrix","text":"connection_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistMethod = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the connection matrix connection_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nC: N×N connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.related_assets-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.related_assets","text":"related_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nCompute the percentage of the portfolio comprised of related assets  related_assets via a cluster-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nhclust_alg: method for hierarhically clustering assets HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nc: percentage of the portfolio comprised of related assets via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Private","page":"Network","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"Optimisation/OptimisationSetup/#Setup-functions","page":"Setup functions","title":"Setup functions","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Public","page":"Setup functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"Optimisation/OptimisationSetup/#Private","page":"Setup functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"Contents/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"Contents/","page":"Index","title":"Index","text":"","category":"page"},{"location":"RiskMeasures/RiskStatistics/#Risk-statistics","page":"Risk statistics","title":"Risk statistics","text":"","category":"section"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"It is possible to compute risk-derived statistics given a RiskMeasure/HCRiskMeasure, a vector of weights, and other relevant data.","category":"page"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"risk_bounds(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector, ::AbstractVector)\nrisk_contribution(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)\nfactor_risk_contribution(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)\nsharpe_ratio(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)","category":"page"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_bounds-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_bounds","text":"risk_bounds(rm::AbstractRiskMeasure, w1::AbstractVector, w2::AbstractVector;\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0), delta::Real = 1e-6,\n            scale::Bool = false, kwargs...)\n\nDescription\n\nCompute the risk bounds for an AbstractRiskMeasure and pair of asset weight vectors.\n\nSee also: AbstractRiskMeasure, calc_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\nV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the coskewness.\nSV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nscale::Bool = false: flag for scaling the kurtosis and semi kurtosis in risk_contribution.\n\nOutputs\n\nr1::Real: lower risk bound/risk corresponding to w1.\nr2::Real: upper risk bound/risk corresponding to w2.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw1 = [0.7, 0.2, 0.1]\nw2 = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nr1, r2 = risk_bounds(CVaR(), w1, w2; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                  X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  delta::Real = 1e-6, marginal::Bool = false, \n                  kwargs...)\n\nDescription\n\nCompute the asset risk contribution for an AbstractRiskMeasure and asset weight vector.\n\nSee also: AbstractRiskMeasure, risk_bounds, calc_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nmarginal::Bool = false:\nif true: compute the marginal risk contribution.\nelse: compute the risk contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc::AbstractVector: N×1 vector of risk contribution per asset.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nrc = risk_contribution(CVaR(), w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                        X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        assets::AbstractVector = Vector{String}(undef, 0),\n                        F::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        f_assets::AbstractVector = Vector{String}(undef, 0),\n                        B::DataFrame = DataFrame(),\n                        regression_type::RegressionType = FReg(),\n                        delta::Real = 1e-6, kwargs...)\n\nDescription\n\nCompute the factor risk contribution for an AbstractRiskMeasure, assets, and factors.\n\nSee also: AbstractRiskMeasure, risk_bounds, calc_risk, regression, RegressionType.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure AbstractRiskMeasure.\nw::AbstractVector: Na×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Na matrix of asset returns.\nassets::AbstractVector = Vector{String}(undef, 0): Na×1 vector of asset names.\nF::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Nf matrix of factor returns.\nf_assets::AbstractVector = Vector{String}(undef, 0): Nf× vector of factor names.\nB::DataFrame = DataFrame(): optional Na×Nf loadings matrix.\nregression_type::RegressionType = FReg(): regression type used for computing the loadings matrix.\ndelta::Real = 1e-6: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nBehaviour\n\nIf B is empty: computes the loadings matrix, B, via regression using regression_type, F, f_assets, X, assets.\n\nOutputs\n\nrc_f::AbstractVector: Nf×1 vector of risk contribution per factor.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.57 -0.54 -0.15  0.42 -1.78;\n           -0.12 -0.02 -0.04  1.61  0.74;\n            0.09  2.58 -0.40 -0.36 -1.07;\n           -1.33 -1.13  0.35 -0.89 -1.01;\n            0.59 -1.48  0.01 -1.79 -0.18;\n            0.22  0.39 -0.04  0.22  0.64;\n            2.39  0.05 -0.24  0.76 -0.08;\n           -0.22 -0.66  0.51  1.21 -0.36;\n            1.56 -0.39  2.13  0.01  1.77;\n            0.88  0.49 -1.24  1.24  0.71]\n\n# Asset names\nassets = [\"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]\n\n# Sample factor returns matrix\nf_returns = [ 3.00  1.55;\n              0.52 -0.57;\n             -0.27  0.71;\n              0.30  0.00;\n              2.27  1.10;\n              0.23  1.33;\n              0.64  0.00;\n              0.35  1.02;\n             -1.33 -1.60;\n              0.49 -1.66]\n\n# Factor names\nf_assets = [\"F1\", \"F2\"]\n\n# Sample asset weights vector\nw = [0.15, 0.1, 0.3, 0.2, 0.25]\n\n# Risk measure\ncvar_rm = CVaR()\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# the default parameters.\nfc1 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets)\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# a different regression method.\nfc2 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets, regression_type = BReg())\n\n# Provide the loadings matrix directly.\nB = DataFrame(:tickers => assets,\n              :const => [0.019628056331070173, -0.4630372691196401, -0.051116594784858346,\n                         0.6244845397620361, -0.46039779836908995],\n              :F1 => [-0.5382419657683666, 0.0, -0.5447539204822568, 0.0,\n                      -0.4713171689983393],\n              :F2 => [0.0, -0.48659032199680796, 0.44882375725309853, -0.23791307331955935,\n                      0.0])\n\nfc3 = factor_risk_contribution(cvar_rm, w; X = returns, F = f_returns, B = B)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(rm::AbstractRiskMeasure, w::AbstractVector;\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            delta::Real = 1e-6, rf::Real = 0.0, \n            kelly::Bool = false)\n\nDescription\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure and asset weights vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: N×1 vector of asset weights.\nmu: N×1 vector of expected returns.\nX: T×N matrix of asset returns.\nV: N×N matrix of the sum of negative spectral slices of the coskewness.\nSV: N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Black-Litterman-models","page":"Black Litterman models","title":"Black Litterman models","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#Public","page":"Black Litterman models","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.ABLType","page":"Black Litterman models","title":"PortfolioOptimiser.ABLType","text":"@kwdef mutable struct ABLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool = true\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::PosdefFix = PosdefNearest()\n    denoise::Denoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Augmented Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nbmPi_a = begincases\n                    deltabeginbmatrix\n                      mathbfSigma\n                      mathbfSigma_F mathbfB^intercal\n                      endbmatrix bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases\nmathbfP_a =  beginbmatrix\n                      mathbfP  mathbf0\n                      mathbf0  mathbfP_F\n                    endbmatrix\nbmQ_a =  beginbmatrix\n                bmQ\n                bmQ_F\n                endbmatrix\nmathbfSigma_a =  beginbmatrix\n                            mathbfSigma  mathbfB mathbfSigma_F\n                            mathbfSigma_F mathbfB^intercal  mathbfSigma_F\n                          endbmatrix\nmathbfOmega_a =  beginbmatrix\n                            mathbfOmega  mathbf0\n                            mathbf0  mathbfOmega_F\n                          endbmatrix\nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\nmathbfM_a = left left(tau  mathbfSigma_a right)^-1 + mathbfP_a^intercal mathbfOmega_a^-1 mathbfP_aright^-1\nbmPi_mathrmABL = mathbfM_a leftleft(tau mathbfSigma_aright)^-1 bmPi_a + mathbfP_a^intercal mathbfOmega_a^-1 mathbfQ_a right\ntau = dfrac1T\nbmmu_mathrmABL = bmPi_mathrmABL + r\nmathbfSigma_mathrmABL = mathbfSigma_a + mathbfM_a\nendalign\n\nWhere:\n\nbmPi_a:\nif error is true: is the Na×1 augmented equilibrium excess returns vector.\nelse: is the Na×1 historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the Na×Na asset covariance matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfP_a: is the (Nva+Nvf)×(Na+Nf) augmented views matrix. The zeros pad the matrix so all columns and rows are of equal length.\nmathbfP: is the Nva×Na asset views matrix.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nbmQ_a: is the (Nva+Nvf)×1 augmented views returns vector.\nbmQ: is the Nva×1 asset views returns vector.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_a: is the (Na+Nf)×(Na+Nf) augmented covariance matrix.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfOmega_a: is the (Nva+Nvf)×(Nva+Nvf) covariance matrix of the errors of the augmented views.\nmathbfOmega: is the Nva×Nva covariance matrix of the errors of the asset views.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nmathbfM_a: is an (Na+Nf)×(Na+Nf) intermediate covariance matrix.\nbmPi_mathbfABL: is the Na×1 equilibrium excess returns vector after being adjusted by the augmented views.\nT: is the number of returns observations.\nbmmu_mathbfABL: is the Na×1 vector of asset expected returns obtained via the Augmented Black-Litterman model.\nmathbfSigma_mathrmABL: is the Na×Na asset covariance matrix obtained via the Augmented Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: method for fixing non positive Augmented Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Augmented Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Augmented Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BBLType","page":"Black Litterman models","title":"PortfolioOptimiser.BBLType","text":"mutable struct BBLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool\n    error::Bool\n    delta::Union{<:Real, Nothing}\n    rf::T1\n    ve::StatsBase.CovarianceEstimator\n    var_w::Union{<:AbstractWeights, Nothing}\n    posdef::PosdefFix\n    denoise::Denoise\n    logo::AbstractLoGo\nend\n\nDefines the parameters for computing the Bayesian Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nmathbfSigma = mathbfB mathbfSigma_F mathbfB^intercal + mathbfSigma_epsilon \nmathbfSigma_epsilon = begincasesmathrmDiagonalleft(mathrmvarleft(mathbfX - mathbfF mathbfB^intercal mathrmdims = 1right)right) quad mathrmif error = true\nmathbf0 quad mathrmif error = false\nendcases\noverlinemathbfSigma_F = left(mathbfSigma_F^-1 + mathbfP_F^intercal mathbfOmega_F^-1 mathbfP_Fright)^-1\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\ntau = dfrac1T\noverlinebmPi_F = overlinemathbfSigma_F left(mathbfSigma_F^-1 bmPi_F + mathbfP_F^intercal mathbfOmega_F^-1 bmQ_Fright)\nbmPi_F = bmmu_F - r\nmathbfSigma_mathrmBF = mathbfSigma^-1 mathbfB left( overlinemathbfSigma_F + mathbfB^intercal mathbfSigma^-1 mathbfB right)^-1\nmathbfSigma_mathrmBLB = left(mathbfSigma^-1 - mathbfSigma_mathrmBF mathbfB^intercal mathbfSigma^-1right)^-1\nbmmu_mathrmBLB = mathbfSigma_mathrmBLB mathbfSigma_mathrmBF overlinemathbfSigma_F overlinebmPi_F + r\nendalign\n\nWhere:\n\nmathbfSigma: is the Na×Na estimated asset covariance matrix computed using the factor model.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfSigma_epsilon: is an Na×Na diagonal matrix constructed from the variances of the errors between the asset and estimated asset returns using the factor model.\nmathbfX: is the T×Na matrix of asset returns.\nmathbfF: is the T×Nf matrix of factor returns.\noverlinemathbfSigma_F: is the Nf×Nf posterior covariance matrix of the factors after adjusting by the factor views.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nT: is the number of returns observations.\noverlinebmPi_F: is the Nf×1 posterior equilibrium excess returns vector of the factors after adjusting by the factor views.\nbmPi_F: is the Nf×1 equilibrium excess returns vector of the factors.\nbmmu_F: is the Nf×1 factor expected returns vector.\nr: is the risk-free rate.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_mathrmBF: is an Na×Nf intermediate covariance matrix,.\nmathbfSigma_mathrmBLB: is the Na×Na posterior asset covariance matrix, aka the asset covariance matrix obtained via the Bayesian Black-Litterman model.\nbmmu_mathrmBLB: is the Na×1 posterior asset expected returns vector, aka the asset returns vector obtained via the Bayesian Black-Litterman model.\n\nParameters\n\nconstant:\nif true: the loadings matrix contains the constant term as its first column.\nelse: the loadings matrix does not contain the constant term.\nerror:\nif true: correct the estimated asset covariance matrix by adding the variances of the errors between the actual returns and factor estimated returns.\n\nnote: Note\nOnly useful when the factor model is based on a regression model.\n\ndelta: risk aversion factor.\nrf: risk free rate.\nve: StatsBase.CovarianceEstimator for computing the errors covariance.\nvar_w: optional weights for computing the errors covariance.\nposdef: method for fixing non positive Bayesian Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Bayesian Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Bayesian Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BLType","page":"Black Litterman models","title":"PortfolioOptimiser.BLType","text":"@kwdef mutable struct BLType{T1 <: Real} <: BlackLitterman\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::PosdefFix = PosdefNearest()\n    denoise::Denoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Black-Litterman model black_litterman. We define N as the number of assets, and Nv the number of asset views.\n\nbeginalign\nbmPi = begincases\n                    delta mathbfSigma bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases                            \nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfM = left left(tau  mathbfSigma right)^-1 + mathbfP^intercal mathbfOmega^-1 mathbfPright^-1\nbmPi_mathrmBL = mathbfM leftleft(tau mathbfSigmaright)^-1 bmPi + mathbfP^intercal mathbfOmega^-1 mathbfQ right\ntau = dfrac1T\nbmmu_mathrmBL = bmPi_mathrmBL + r\nmathbfSigma_mathrmBL = mathbfSigma + mathbfM\nendalign\n\nWhere:\n\nbmPi:\nif error is true: is N×1 the equilibrium excess returns vector.\nelse: is N×1 the historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the N×N asset covariance matrix.\nbmw: is the N×1 vector of benchmark asset weights.\nmathbfP: is the Nv×N asset views matrix.\nbmQ: is the Nv×1 asset views returns vector.\nmathbfOmega: is the Nv×Nv covariance matrix of the errors of the asset views.\nmathbfM: is an N×N intermediate covariance matrix, and M the number of assets.\nbmPi_mathbfBL: is the N×1 equilibrium excess returns after being adjusted by the views.\nT: is the number of returns observations.\nbmmu_mathbfBL: is the N×1 vector of asset expected returns obtained via the Black-Litterman model.\nmathbfSigma_mathrmBL: is the N×N asset covariance matrix obtained via the Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: method for fixing non positive Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.black_litterman-Tuple{BLType, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}","page":"Black Litterman models","title":"PortfolioOptimiser.black_litterman","text":"black_litterman(bl::BLType, X::AbstractMatrix, P::AbstractMatrix,\n                         Q::AbstractVector, w::AbstractVector;\n                         cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                         mu_type::MeanEstimator = MuSimple())\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Private","page":"Black Litterman models","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BlackLittermanFactor","page":"Black Litterman models","title":"PortfolioOptimiser.BlackLittermanFactor","text":"abstract type BlackLittermanFactor <: BlackLitterman end\n\nAbstract type for subtyping Black Litterman models.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser._bl_mu_cov_w-NTuple{13, Any}","page":"Black Litterman models","title":"PortfolioOptimiser._bl_mu_cov_w","text":"_mu_cov_w(tau, omega, P, Pi, Q, rf, sigma, delta, T, N, opt, cov_type, cov_flag = true)\n\nInternal function for computing the Black Litterman statistics as defined in black_litterman. See .\n\nInputs\n\ntau: variable of the same name in the Black-Litterman model.\nomega: variable of the same name in the Black-Litterman model.\nP: variable of the same name in the Black-Litterman model.\nPi: variable of the same name in the Black-Litterman model.\nQ: variable of the same name in the Black-Litterman model.\nrf: variable of the same name in the Black-Litterman model.\nsigma: variable of the same name in the Black-Litterman model.\ndelta: variable of the same name in the Black-Litterman model.\nT: variable of the same name in the Black-Litterman model.\nN: variable of the same name in the Black-Litterman model.\nopt: any valid instance of opt for .\ncov_type: any valid value from .\ncov_flag: whether the matrix is a covariance matrix or not.\n\nOutputs\n\nmu: asset expected returns vector obtained via the Black-Litterman model.\ncov_mtx: asset covariance matrix obtained via the Black-Litterman model.\nw: asset weights obtained via the Black-Litterman model.\nPi_: equilibrium excess returns after being adjusted by the views.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/#Public","page":"Statistics","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.asset_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.asset_statistics!","text":"asset_statistics!(port::AbstractPortfolio;\n                  cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cov::Bool = true, mu_type::MeanEstimator = MuSimple(),\n                  set_mu::Bool = true, kurt_type::KurtFull = KurtFull(),\n                  set_kurt::Bool = true, skurt_type::KurtSemi = KurtSemi(),\n                  set_skurt::Bool = true, skew_type::SkewFull = SkewFull(),\n                  set_skew::Bool = true, sskew_type::SkewSemi = SkewSemi(),\n                  set_sskew::Bool = true,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cor::Bool = true,\n                  dist_type::DistMethod = DistCanonical(),\n                  set_dist::Bool = true)\n\nCompute the asset statistics for a portfolio. See the argument types' docs for details. If a statistic requires another to be computed, the funciton will do so from the relevant estimator.\n\nThe set_* variables are flags for deciding whether or not to set the statistic. If a statistic's flag is false the statistic will not be set. Furthermore, if the flag is false and the statistic is not required by another one, it will not be computed.\n\nInputs\n\nport: portfolio AbstractPortfolio.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nset_cov: flag for setting port.cov\nmu_type: expected returns estimator MeanEstimator.\nset_mu: flag for setting port.mu\nkurt_type: cokurtosis matrix estimator KurtFull.\nset_kurt: flag for setting port.kurt.\nskurt_type: cokurtosis matrix estimator KurtSemi.\nset_skurt: flag for setting port.skurt.\nskew_type: coskew estimator SkewFull.\nset_skew: set port.skew and port.V.\nsskew_type: semi coskew estimator SkewSemi.\nset_sskew: set port.skew and port.SV.\n\nOnly relevant for HCPortfolio.\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\nset_cor: flag for setting port.cor.\ndist_type: method for computing the distance matrix DistMethod. asset_statistics! uses get_default_dist to ensure the computed distance is consistent with dist_type and either cor_type.ce or cor_type whichever is applicable.\nset_dist: flag for setting port.dist.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_factor_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_factor_statistics!","text":"black_litterman_factor_statistics!(port::Portfolio;\n                                   w::AbstractVector = port.bl_bench_weights,\n                                   B::Union{DataFrame, Nothing} = port.loadings,\n                                   P::Union{AbstractMatrix, Nothing} = nothing,\n                                   P_f::Union{AbstractMatrix, Nothing} = nothing,\n                                   Q::Union{AbstractVector, Nothing} = nothing,\n                                   Q_f::Union{AbstractVector, Nothing} = nothing,\n                                   factor_type::FactorType = FactorType(),\n                                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   mu_type::MeanEstimator = MuSimple(),\n                                   f_cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   f_mu_type::MeanEstimator = MuSimple(),\n                                   bl_type::BlackLittermanFactor = BBLType())\n\nCompute the Black Litterman factor model statistics. Na is the number of assets, Nva is the number of asset views, Nf is the number of factors, Nvf is the number of factors views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\nB: loadings matrix.\nif isempty(B): computes the loadings matrix using factor_type.\nP: Nva×Na matrix of asset views.\nP_f: Nvf×Nf matrix of factor views.\nQ: Nva×1 vector of asset views.\nQ_f: Nvf×1 vector of factor views.\nfactor_type: factor statistics estimator FactorType.\ncov_type: asset covariance estimator PortfolioOptimiserCovCor.\nmu_type: asset expected returns estimator MeanEstimator.\nf_cov_type: factor covariance estimator PortfolioOptimiserCovCor.\nf_mu_type: factor expected returns estimator MeanEstimator.\nbl_type: Black Litterman factor model estimator BlackLittermanFactor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_statistics!","text":"black_litterman_statistics!(port::Portfolio; P::AbstractMatrix, Q::AbstractVector,\n                            w::AbstractVector = port.bl_bench_weights,\n                            cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                            mu_type::MeanEstimator = MuSimple(),\n                            bl_type::BLType = BLType())\n\nCompute the factor statistics. N is the number of assets, Nv is the number of asset views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nP: Nv×N matrix of asset views.\nQ: Nv×1 vector of asset views.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\nbl_type: Black Litterman model estimator BLType.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.factor_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.factor_statistics!","text":"factor_statistics!(port::Portfolio; factor_type::FactorType = FactorType(),\n                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                   mu_type::MeanEstimator = MuSimple())\n\nCompute the factor statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nfactor_type: factor statistics estimator FactorType.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.wc_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.wc_statistics!","text":"wc_statistics!(port::Portfolio; wc_type::WCType = WCType(), set_box::Bool = true,\n                        set_ellipse::Bool = true)\n\nCompute the worst case mean-variance statistics. Only used in WC optimisations. The set_* variables are used to compute and set the relevant statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nwc: worst-case mean-variance statistics estimator WCType.\nset_box:\nif true: compute and set the box uncertainty sets, port.cov_l, port.cov_u, port.d_mu.\nset_ellipse:\nif true: compute and set the elliptical uncertainty sets and parameters, port.cov_mu, port.cov_sigma, port.k_mu, port.k_sigma.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Private","page":"Statistics","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"EditURL = \"../../../examples/6_worst_case_mv_portfolios.jl\"","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#Example-6:-Worst-case-Mean-Variance","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This example focuses on the WC optimisation type of Portfolio.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.1-Downloading-the-data","page":"Example 6: Worst case Mean-Variance","title":"6.1 Downloading the data","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables, Random\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 6: Worst case Mean-Variance","title":"6.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.3-Worst-case-statistics","page":"Example 6: Worst case Mean-Variance","title":"6.3 Worst case statistics","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"In order to perform a worst case mean variance optimisation we need to compute uncertainty sets for the expected returns vector and covariance matrix. We can do this via wc_statistics!.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"For the purposes of this tutorial we'll use the defaults. We will explore the other options one can sue for computing the uncertainty sets in a subsequent tutorial.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# Set random seed for reproducible results.\nRandom.seed!(123)\nwc_statistics!(portfolio)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.4-Optimising-the-portfolio","page":"Example 6: Worst case Mean-Variance","title":"6.4 Optimising the portfolio","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"Having computed our worst case statistics, we can optimise the portfolio. The WC struct defines which set types to use in the worst case mean variance optimisation. WC defaults to using Box constraints for both the expected returns vector and covariance matrix.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"User-provided risk measures have no effect on this type of optimisation will only perform a mean variance optimisation with uncertainty sets.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This type of optimisation can take any PortfolioOptimiser.ObjectiveFunction.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# User-provided risk measures have no effect.\nrm = CVaR()\n# Worst case mean-variance optimisation using default set types.\ntype = WC()\n# We'll maximise the risk-adjusted return ratio.\nobj = Sharpe(; rf = 3.5 / 100 / 252)\n\n# Box uncertainty set for the expected returns vector and covariance matrix.\nw1 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and box uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw2 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Box uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Box()\ntype.cov = Ellipse()\nw3 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw4 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\npretty_table(DataFrame(; tickers = w1.tickers, box_box = w1.weights, ellip_box = w2.weights,\n                       box_ellip = w3.weights, ellip_ellip = w4.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"As you can see, the type of constraint used can have a large impact on the results of the optimisation. This is accentuated by the fact that we maximised the risk-adjusted return ratio. We'll now minimise the risk, on which the uncertainty set for the expected returns vector has a smaller impact.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"type = WC()\n# We'll maximise the risk-adjusted return ratio.\nobj = MinRisk()\n\n# Box uncertainty set for the expected returns vector and covariance matrix.\nw5 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and box uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw6 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Box uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Box()\ntype.cov = Ellipse()\nw7 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw8 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\npretty_table(DataFrame(; tickers = w5.tickers, box_box = w5.weights, ellip_box = w6.weights,\n                       box_ellip = w7.weights, ellip_ellip = w8.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"It's also posible to disable the worst set constraint for the expected returns vector and covariance matrix independently. We'll disable them both and see that we recover the traditional mean variance optimisation.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"type = WC(; mu = NoWC(), cov = NoWC())\n\nobj = MinRisk()\nw9 = optimise!(portfolio; type = type, obj = obj)\nw10 = optimise!(portfolio; type = Trad(), obj = obj)\n\nobj = Sharpe(; rf = 3.5 / 100 / 252)\nw11 = optimise!(portfolio; type = type, obj = obj)\nw12 = optimise!(portfolio; type = Trad(), obj = obj)\n\npretty_table(DataFrame(; tickers = w9.tickers, nowc_risk = w9.weights,\n                       trad_risk = w10.weights, nowc_sharpe = w11.weights,\n                       trad_sharpe = w12.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"We don't recover the weights of the sharpe ratio exactly because one of the risk-adjusted return constraints is slightly relaxed with respect to the traditional optimisation.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ParameterEstimation/PosdefFix/#Fixing-non-positive-definite-matrices","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#Public","page":"Fixing non-positive definite matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.NoPosdef","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.NoPosdef","text":"struct NoPosdef <: PosdefFix end\n\nNon positive definite matrices will not be fixed in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefNearest","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefNearest","text":"@kwdef mutable struct PosdefNearest <: PosdefFix\n    method::NearestCorrelationMatrix.NCMAlgorithm = NearestCorrelationMatrix.Newton(;\n                                                                                    tau = 1e-12)\nend\n\nDefines which method from NearestCorrelationMatrix to use in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.posdef_fix!-Tuple{PortfolioOptimiser.PosdefFix, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.posdef_fix!","text":"posdef_fix!(method::PosdefFix, X::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/PosdefFix/#Private","page":"Fixing non-positive definite matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefFix","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefFix","text":"abstract type PosdefFix end\n\nAbstract type for subtyping methods for fixing non positive definite matrices in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser._posdef_fix!-Tuple{PosdefNearest, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser._posdef_fix!","text":"_posdef_fix!(method::PosdefNearest, X::AbstractMatrix)\n\nOverload this for other posdef fix methods.\n\n\n\n\n\n","category":"method"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"EditURL = \"../../../examples/0_not_financial_advice.jl\"","category":"page"},{"location":"examples/0_not_financial_advice/#Example-0:-Not-financial-advice","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This example goes over a sample workflow using PortfolioOptimiser.jl. I use a similar strategy myself. This is just an example of the things that can be done with the library.","category":"page"},{"location":"examples/0_not_financial_advice/#0.1-Downloading-the-data","page":"Example 0: Not financial advice","title":"0.1 Downloading the data","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"PortfolioOptimiser does not ship with supporting packages that are not integral to its internal functionality. This means users are responsible for installing packages to load and download data, JuMP-compatible solvers, pretty printing, and the plotting functionality is an extension which requires GraphRecipes and StatsPlots.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Which means we need a few extra packages to be installed. Uncomment the first two lines if these packages are not in your Julia environment.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"PrettyTables\"])\nusing Clarabel, DataFrames, Dates, GraphRecipes, HiGHS, YFinance, PortfolioOptimiser,\n      PrettyTables, Statistics, StatsBase, StatsPlots, TimeSeries\n\n# These are helper functions for formatting tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j != 5\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We define our list of meme stonks and a generous date range. We will only be keeping the adjusted close price. In practice it doesn't really matter because we're using daily data.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"function stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))","category":"page"},{"location":"examples/0_not_financial_advice/#0.2-Filter-worst-stocks","page":"Example 0: Not financial advice","title":"0.2 Filter worst stocks","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"If we have hundreds or thousands of stocks, we should probably do some pruning of the worst stocks using a cheap method. For this we'll use the HERC optimisation type. We'll filter the stocks using a few different risk measures. The order matters here, as each risk measure will filter out the worst performing stocks for each iteration.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"First we need our filter functions.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# This tells us the bottom percentile we need to eliminate at each iteration so we have at most `x %` of the original stocks after `n` steps.\npercentile_after_n(x, n) = 1 - exp(log(x) / n)\n\nfunction filter_best(assets, rms, best, cov_type, cor_type)\n    # Copy the assets to a vector that will be shrunk at every iteration.\n    assets_best = copy(assets)\n    # Compute the bottom percentile we need to remove after each iteration.\n    q = percentile_after_n(best, length(rms))\n    # Loop over all risk measures.\n    for rm ∈ rms\n        hp = HCPortfolio(; prices = prices[Symbol.(assets_best)])\n        asset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type,\n                          set_kurt = false, set_skurt = false, set_mu = false,\n                          set_skew = isa(rm, Skew) ? true : false, set_sskew = false)\n        cluster_assets!(hp; hclust_opt = HCOpt(; k_method = StdSilhouette()))\n        w = optimise!(hp; type = HERC(), rm = rm)\n\n        if isempty(w)\n            continue\n        end\n\n        w = w.weights\n\n        # Only take the stocks above the q'th quantile at each step.\n        qidx = w .>= quantile(w, q)\n        assets_best = assets_best[qidx]\n    end\n    return assets_best\nend","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Now we can define the parameters for our filtering procedure.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# Risk measures.\nrms = [SD(), SSD(), CVaR(), CDaR(), Skew()]\n\n# Lets say we want to have 50% of all stocks at the end.\nbest = 0.5\n\n# Lets use denoised and detoned covariance and correlation types so we can get rid of market forces. We're using the normal covariance as it's not very expensive to compute and we've made it more robust by denoising and detoning.\ncovcor_type = PortCovCor(; ce = CovFull(), denoise = DenoiseFixed(; detone = true))\n\n# Filter assets to only have the best ones.\nassets_best = filter_best(assets, rms, best, covcor_type, covcor_type)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We can see that we end up with the best 11 stocks.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"assets_best","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We can now use fancier optimisations and statistics with the smaller stock universe.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"hp = HCPortfolio(; prices = prices[Symbol.(assets_best)],\n                 # Continuous optimiser.\n                 solvers = Dict(:Clarabel1 => Dict(:solver => Clarabel.Optimizer,\n                                                   :check_sol => (allow_local = true,\n                                                                  allow_almost = true),\n                                                   :params => Dict(\"verbose\" => false))),\n                 # MIP optimiser for the discrete allocation.\n                 alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                     :check_sol => (allow_local = true,\n                                                                    allow_almost = true),\n                                                     :params => Dict(\"log_to_console\" => false))))\n\ncovcor_type = PortCovCor(; ce = CorGerber1())\nmu_type = MuBOP()\nasset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type, mu_type = mu_type,\n                  set_kurt = false, set_skurt = false, set_skew = false, set_sskew = false)\ncluster_assets!(hp; hclust_opt = HCOpt(; k_method = TwoDiff()))","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We'll use the nested clustering optimisation. We will also use the maximum risk adjusted return ratio objective function. We will also allocate the portfolio according to our availabe cash and the latest prices.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"w = optimise!(hp; rm = RLDaR(),\n              type = NCO(;\n                         # Risk adjusted return ratio objective function.\n                         opt_kwargs = (; obj = Sharpe(; rf = 3.5 / 100 / 252))))\n\n# Say we have 3000 dollars at our disposal to allocate the portfolio\nwa = allocate!(hp; type = :NCO, investment = 3000)\n\npretty_table(w; formatters = fmt1)\npretty_table(wa; formatters = fmt2)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"However, we can do one better, we can take the worst performing stocks as well and short them. Since we're starting from so few stocks we'll adjust the best percentage to only take the best 30% after all filters.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"function filter_worst(assets, rms, best, cov_type, cor_type)\n    assets_worst = copy(assets)\n    # Compute the bottom percentile we need to remove after each iteration.\n    q = percentile_after_n(best, length(rms))\n    # Loop over all risk measures.\n    for rm ∈ rms\n        hp = HCPortfolio(; prices = prices[Symbol.(assets_worst)])\n        asset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type,\n                          set_kurt = false, set_skurt = false, set_mu = false,\n                          set_skew = isa(rm, Skew) ? true : false, set_sskew = false)\n        cluster_assets!(hp; hclust_opt = HCOpt(; k_method = StdSilhouette()))\n        w = optimise!(hp; type = HERC(), rm = rm)\n\n        if isempty(w)\n            continue\n        end\n\n        w = w.weights\n\n        # Only take the stocks below the (1-q)'th quantile at each step.\n        qidx = w .<= quantile(w, 1 - q)\n        assets_worst = assets_worst[qidx]\n    end\n    return assets_worst\nend","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Now we can define the parameters for our filtering procedures.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# Risk measures.\nrms = [SD(), SSD(), CVaR(), CDaR(), Skew()]\n\n# Lets say we want to have 50% of all stocks at the end, 30% of the best, and 20% of the worst.\nbest = 0.3\nworst = 0.2\n\n# Lets use denoised and detoned covariance and correlation types so we can get rid of market forces. We're using the normal covariance as it's not very expensive to compute and we've made it more robust by denoising and detoning.\ncovcor_type = PortCovCor(; ce = CovFull(), denoise = DenoiseFixed(; detone = true))\n\n# Filter assets to only have the best ones.\nassets_best = filter_best(assets, rms, best, covcor_type, covcor_type)\n\n# Filter assets to only have the worst ones.\nassets_worst = filter_worst(assets, rms, worst, covcor_type, covcor_type)\n\n# Lets join the best and worst tickers into a single vector.\nassets_best_worst = union(assets_best, assets_worst)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This time we'll make a market neutral portfolio using the NCO optimisation type.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"hp = HCPortfolio(; prices = prices[Symbol.(assets_best_worst)],\n                 # Continuous optimiser.\n                 solvers = Dict(:Clarabel1 => Dict(:solver => Clarabel.Optimizer,\n                                                   :check_sol => (allow_local = true,\n                                                                  allow_almost = true),\n                                                   :params => Dict(\"verbose\" => false))),\n                 # MIP optimiser for the discrete allocation.\n                 alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                     :check_sol => (allow_local = true,\n                                                                    allow_almost = true),\n                                                     :params => Dict(\"log_to_console\" => false))))\n\ncovcor_type = PortCovCor(; ce = CorGerber1())\nmu_type = MuBOP()\nasset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type, mu_type = mu_type,\n                  set_kurt = false, set_skurt = false, set_skew = false, set_sskew = false)\ncluster_assets!(hp; hclust_opt = hclust_opt = HCOpt(; k_method = TwoDiff()))","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"For this we need to use the max ret objective and set the appropriate bounds on the asset weights.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# We need to set w_min and w_max weight constraints of the hierarchical clustering portfolio so the weights can be negative.\nhp.w_min = -1\nhp.w_max = 1\n\n# The short parameters for the portfolios optimised via NCO.\nshort = true\n\n# Absolute value of the sum of the short weights.\nshort_budget = 1\n\n# Sum of all the portfolio weights.\nbudget = 0\n\n# Upper bound for the value of each short weight.\nshort_u = 1\n\n# Upper bound for the value of each long weight.\nlong_u = 1\n\nw = optimise!(hp; rm = RLDaR(),\n              type = NCO(;\n                         # Allow shorting in the sub portfolios, as well as the synthetic portfolio optimised by NCO.\n                         # We also set the the values of `short_u` and `long_u` to be equal to 1.\n                         port_kwargs = (; short = short, budget = budget,\n                                        short_budget = short_budget, long_u = long_u,\n                                        short_u = short_u),\n                         # Max return objective.\n                         opt_kwargs = (; obj = MaxRet())\n                         #\n                         )\n              #\n              )\n\nwa = allocate!(hp; type = :NCO, investment = 3000, short = short, budget = budget,\n               short_budget = short_budget)\n\npretty_table(w; formatters = fmt1)\npretty_table(wa; formatters = fmt2)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This page was generated using Literate.jl.","category":"page"}]
}
