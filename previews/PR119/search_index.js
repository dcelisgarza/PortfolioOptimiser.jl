var documenterSearchIndex = {"docs":
[{"location":"ParameterEstimation/ParameterEstimationMisc/#Miscelaneous","page":"Miscelaneous","title":"Miscelaneous","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Public","page":"Miscelaneous","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Private","page":"Miscelaneous","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"Constraints/NetworkConstraints/#Network-constraints","page":"Network constraints","title":"Network constraints","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#Public","page":"Network constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BetweennessCentrality","page":"Network constraints","title":"PortfolioOptimiser.BetweennessCentrality","text":"@kwdef mutable struct BetweennessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BoruvkaTree","page":"Network constraints","title":"PortfolioOptimiser.BoruvkaTree","text":"@kwdef mutable struct BoruvkaTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.ClosenessCentrality","page":"Network constraints","title":"PortfolioOptimiser.ClosenessCentrality","text":"@kwdef mutable struct ClosenessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.DegreeCentrality","page":"Network constraints","title":"PortfolioOptimiser.DegreeCentrality","text":"@kwdef mutable struct DegreeCentrality{T1 <: Integer} <: CentralityType\n    type::T1 = 0\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.EigenvectorCentrality","page":"Network constraints","title":"PortfolioOptimiser.EigenvectorCentrality","text":"struct EigenvectorCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KatzCentrality","page":"Network constraints","title":"PortfolioOptimiser.KatzCentrality","text":"@kwdef mutable struct KatzCentrality{T1 <: Real} <: CentralityType\n    alpha::T1 = 0.3\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KruskalTree","page":"Network constraints","title":"PortfolioOptimiser.KruskalTree","text":"@kwdef mutable struct KruskalTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.MST","page":"Network constraints","title":"PortfolioOptimiser.MST","text":"@kwdef mutable struct MST{T1 <: Integer} <: NetworkType\n    tree::TreeType = KruskalTree()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.Pagerank","page":"Network constraints","title":"PortfolioOptimiser.Pagerank","text":"@kwdef mutable struct Pagerank{T1 <: Real, T2 <: Integer, T3 <: Real} <: CentralityType\n    alpha::T1 = 0.85\n    n::T2 = 100\n    epsilon::T3 = 1e-6\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.PrimTree","page":"Network constraints","title":"PortfolioOptimiser.PrimTree","text":"@kwdef mutable struct PrimTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.RadialityCentrality","page":"Network constraints","title":"PortfolioOptimiser.RadialityCentrality","text":"struct RadialityCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.StressCentrality","page":"Network constraints","title":"PortfolioOptimiser.StressCentrality","text":"@kwdef mutable struct StressCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TMFG","page":"Network constraints","title":"PortfolioOptimiser.TMFG","text":"@kwdef mutable struct TMFG{T1 <: Integer} <: NetworkType\n    similarity::DBHTSimilarity = DBHTMaxDist()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#Private","page":"Network constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.CentralityType","page":"Network constraints","title":"PortfolioOptimiser.CentralityType","text":"abstract type CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.NetworkType","page":"Network constraints","title":"PortfolioOptimiser.NetworkType","text":"abstract type NetworkType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TreeType","page":"Network constraints","title":"PortfolioOptimiser.TreeType","text":"abstract type TreeType end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Risk-measaures","page":"Risk measaures","title":"Risk measaures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"Some risk measures require solvers to compute.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"solvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"The dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":":solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"Users are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"using JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"PortfolioOptimiser will iterate over the solvers until it finds the first one to successfully solve the problem.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Public","page":"Risk measaures","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"RiskMeasures/Types/RiskMeasureTypes.jl\",\n\"RiskMeasures/Functions/RiskValue.jl\"]","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD","page":"Risk measaures","title":"PortfolioOptimiser.ADD","text":"struct ADD <: RiskMeasure\n\nAverage Drawdown risk measure for uncompounded returns.\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\n\nNotes\n\nMeasures the average of all peak-to-trough declines\nProvides a more balanced view than Maximum Drawdown\n\nExamples\n\n# Basic usage\nadd = ADD()\n\n# Custom settings\nadd = ADD(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD_r","page":"Risk measaures","title":"PortfolioOptimiser.ADD_r","text":"@kwdef mutable struct ADD_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Average Drawdown of compounded cumulative returns _ADD_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR","page":"Risk measaures","title":"PortfolioOptimiser.CDaR","text":"mutable struct CDaR{T1 <: Real} <: RiskMeasure\n\nConditional Drawdown at Risk risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\nalpha::T1: Significance level, must be in (0,1)\n\nNotes\n\nMeasures expected loss in the worst α% of cases\nInput validation ensures 0 < α < 1\n\nExamples\n\n# Default configuration (α = 0.05)\ncdar = CDaR()\n\n# Custom significance level\ncdar = CDaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01) # 1% significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR_r","page":"Risk measaures","title":"PortfolioOptimiser.CDaR_r","text":"@kwdef mutable struct CDaR_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Conditional Drawdown at Risk of compounded cumulative returns _CDaR_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\nalpha: significance level, alpha ∈ (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaR","page":"Risk measaures","title":"PortfolioOptimiser.CVaR","text":"mutable struct CVaR{T1 <: Real} <: RiskMeasure\n\nConditional Value at Risk (Expected Shortfall) risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\nalpha::T1: Significance level, must be in (0,1)\n\nNotes\n\nMeasures expected loss in the worst α% of cases\nInput validation ensures 0 < α < 1\n\nExamples\n\n# Default configuration (α = 0.05)\ncvar = CVaR()\n\n# Custom significance level\ncvar = CVaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaRRG","page":"Risk measaures","title":"PortfolioOptimiser.CVaRRG","text":"@kwdef mutable struct CVaRRG{T1 <: Real} <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefines the Conditional Value at Risk Range _CVaRRG risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nalpha: significance level of CVaR losses, alpha ∈ (0, 1).\nbeta: significance level of CVaR gains, beta ∈ (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR","page":"Risk measaures","title":"PortfolioOptimiser.DaR","text":"@kwdef mutable struct DaR{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Drawdown at Risk of uncompounded cumulative returns _DaR risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\nalpha: significance level, alpha ∈ (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR_r","page":"Risk measaures","title":"PortfolioOptimiser.DaR_r","text":"@kwdef mutable struct DaR_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Drawdown at Risk of compounded cumulative returns _DaR_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\nalpha: significance level, alpha ∈ (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR","page":"Risk measaures","title":"PortfolioOptimiser.EDaR","text":"mutable struct EDaR{T1 <: Real} <: RiskMeasure\n\nEntropic Drawdown at Risk risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\n\nFields\n\nsettings::RMSettings: Configuration settings\nalpha::T1: Significance level, must be in (0,1)\nsolvers::Union{<:AbstractDict, Nothing}: Optional JuMP-compatible solvers for exponential cone problems\n\nNotes\n\nRequires solver capability for exponential cone problems\nUses Portfolio/HCPortfolio solvers if solvers is nothing\nInput validation ensures 0 < α < 1\n\nExamples\n\n# Default configuration\nedar = EDaR()\n\n# Custom configuration with specific solver\nedar = EDaR(; alpha = 0.025,  # 2.5% significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR_r","page":"Risk measaures","title":"PortfolioOptimiser.EDaR_r","text":"@kwdef mutable struct EDaR_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\n    solvers::Union{<:AbstractDict, Nothing} = nothing\nend\n\nDefines the Entropic Drawdown at Risk of compounded cumulative returns _EDaR_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\nalpha: significance level, alpha ∈ (0, 1).\nsolvers: optional abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nif nothing: use the solvers stored in the instance of Portfolio or HCPortfolio.\nelse: use these ones.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EVaR","page":"Risk measaures","title":"PortfolioOptimiser.EVaR","text":"mutable struct EVaR{T1 <: Real} <: RiskMeasure\n\nEntropic Value at Risk risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\n\nFields\n\nsettings::RMSettings: Configuration settings\nalpha::T1: Significance level, must be in (0,1)\nsolvers::Union{<:AbstractDict, Nothing}: Optional JuMP-compatible solvers for exponential cone problems\n\nNotes\n\nRequires solver capability for exponential cone problems\nUses Portfolio/HCPortfolio solvers if solvers is nothing\nInput validation ensures 0 < α < 1\n\nExamples\n\n# Default configuration\nevar = EVaR()\n\n# Custom configuration with specific solver\nevar = EVaR(; alpha = 0.025,  # 2.5% significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Equal","page":"Risk measaures","title":"PortfolioOptimiser.Equal","text":"@kwdef struct Equal <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\nend\n\nDefines the Equal risk measure, where risk is allocated evenly among a group of assets.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.FLPM","page":"Risk measaures","title":"PortfolioOptimiser.FLPM","text":"mutable struct FLPM{T1 <: Real} <: RiskMeasure\n\nFirst Lower Partial Moment (Omega ratio) risk measure.\n\nType Parameters\n\nT1: Numeric type for the target threshold\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\ntarget::T1: Minimum return threshold for downside classification\n\nNotes\n\nUsed in Omega ratio calculations\nMeasures expected shortfall below target return\n\nExamples\n\n# Default configuration (target = 0.0)\nflpm = FLPM()\n\n# Custom target return\nflpm = FLPM(; target = 0.01)  # 1% minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.GMD","page":"Risk measaures","title":"PortfolioOptimiser.GMD","text":"@kwdef struct GMD <: RiskMeasure\n    settings::RMSettings = RMSettings()\n    owa::OWASettings = OWASettings()\nend\n\nDefines the Gini Mean Difference _GMD risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nowa: OWA risk measure settings OWASettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRMSettings","page":"Risk measaures","title":"PortfolioOptimiser.HCRMSettings","text":"mutable struct HCRMSettings{T1 <: Real}\n\nSettings configuration for hierarchical clustering (HC) risk measures.\n\nType Parameters\n\nT1: Numeric type for the scale parameter, must be a subtype of Real\n\nFields\n\nscale::T1: Scaling factor applied when adding the risk to the minimization objective\n\nExamples\n\n# Default settings\nsettings = HCRMSettings()\n\n# Custom scale\nsettings = HCRMSettings(; scale = 2.5)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Kurt","page":"Risk measaures","title":"PortfolioOptimiser.Kurt","text":"mutable struct Kurt <: RiskMeasure\n\nSquare root kurtosis risk measure implementation for portfolio optimization.\n\nFields\n\nsettings::RMSettings: Risk measure configuration settings\nw::Union{<:AbstractWeights, Nothing}: Optional T×1 vector of weights for expected return calculation\nkt::Union{AbstractMatrix, Nothing}: Optional cokurtosis matrix\nIf nothing: Uses the cokurtosis matrix from Portfolio/HCPortfolio\nOtherwise: Uses the provided matrix\n\nValidation\n\nWhen setting kt, the matrix must be square (N^2×N^2)\nIncludes runtime dimension checks for cokurtosis matrix\n\nExamples\n\n# Basic usage with default settings\nkurt = Kurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nkurt = Kurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nkurt = Kurt(; kt = nothing)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MAD","page":"Risk measaures","title":"PortfolioOptimiser.MAD","text":"mutable struct MAD <: RiskMeasure\n\nMean Absolute Deviation risk measure implementation.\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\nw::Union{<:AbstractWeights, Nothing}: Optional T×1 vector of weights for expected return calculation\nmu::Union{<:AbstractVector, Nothing}: Optional N×1 vector of expected asset returns\n\nNotes\n\nIf mu is nothing, the implementation uses expected returns from the Portfolio instance.\n\nExamples\n\n# Basic usage with default settings\nmad = MAD()\n\n# Custom configuration\nweights = ones(10) ./ 10  # Equal weights\nreturns = rand(10)        # Sample returns\nmad = MAD(; settings = RMSettings(; scale = 2.0), w = weights, mu = returns)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD","page":"Risk measaures","title":"PortfolioOptimiser.MDD","text":"struct MDD <: RiskMeasure\n\nMaximum Drawdown (Calmar ratio) risk measure for uncompounded returns.\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\n\nNotes\n\nMeasures the largest peak-to-trough decline in uncompounded returns\n\nExamples\n\n# Basic usage\nmdd = MDD()\n\n# Custom settings\nmdd = MDD(; settings = RMSettings(; scale = 2.0))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD_r","page":"Risk measaures","title":"PortfolioOptimiser.MDD_r","text":"@kwdef mutable struct MDD_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Maximum Drawdown (Calmar ratio) of compounded cumulative returns _MDD_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWA","page":"Risk measaures","title":"PortfolioOptimiser.OWA","text":"@kwdef struct OWA <: RiskMeasure\n    settings::RMSettings = RMSettings()\n    owa::OWASettings = OWASettings()\n    w::Union{<:AbstractVector, Nothing} = nothing\nend\n\nDefines the generic Ordered Weight Array _OWA risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nowa: OWA risk measure settings OWASettings.\nw: optional T×1 vector of ordered weights.\nif nothing: use owa_gmd to compute the weights.\nelse: use this value.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWASettings","page":"Risk measaures","title":"PortfolioOptimiser.OWASettings","text":"@kwdef mutable struct OWASettings{T1<:AbstractVector{<:Real}}\n    approx::Bool = true\n    p::T1 = Float64[2, 3, 4, 10, 50]\nend\n\nDefines the settings for Ordered Weight Array (OWA) risk measures.\n\nParameters\n\napprox:\nif true: use the approximate formulation based on power cone norms.\np: only used when approx = true. Vector of the order of p-norms to use in the approximation.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.QuadSD","page":"Risk measaures","title":"PortfolioOptimiser.QuadSD","text":"struct QuadSD <: SDSquaredFormulation end\n\nExplicit quadratic formulation for variance calculation in portfolio optimization.\n\nRisk Expression\n\nThe risk is computed as dot(w, sigma, w) where:\n\nw: N×1 vector of portfolio weights\nsigma: N×N covariance matrix\n\nUse Cases\n\nSuitable when direct quadratic form optimization is desired/needed or when specific solver requirements necessitate explicit quadratic expressions.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RG","page":"Risk measaures","title":"PortfolioOptimiser.RG","text":"@kwdef mutable struct RG{T1 <: Real} <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefines the Range _RG risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR","page":"Risk measaures","title":"PortfolioOptimiser.RLDaR","text":"mutable struct RLDaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nRelativistic Drawdown at Risk risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\nT2: Numeric type for the relativistic deformation parameter\n\nFields\n\nsettings::RMSettings: Configuration settings\nalpha::T1: Significance level, must be in (0,1)\nkappa::T2: Relativistic deformation parameter, must be in (0,1)\nsolvers::Union{<:AbstractDict, Nothing}: Optional JuMP-compatible solvers for 3D power cone problems\n\nNotes\n\nRequires solver capability for 3D power cone problems\nUses Portfolio/HCPortfolio solvers if solvers is nothing\nInput validation ensures both α and κ are in (0,1)\n\nExamples\n\n# Default configuration\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05,   # 5% significance level\n              kappa = 0.3,    # 30% Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR_r","page":"Risk measaures","title":"PortfolioOptimiser.RLDaR_r","text":"@kwdef mutable struct RLDaR_r{T1 <: Real} <: RiskMeasure\n    settings::RMSettings = RMSettings()\n    alpha::T1 = 0.05\n    solvers::Union{<:AbstractDict, Nothing} = nothing\nend\n\nDefines the Relativistic Drawdown at Risk of compounded cumulative returns _RLDaR_r risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nalpha: significance level, alpha ∈ (0, 1).\nkappa: relativistic deformation parameter, κ ∈ (0, 1).\nsolvers: optional abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nif nothing: use the solvers stored in the instance of Portfolio or HCPortfolio.\nelse: use these ones.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLVaR","page":"Risk measaures","title":"PortfolioOptimiser.RLVaR","text":"mutable struct RLVaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nRelativistic Value at Risk risk measure.\n\nType Parameters\n\nT1: Numeric type for the significance level\nT2: Numeric type for the relativistic deformation parameter\n\nFields\n\nsettings::RMSettings: Configuration settings\nalpha::T1: Significance level, must be in (0,1)\nkappa::T2: Relativistic deformation parameter, must be in (0,1)\nsolvers::Union{<:AbstractDict, Nothing}: Optional JuMP-compatible solvers for 3D power cone problems\n\nNotes\n\nRequires solver capability for 3D power cone problems\nUses Portfolio/HCPortfolio solvers if solvers is nothing\nInput validation ensures both α and κ are in (0,1)\n\nExamples\n\n# Default configuration\nrlvar = RLVaR()\n\n# Custom configuration\nrlvar = RLVaR(; alpha = 0.05,   # 5% significance level\n              kappa = 0.3,    # Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RMSettings","page":"Risk measaures","title":"PortfolioOptimiser.RMSettings","text":"mutable struct RMSettings{T1 <: Real, T2 <: Real}\n\nConfiguration settings for risk measures that subtype RiskMeasure.\n\nFields\n\nflag::Bool: Controls risk contribution to the optimization model\nscale::T1: Scaling factor for the risk measure\nub::T2: Upper bound constraint for the risk measure\n\nBehavior\n\nFor Portfolio optimization:\n\nflag: When true, includes risk in the JuMP model's risk expression\nscale: Scaling factor applied when adding the risk to the optimisation objective\nub: When finite, sets the upper bound constraint on the risk measure\n\nFor HCPortfolio optimization:\n\nflag: No effect\nscale: Scaling factor applied when adding the risk to the optimisation objective\nub: No effect\n\nExamples\n\n# Default settings\nsettings = RMSettings()\n\n# Custom settings\nsettings = RMSettings(; flag = true, scale = 2.0, ub = 0.5)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SD","page":"Risk measaures","title":"PortfolioOptimiser.SD","text":"mutable struct SD <: RiskMeasure\n\nStandard Deviation risk measure implementation for portfolio optimization.\n\nFields\n\nsettings::RMSettings: Risk measure configuration settings\nformulation::SDFormulation: Strategy for standard deviation/variance calculation\nsigma::Union{AbstractMatrix, Nothing}: Optional covariance matrix\nIf nothing: Uses the covariance matrix from Portfolio/HCPortfolio\nOtherwise: Uses the provided matrix\n\nValidation\n\nWhen setting sigma, the matrix must be square (N×N)\nIncludes runtime dimension checks for covariance matrix\n\nExamples\n\n# Basic usage with default settings\nsd_risk = SD()\n\n# Custom configuration with specific covariance matrix\nmy_sigma = [1.0 0.2; 0.2 1.0]\nsd_risk = SD(; settings = RMSettings(; scale = 2.0), formulation = SOCSD(),\n             sigma = my_sigma)\n\n# Using portfolio's built-in covariance\nsd_risk = SD(; formulation = QuadSD(), sigma = nothing)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SKurt","page":"Risk measaures","title":"PortfolioOptimiser.SKurt","text":"mutable struct SKurt{T1 <: Real} <: RiskMeasure\n\nSquare root semikurtosis risk measure implementation for portfolio optimization.\n\nType Parameters\n\nT1: Numeric type for the target threshold\n\nFields\n\nsettings::RMSettings: Risk measure configuration settings\ntarget::T1: Minimum return threshold for downside classification\nw::Union{<:AbstractWeights, Nothing}: Optional T×1 vector of weights for expected return calculation\nkt::Union{AbstractMatrix, Nothing}: Optional cokurtosis matrix\nIf nothing: Uses the cokurtosis matrix from Portfolio/HCPortfolio\nOtherwise: Uses the provided matrix\n\nNotes\n\nMeasures deviation only for returns below the target threshold\n\nValidation\n\nWhen setting kt, the matrix must be square (N^2×N^2)\nIncludes runtime dimension checks for cokurtosis matrix\n\nExamples\n\n# Basic usage with default settings\nskurt = SKurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nskurt = SKurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nskurt = SKurt(; kt = nothing, target = 0.015) # 1.5% minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SLPM","page":"Risk measaures","title":"PortfolioOptimiser.SLPM","text":"mutable struct SLPM{T1 <: Real} <: RiskMeasure\n\nSecond Lower Partial Moment (Sortino ratio) risk measure.\n\nType Parameters\n\nT1: Numeric type for the target threshold\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\ntarget::T1: Minimum return threshold for downside classification\n\nNotes\n\nUsed in Sortino ratio calculations\nMeasures variance of returns below target threshold\n\nExamples\n\n# Default configuration (target = 0.0)\nslpm = SLPM()\n\n# Custom settings\nslpm = SLPM(; settings = RMSettings(; scale = 2.0), target = 0.005)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SOCSD","page":"Risk measaures","title":"PortfolioOptimiser.SOCSD","text":"struct SOCSD <: SDSquaredFormulation end\n\nSecond-Order Cone (SOC) formulation for standard deviation calculation in portfolio optimization.\n\nImplementation Details\n\nUses MOI.SecondOrderCone constraints\nDefines a standard deviation variable dev\nSets risk expression as sd_risk = dev^2\n\nAdvantages\n\nCan be more numerically stable than explicit quadratic formulation\nOften more efficient for larger portfolios\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSD","page":"Risk measaures","title":"PortfolioOptimiser.SSD","text":"mutable struct SSD{T1 <: Real} <: RiskMeasure\n\nSemi Standard Deviation risk measure implementation.\n\nType Parameters\n\nT1: Numeric type for the target threshold\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\ntarget::T1: Minimum return threshold for downside classification\nw::Union{<:AbstractWeights, Nothing}: Optional T×1 vector of weights for expected return calculation\nmu::Union{<:AbstractVector, Nothing}: Optional N×1 vector of expected asset returns\n\nNotes\n\nMeasures deviation only for returns below the target threshold\nUses Portfolio's expected returns if mu is nothing\n\nExamples\n\n# Basic usage with default settings (target = 0.0)\nssd = SSD()\n\n# Custom configuration with specific target\nssd = SSD(; settings = RMSettings(; scale = 1.5), target = 0.02,  # 2% minimum return threshold\n          w = weights, mu = returns)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSkew","page":"Risk measaures","title":"PortfolioOptimiser.SSkew","text":"@kwdef struct SSkew <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefine the Quadratic SSkewness _Skew risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SVariance","page":"Risk measaures","title":"PortfolioOptimiser.SVariance","text":"@kwdef mutable struct SVariance{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    target::T1 = 0.0\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    mu::Union{<:AbstractVector, Nothing} = nothing\nend\n\nDefines the Semi Variance _SVariance risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\ntarget: minimum return threshold for classifying downside returns.\nw: optional T×1 vector of weights for computing the expected return in _SVariance.\nmu: optional N×1 vector of expected asset returns.\nif nothing: use the expected asset returns stored in the instance of Portfolio.\nelse: use this one.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SimpleSD","page":"Risk measaures","title":"PortfolioOptimiser.SimpleSD","text":"struct SimpleSD <: SDFormulation end\n\nLinear standard deviation formulation using Second-Order Cone constraints.\n\nImplementation Details\n\nUses MOI.SecondOrderCone constraints\nDefines standard deviation variable dev\nSets risk expression as sd_risk = dev\n\nKey Features\n\nCompatible with NOC optimizations due to them requiring strictly convex risk functions\nProvides direct standard deviation optimization rather than variance\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Skew","page":"Risk measaures","title":"PortfolioOptimiser.Skew","text":"@kwdef struct Skew <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefine the Quadratic Skewness _Skew risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TG","page":"Risk measaures","title":"PortfolioOptimiser.TG","text":"@kwdef mutable struct TG{T1 <: Real, T2 <: Real, T3 <: Integer} <: RiskMeasure\n    settings::RMSettings\n    owa::OWASettings\n    alpha_i::T1 = 0.0001\n    alpha::T2 = 0.05\n    a_sim::T3 = 100\nend\n\nDefines the Tail Gini Difference _TG risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nowa: OWA risk measure settings OWASettings.\nalpha_i: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha: end value of the significance level of CVaR losses, alpha ∈ (0, 1).\na_sim: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TGRG","page":"Risk measaures","title":"PortfolioOptimiser.TGRG","text":"mutable struct TGRG{T1 <: Real, T2 <: Real, T3 <: Integer, T4 <: Real, T5 <: Real, T6 <: Integer} <: RiskMeasure\n    settings::RMSettings\n    owa::OWASettings\n    alpha_i::T1 = 0.0001\n    alpha::T2 = 0.05\n    a_sim::T3 = 100\n    beta_i::T4 = 0.0001\n    beta::T5 = 0.05\n    b_sim::T6 = 100\nend\n\nDefines the Tail Gini Difference Range _TGRG risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nowa: OWA risk measure settings OWASettings.\nalpha_i: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha: end value of the significance level of CVaR losses, alpha ∈ (0, 1).\na_sim: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta: end value of the significance level of CVaR gains, beta ∈ (0, 1).\nb_sim: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI","page":"Risk measaures","title":"PortfolioOptimiser.UCI","text":"@kwdef mutable struct UCI{T1 <: Real} <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefines the Ulcer Index _UCI risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI_r","page":"Risk measaures","title":"PortfolioOptimiser.UCI_r","text":"@kwdef mutable struct UCI_r{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Ulcer Index of compounded cumulative returns _UCI_r risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.VaR","page":"Risk measaures","title":"PortfolioOptimiser.VaR","text":"@kwdef mutable struct VaR{T1 <: Real} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    alpha::T1 = 0.05\nend\n\nDefines the Value at Risk _VaR risk measure.\n\nParameters\n\nsettings: risk measure settings HCRMSettings.\nalpha: significance level, alpha ∈ (0, 1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Variance","page":"Risk measaures","title":"PortfolioOptimiser.Variance","text":"@kwdef mutable struct Variance{T1 <: Union{AbstractMatrix, Nothing}} <: HCRiskMeasure\n    settings::HCRMSettings = HCRMSettings()\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nDefines the Variance _Variance risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\nsigma: optional N×N covariance matrix.\nif nothing: use the covariance matrix stored in the instance of Portfolio or HCPortfolio.\nelse: use this one.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.WR","page":"Risk measaures","title":"PortfolioOptimiser.WR","text":"struct WR <: RiskMeasure\n\nWorst Realization risk measure.\n\nFields\n\nsettings::RMSettings: Configuration settings for the risk measure\n\nNotes\n\nConsiders the worst historical return as the risk measure\nUseful for extremely conservative risk assessment\n\nExamples\n\n# Basic usage\nwr = WR()\n\n# Custom settings\nwr = WR(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.dVar","page":"Risk measaures","title":"PortfolioOptimiser.dVar","text":"@kwdef struct dVar <: RiskMeasure\n    settings::RMSettings = RMSettings()\nend\n\nDefine the Brownian Distance Variance _dVar risk measure.\n\nParameters\n\nsettings: risk measure settings RMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ERM","page":"Risk measaures","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector, z::Real = 1.0, α::Real = 0.05)\n\nCompute the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = z ln left(dfracM_bmXleft(z^-1right)alpha right)\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nalpha in (01) is the significance parameter.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\nz: entropic moment, can be obtained from get_z_from_model and get_z after optimising a Portfolio.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ERM-2","page":"Risk measaures","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector, solvers:AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Risk Measure. Used in _EVaR, _EDaR and _EDaR_r.\n\nbeginalign\nmathrmERM(bmX z alpha) = \n    begincases\n        undersetz t uinf  t + z lnleft(dfrac1alpha Tright)\n        mathrmst  z geq sumlimits_i=1^T u_inonumber\n         (-X_i-t z u_i) in mathcalK_exp  forall  i=1dots T\n    endcases\n= undersetz0infleft z ln left(dfracM_bmXleft(z^-1right)alpha right)right\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nmathcalK_mathrmexp is the exponential cone.\nalpha in (01) is the significance parameter.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving exponential conic problems.\nα: significance level, α ∈ (0, 1).\n\nIf no valid solution is found then NaN will be returned.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RRM","page":"Risk measaures","title":"PortfolioOptimiser.RRM","text":"RRM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nCompute the Relativistic Risk Measure. Used in _RLVaR, _RLDaR and _RLDaR_r.\n\nbeginalign\nmathrmRRM^kappa_alpha(X) = left\n    beginalign\n        undersetz t psi theta  varepsilon omegatextinf  t + z ln_kappa left(dfrac1alpha Tright) + sumlimits_i=1^T left(psi_i + theta_i  right) nonumber\n        mathrmst  -X  - t + varepsilon + omega leq 0 nonumber\n        z geq 0 \n        left( zleft(dfrac1+kappa2kapparight) psi_ileft(dfrac1+kappakapparight) varepsilon_i right) in mathcalP_3^1(1+kappa) kappa(1+kappa)nonumber\n        left( omega_ileft(dfrac11-kapparight) theta_ileft(dfrac1kapparight) -z left(dfrac12kapparight) right) in mathcalP_3^1-kappa kappanonumber\n        forall  i=1dots T nonumber\n    endalign\nright\nendalign\n\nWhere:\n\nmathcalP_3^alpha 1-alpha is the power cone 3D.\nalpha in (01) is the significance parameter.\nkappa in (01) is the relativistic deformation parameter.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\nκ: relativistic deformation parameter, κ ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{ADD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::ADD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the ADD via _ADD. Inputs correspond to those of _ADD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{ADD_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::ADD_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the ADD_r via _ADD_r. Inputs correspond to those of _ADD_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{CDaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(cdar::CDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the CDaR via _CDaR. Inputs correspond to those of _CDaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{CDaR_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(cdar::CDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the CDaR_r via _CDaR_r. Inputs correspond to those of _CDaR_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{CVaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(cvar::CVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the CVaR via _CVaR. Inputs correspond to those of _CVaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{CVaRRG, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rcvar::CVaRRG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the CVaRRG via _CVaRRG. Inputs correspond to those of _CVaRRG.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{DaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(dar::DaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the DaR via _DaR. Inputs correspond to those of _DaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{DaR_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(dar::DaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the DaR_r via _DaR_r. Inputs correspond to those of _DaR_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{EDaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(edar::EDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the EDaR via _EDaR. Inputs correspond to those of _EDaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{EDaR_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(edar::EDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the EDaR_r via _EDaR_r. Inputs correspond to those of _EDaR_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{EVaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(evar::EVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the EVaR via _EVaR. Inputs correspond to those of _EVaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{Equal, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::Equal, w::AbstractVector; delta::Real = 0, kwargs...)\n\nCompute the risk as the inverse of the length of w.\n\nInputs\n\nw: N×1 vector of weights.\ndelta: is a displacement, used in risk_contribution and factor_risk_contribution.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{FLPM, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(svariance::FLPM, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the FLPM via _FLPM. Inputs correspond to those of _FLPM.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{GMD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::GMD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the GMD via _GMD. Inputs correspond to those of _GMD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{Kurt, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(kt::Kurt, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the Kurt via _Kurt. Inputs correspond to those of _Kurt.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{MAD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(mad::MAD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the MAD via _MAD. Inputs correspond to those of _MAD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{MDD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::MDD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the MDD via _MDD. Inputs correspond to those of _MDD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{MDD_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::MDD_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the MDD_r via _MDD_r. Inputs correspond to those of _MDD_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{OWA, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(owa::OWA, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the OWA via _OWA. Inputs correspond to those of _OWA.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{RG, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::RG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the RG via _RG. Inputs correspond to those of _RG.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{RLDaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rdar::RLDaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the RLDaR via _RLDaR. Inputs correspond to those of _RLDaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{RLDaR_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rdar::RLDaR_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the RLDaR_r via _RLDaR_r. Inputs correspond to those of _RLDaR_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{RLVaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rvar::RLVaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the RLVaR via _RLVaR. Inputs correspond to those of _RLVaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(sd::SD, w::AbstractVector; kwargs...)\n\nCompute the SD via _SD. Inputs correspond to those of _SD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SKurt, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(skt::SKurt, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the SKurt via _SKurt. Inputs correspond to those of _SKurt.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SLPM, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(svariance::SLPM, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the SLPM via _SLPM. Inputs correspond to those of _SLPM.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SSD, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(mad::SSD, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the SSD via _SSD. Inputs correspond to those of _SSD.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SSkew, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::SSkew, w::AbstractVector; SV::AbstractMatrix, kwargs...)\n\nCompute the SSkew via _Skew. Inputs correspond to those of _Skew.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{SVariance, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(svariance::SVariance, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the SVariance via _SVariance. Inputs correspond to those of _SVariance.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{Skew, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::Skew, w::AbstractVector; V::AbstractMatrix, kwargs...)\n\nCompute the Skew via _Skew. Inputs correspond to those of _Skew.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{TG, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(tg::TG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the TG via _TG. Inputs correspond to those of _TG.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{TGRG, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(rtg::TGRG, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the TGRG via _TGRG. Inputs correspond to those of _TGRG.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{UCI, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::UCI, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the UCI via _UCI. Inputs correspond to those of _UCI.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{UCI_r, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::UCI_r, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the UCI_r via _UCI_r. Inputs correspond to those of _UCI_r.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{VaR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(var::VaR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the VaR via _VaR. Inputs correspond to those of _VaR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{Variance, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(sd::Variance, w::AbstractVector; kwargs...)\n\nCompute the Variance via _Variance. Inputs correspond to those of _Variance.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{WR, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::WR, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the WR via _WR. Inputs correspond to those of _WR.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.calc_risk-Tuple{dVar, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::dVar, w::AbstractVector; X::AbstractMatrix, kwargs...)\n\nCompute the dVar via _dVar. Inputs correspond to those of _dVar.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#Private","page":"Risk measaures","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk measaures","title":"Risk measaures","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"RiskMeasures/Types/RiskMeasureTypes.jl\",\n\"RiskMeasures/Functions/RiskValue.jl\"]","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.AbstractRiskMeasure","page":"Risk measaures","title":"PortfolioOptimiser.AbstractRiskMeasure","text":"abstract type AbstractRiskMeasure end\n\nRoot abstract type for all risk measures in the type hierarchy. Serves as the base type for implementing various risk measurement approaches.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRiskMeasure","page":"Risk measaures","title":"PortfolioOptimiser.HCRiskMeasure","text":"abstract type HCRiskMeasure <: AbstractRiskMeasure end\n\nAbstract type for specialized risk measures that can only be used with HCPortfolio optimization. These risk measures are not compatible with standard Portfolio optimization.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RiskMeasure","page":"Risk measaures","title":"PortfolioOptimiser.RiskMeasure","text":"abstract type RiskMeasure <: AbstractRiskMeasure end\n\nAbstract type for risk measures that are compatible with both Portfolio and HCPortfolio optimization. Concrete subtypes can be used in either context.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SDFormulation","page":"Risk measaures","title":"PortfolioOptimiser.SDFormulation","text":"abstract type SDFormulation end\n\nAbstract type hierarchy for Mean-Variance optimization formulations. Serves as the root type for different standard deviation calculation approaches in portfolio optimization.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SDSquaredFormulation","page":"Risk measaures","title":"PortfolioOptimiser.SDSquaredFormulation","text":"abstract type SDSquaredFormulation <: SDFormulation end\n\nAbstract type for Mean-Variance formulations that produce quadratic expressions for the JuMP model's standard deviation risk.\n\nImplementation Notes\n\nProduces a JuMP.QuadExpr for the model's sd_risk\nNOC (Near Optimal Centering) optimizations require strictly convex risk functions and are only compatible with SimpleSD\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._ADD-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._ADD","text":"_ADD(x::AbstractVector)\n\nCompute the Average Drawdown of uncompounded cumulative returns.\n\nbeginalign\nmathrmADD_a(bmX) = dfrac1T sumlimits_j=1^T mathrmDD_a(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._ADD_r-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._ADD_r","text":"_ADD_r(x::AbstractVector)\n\nCompute the Average Drawdown of compounded cumulative returns.\n\nbeginalign\nmathrmADD_r(bmX) = dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._CDaR","page":"Risk measaures","title":"PortfolioOptimiser._CDaR","text":"_CDaR(x::AbstractVector, α::Real = 0.05)\n\nCompute the Conditional Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmCDaR_a(bmX alpha) = mathrmDaR_a(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_a(bmX j) - mathrmDaR_a(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR, and mathrmDaR_a(bmX alpha) the Drawdown at Risk of uncompounded cumulative returns as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._CDaR_r","page":"Risk measaures","title":"PortfolioOptimiser._CDaR_r","text":"_CDaR_r(x::AbstractVector, α::Real = 0.05)\n\nCompute the Conditional Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmCDaR_r(bmX alpha) = mathrmDaR_r(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_r(bmX j) - mathrmDaR_r(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._CVaR","page":"Risk measaures","title":"PortfolioOptimiser._CVaR","text":"_CVaR(x::AbstractVector, α::Real = 0.05)\n\nCompute the Conditional Value at Risk.\n\nbeginalign\nmathrmCVaR(bmX alpha) = mathrmVaR(bmX alpha) + dfrac1alpha T sumlimits_t=1^T maxleft( -X_t - mathrmVaR(bmX alpha) 0right)\nendalign\n\nWhere:\n\nmathrmVaR(bmX alpha) is the Value at Risk as defined in _VaR.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._CVaRRG-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._CVaRRG","text":"_CVaRRG(x::AbstractVector; alpha::Real = 0.05, beta::Real = alpha)\n\nCompute the _CVaR Range.\n\nInputs\n\nx: T×1 returns vector.\nalpha: significance level of CVaR losses, alpha ∈ (0, 1).\nbeta: significance level of CVaR gains, beta ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._DaR","page":"Risk measaures","title":"PortfolioOptimiser._DaR","text":"_DaR(x::AbstractArray, α::Real = 0.05)\n\nCompute the Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmDaR_a(bmX alpha) = undersetj in (0 T)max left mathrmDD_a(bmX j) in mathbbR  F_mathrmDDleft(mathrmDD_a(bmX j)right)  1 - alpha right\nmathrmDD_a(bmX j) = undersett in (0 j)maxleft( sumlimits_i=0^t X_i right) - sumlimits_i=0^j X_i\nmathrmDD_a(bmX) = mathrmDD_a(bmX j) quad forall j = 1ldotsT\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns.\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j.\nmathrmDaR_a(bmX alpha) the Drawdown at Risk of uncompounded cumulative returns.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._DaR_r","page":"Risk measaures","title":"PortfolioOptimiser._DaR_r","text":"_DaR_r(x::AbstractArray, α::Real = 0.05)\n\nCompute the Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmDaR_r(bmX alpha) = undersetj in (0 T)max left mathrmDD_r(bmX j) in mathbbR  F_mathrmDDleft(mathrmDD_r(bmX j)right)  1 - alpha right\nmathrmDD_r(bmX j) = undersett in (0 j)maxleft( prodlimits_i=0^t left(1+X_iright) right) - prodlimits_i=0^j left(1+X_iright)\nmathrmDD_r(bmX) = mathrmDD_r(bmX j) quad forall j = 1ldotsT\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns.\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._EDaR","page":"Risk measaures","title":"PortfolioOptimiser._EDaR","text":"_EDaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmEDaR_a(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_a(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_a(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._EDaR_r","page":"Risk measaures","title":"PortfolioOptimiser._EDaR_r","text":"_EDaR_r(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmEDaR_r(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_r(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_r(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._EVaR","page":"Risk measaures","title":"PortfolioOptimiser._EVaR","text":"_EVaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Value at Risk.\n\nbeginalign\nmathrmEVaR(bmXalpha) = undersetz  0inf leftmathrmERM(bmX z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(bmX z alpha) is the entropic risk measure as defined in ERM.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._FLPM","page":"Risk measaures","title":"PortfolioOptimiser._FLPM","text":"_FLPM(x::AbstractVector, r::Real = 0.0)\n\nCompute the First Lower Partial Moment (Omega ratio).\n\nbeginalign\nmathrmFLPM(bmX r) = dfrac1T  sumlimits_t=1^Tmaxleft(r - X_t 0right)\nendalign\n\nInputs\n\nx: T×1 returns vector.\nr: minimum return target.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._GMD-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._GMD","text":"_GMD(x::AbstractVector)\n\nCompute the Gini Mean Difference.\n\nInputs\n\nx: T×1 returns vector.\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._Kurt","page":"Risk measaures","title":"PortfolioOptimiser._Kurt","text":"_Kurt(x::AbstractVector, w::Union{AbstractWeights, Nothing} = nothing;\n               scale::Bool = false)\n\nCompute the Square Root Kurtosis.\n\nbeginalign\nmathrmKurt(bmX) = left(dfrac1T sumlimits_t=1^T left( X_t - mathbbE(bmX) right)^4 right)^12\nendalign\n\nInputs\n\nx: T×1 returns vector.\nw: T×1 optional vector of weights for computing the expected return.\nscale:\nif true: divides by 2, used in risk_contribution.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._MAD","page":"Risk measaures","title":"PortfolioOptimiser._MAD","text":"_MAD(x::AbstractVector, w::Union{AbstractWeights, Nothing} = nothing)\n\nCompute the Mean Absolute Deviation.\n\nbeginalign\nmathrmMAD(bmX) = dfrac1T sumlimits_t=1^T leftlvert X_t - mathbbE(bmX) rightrvert\nendalign\n\nInputs\n\nx: T×1 returns vector.\nw: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._MDD-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._MDD","text":"_MDD(x::AbstractVector)\n\nCompute the Maximum Drawdown (Calmar ratio) of uncompounded cumulative returns.\n\nbeginalign\nmathrmMDD_a(bmX) = maxmathrmDD_a(bmX)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._MDD_r-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._MDD_r","text":"_MDD_r(x::AbstractVector)\n\nCompute the Maximum Drawdown of compounded cumulative returns.\n\nbeginalign\nmathrmMDD_r(bmX) = max mathrmDD_r(bmX)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._OWA-Tuple{AbstractVector, AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._OWA","text":"_OWA(x::AbstractVector, w::AbstractVector)\n\nCompute the Ordered Weight Array risk measure.\n\nInputs\n\nw: T×1 precomputed vector of OWA weights. Can be computed with owa_gmd, owa_rg, owa_rcvar, owa_tg, owa_rtg, owa_l_moment or owa_l_moment_crm.\nx: T×1 returns vector.\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._RG-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._RG","text":"_RG(x::AbstractVector)\n\nCompute the Range.\n\nInputs\n\nx: T×1 returns vector.\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._RLDaR","page":"Risk measaures","title":"PortfolioOptimiser._RLDaR","text":"_RLDaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nCompute the Relativistic Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign\nmathrmRLDaR_a(bmX alpha kappa) = mathrmRRM(mathrmDD_a(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_a(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of uncompounded cumulative returns as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\nκ: relativistic deformation parameter, κ ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._RLDaR_r","page":"Risk measaures","title":"PortfolioOptimiser._RLDaR_r","text":"_RLDaR_r(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nCompute the Relativistic Drawdown at Risk of compounded cumulative returns.\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\nsolvers: abstract dict containing the a JuMP-compatible solver capable of solving 3D power cone problems.\nα: significance level, α ∈ (0, 1).\nκ: relativistic deformation parameter, κ ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._RLVaR","page":"Risk measaures","title":"PortfolioOptimiser._RLVaR","text":"_RLVaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nCompute the Relativistic Value at Risk.\n\nbeginalign\nmathrmRLVaR(bmX alpha kappa) = mathrmRRM(bmX alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(bmX alpha kappa) is the Relativistic Risk Measure as defined in RRM.\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\nκ: relativistic deformation parameter, κ ∈ (0, 1).\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._SD-Tuple{AbstractVector, AbstractMatrix}","page":"Risk measaures","title":"PortfolioOptimiser._SD","text":"_SD(w::AbstractVector, Σ::AbstractMatrix)\n\nCompute the Standard Deviation. Square root of _Variance.\n\nbeginalign\nmathrmSD(bmw mathbfSigma) = left(bmw^intercal  mathbfSigma  bmwright)^12\nendalign\n\nInputs\n\nw: vector of asset weights.\nΣ: covariance matrix of asset returns.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._SKurt","page":"Risk measaures","title":"PortfolioOptimiser._SKurt","text":"_SKurt(x::AbstractVector, r::Real = 0.0,\n        w::Union{AbstractWeights, Nothing} = nothing; scale::Bool = false)\n\nCompute the Square Root Semi Kurtosis.\n\nbeginalign\nmathrmSKurt(bmX) = left(dfrac1T sumlimits_t=1^T minleft( X_t - mathbbE(bmX) r right)^4 right)^12\nendalign\n\nInputs\n\nx: T×1 returns vector.\nr: minimum return target.\nw: T×1 optional vector of weights for computing the expected return.\nscale:\nif true: divides by 2, used in risk_contribution.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._SLPM","page":"Risk measaures","title":"PortfolioOptimiser._SLPM","text":"_SLPM(x::AbstractVector, r::Real = 0.0)\n\nCompute the Second Lower Partial Moment (Sortino Ratio).\n\nbeginalign\nmathrmSLPM(bmX r) = left(dfrac1T-1 sumlimits_t=1^Tmaxleft(r - X_t 0right)^2right)^12\nendalign\n\nInputs\n\nx: T×1 returns vector.\nr: minimum return target.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._SSD","page":"Risk measaures","title":"PortfolioOptimiser._SSD","text":"_SSD(x::AbstractVector, r::Real = 0.0, w::Union{AbstractWeights, Nothing} = nothing)\n\nCompute the Semi-Standard Deviation.\n\nbeginalign\nmathrmSSD(bmX) = left(dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2right)^12\nendalign\n\nInputs\n\nx: T×1 returns vector.\nr: minimum return target.\nw: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._SVariance","page":"Risk measaures","title":"PortfolioOptimiser._SVariance","text":"_SVariance(x::AbstractVector, r::Real = 0.0, w::Union{AbstractWeights, Nothing} = nothing)\n\nCompute the Semi-Variance, this is the square of _SSD.\n\nbeginalign\nmathrmSVariance(bmX) = dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2\nendalign\n\nInputs\n\nx: T×1 returns vector.\nr: minimum return target.\nw: T×1 optional vector of weights for computing the expected return.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._Skew-Tuple{AbstractVector, AbstractArray}","page":"Risk measaures","title":"PortfolioOptimiser._Skew","text":"_Skew(w::AbstractVector, V::AbstractArray)\n\nCompute the Quadratic Skewness/Semi Skewness.\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw is the vector of asset weights.\nmathbfV is the sum of the symmetric negative spectral slices of coskewness or semicoskewness.\n\nInputs\n\nw: N×1 vector of weights.\nV: N×N matrix of sum of negative spectral slices of the coskewness or semi coskewness.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._TG-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._TG","text":"_TG(x::AbstractVector; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Int = 100)\n\nCompute the Tail Gini.\n\nInputs\n\nx: T×1 returns vector.\nalpha_i: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha: end value of the significance level of CVaR losses, alpha ∈ (0, 1).\na_sim: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._TGRG-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._TGRG","text":"_TGRG(x::AbstractVector; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Real = 100,\n     beta_i::Real = alpha_i, beta::Real = alpha, b_sim::Integer = a_sim)\n\nCompute the Tail Gini Range.\n\nInputs\n\nx: T×1 returns vector.\nalpha_i: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha: end value of the significance level of CVaR losses, alpha ∈ (0, 1).\na_sim: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta: end value of the significance level of CVaR gains, beta ∈ (0, 1).\nb_sim: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._UCI-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._UCI","text":"_UCI(x::AbstractVector)\n\nCompute the Ulcer Index of uncompounded cumulative returns.\n\nbeginalign\nmathrmUCI_a(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_a(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in _DaR.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._UCI_r-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._UCI_r","text":"_UCI_r(x::AbstractVector)\n\nCompute the Ulcer Index of compounded cumulative returns.\n\nbeginalign\nmathrmUCI_r(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in _DaR_r.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._VaR","page":"Risk measaures","title":"PortfolioOptimiser._VaR","text":"_VaR(x::AbstractVector, α::Real = 0.05)\n\nCompute the Value at Risk, used in _CVaR.\n\nbeginalign\nmathrmVaR(bmX alpha) = -undersett in (0 T)inf left X_t in mathbbR  F_bmX(X_t)  alpha right\nendalign\n\nInputs\n\nx: T×1 returns vector.\nα: significance level, α ∈ (0, 1).\n\nwarning: Warning\nIn-place sorts the input vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._Variance-Tuple{AbstractVector, AbstractMatrix}","page":"Risk measaures","title":"PortfolioOptimiser._Variance","text":"_Variance(w::AbstractVector, Σ::AbstractMatrix)\n\nCompute the Variance. Square of _SD.\n\nbeginalign\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\nendalign\n\nInputs\n\nw: vector of asset weights.\nΣ: covariance matrix of asset returns.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._WR-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._WR","text":"_WR(x::AbstractVector)\n\nCompute the Worst Realisation or Worst Case Scenario.\n\nbeginalign\nmathrmWR(bmX) = -min(bmX)\nendalign\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser._dVar-Tuple{AbstractVector}","page":"Risk measaures","title":"PortfolioOptimiser._dVar","text":"_dVar(x::AbstractVector)\n\nCompute the Brownian distance variance.\n\nbeginalign\nmathrmdVar(bmX) = mathrmdCov(bmX bmX) =  dfrac1T^2 sumlimits_i=1^Tsumlimits_j=1^T A_ij^2\nmathrmdCov(bmX bmY) = dfrac1T^2 sumlimits_i=1^T sumlimits_j=1^T A_ij B_ij\nA_ij = a_ij - bara_i - bara_j + bara_\nB_ij = b_ij - barb_i - barb_j + barb_\na_ij = lVert X_i - X_j rVert_2 quad forall i j = 1 ldots  T\nb_ij = lVert Y_i - Y_j rVert_2 quad forall i j = 1 ldots  T\nendalign\n\nwhere:\n\nbmX and bmY are random variables, they are equal in this case as they are the portfolio returns.\na_ij and b_ij are entries of a distance matrix where i and j are points in time. Each entry is defined as the Euclidean distance lVert cdot rVert_2 between the value of the random variable at time i and its value at time j.\nbara_icdot and barb_icdot are the i-th row means of their respective matrices.\nbara_cdotj and barb_cdotj are the j-th column means of their respective matrices.\nbara_cdotcdot and barb_cdotcdot are the grand means of their respective matrices.\nA_ij and B_ij are doubly centered distances.\n\nInputs\n\nx: T×1 returns vector.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#Risk","page":"Risk","title":"Risk","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/#Public","page":"Risk","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.calc_risk-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                         F::AbstractMatrix = port.f_returns,\n                         type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                         rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6)\n\nCompute the factor risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nw: Na×1 vector of asset weights.\nX: T×Na matrix of asset returns.\nF: T×Nf matrix of factor returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nOutputs\n\nrc_f: Nf×1 vector of risk contribution per factor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.number_effective_assets-Tuple{Any}","page":"Risk","title":"PortfolioOptimiser.number_effective_assets","text":"number_effective_assets(port; type::Symbol = isa(port, Portfolio) ? :Trad : :HRP)\n\nCompute the number of effective assets.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                  rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6,\n                  marginal::Bool = false)\n\nCompute the asset risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nmarginal:\nif true: compute the marginal risk contribution.\nelse: compute the risk by contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc: Na×1 vector of risk contribution per asset.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Risk","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n             mu::AbstractVector = port.mu,\n             type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n             rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6, rf::Real = 0.0,\n             kelly::Bool = false)\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N matrix of asset returns.\nmu: N×1 vector of expected returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioRisk/#Private","page":"Risk","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Constraints/ViewsConstraints/#Views-constraints","page":"Views constraints","title":"Views constraints","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/#Public","page":"Views constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.asset_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.asset_views","text":"asset_views(views::DataFrame, asset_sets::DataFrame)\n\nCreate the asset views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×9 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nType: (String) specifies the object(s) to which a view applies:\nAsset: specific asset.\nSubset: whole class.\nSet: (String) if Type is Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the view applies.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nReturn: (<:Real) the view's return.\nRelative_Type: (String) specifies to what the view is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative view.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nP: Nv×Na matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nviews = DataFrame(\"Enabled\" => [true, true, true, true, true],\n                  \"Type\" => [\"Asset\", \"Subset\", \"Subset\", \"Asset\", \"Subset\"],\n                  \"Set\" => [\"\", \"Class 2\", \"Class 1\", \"\", \"Class 1\"],\n                  \"Position\" => [\"WFC\", \"Financial\", \"Equity\", \"FB\", \"Fixed Income\"],\n                  \"Sign\" => [\"<=\", \">=\", \">=\", \">=\", \"<=\"],\n                  \"Return\" => [0.3, 0.1, 0.05, 0.03, 0.017],\n                  \"Relative_Type\" => [\"Asset\", \"Subset\", \"Asset\", \"\", \"\"],\n                  \"Relative_Set\" => [\"\", \"Class 1\", \"\", \"\", \"\"],\n                  \"Relative_Position\" => [\"FB\", \"Fixed Income\", \"TLT\", \"\", \"\"])\nP, Q = asset_views(views, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.factor_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.factor_views","text":"factor_views(views::DataFrame, loadings::DataFrame)\n\nCreate the factor views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×4 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nFactor: (String) name of the view's factor.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the view is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nP: Nv×Nf matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nviews = DataFrame(\"Enabled\" => [true, true, true], \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\"],\n                  \"Sign\" => [\"<=\", \"<=\", \">=\"], \"Value\" => [0.9, -1.2, 0.3],\n                  \"Relative_Factor\" => [\"USMV\", \"\", \"\"])\nP, Q = factor_views(views, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#Private","page":"Views constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"EditURL = \"../../../examples/2_asset_statistics.jl\"","category":"page"},{"location":"examples/2_asset_statistics/#Example-2:-Asset-statistics","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This example follows from Example 1. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This example focuses on the computation of asset statistics. This is one of the most important functions in PortfolioOptimiser. It can be used for computing any and all statistics needed to optimise Portfolio and HCPortfolio. It is also possible to define any and all statistics at variable instantiation, or by changing the relevant property in the Portfolio or HCPortfolio instance. Every case will perform validation checks.","category":"page"},{"location":"examples/2_asset_statistics/#2.1-Downloading-the-data","page":"Example 2: Asset statistics","title":"2.1 Downloading the data","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      SparseArrays\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/#2.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 2: Asset statistics","title":"2.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"portfolio = Portfolio(; prices = prices);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/#3-Asset-statistics","page":"Example 2: Asset statistics","title":"3 Asset statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"When you first create a Portfolio in this way, it does not contain any statistics other than the returns. So we must compute them.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"PortfolioOptimiser uses the StatsAPI.jl interfaces through StatsBase.jl. Meaning it is composable with other packages which use the common framework, and it also makes it easy for users to define their custom methods by using Julia's typesystem.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We'll only focus on the expected returns and covariance matrix. The default parameters are the arithmetic mean and sample covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"asset_statistics!(portfolio; set_kurt = false, set_skurt = false, set_skew = false,\n                  set_sskew = false);\n\n# Save these for later use.\nmu1 = copy(portfolio.mu);\ncov1 = copy(portfolio.cov);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We can prove this by computing the arithmetic mean and sample covariance of the returns.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"println(isapprox(mu1, vec(mean(portfolio.returns; dims = 1)))) # true\nprintln(isapprox(cov1, cov(portfolio.returns; dims = 1))) # true","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"These statistics are not very robust, so they're not very reliable. We can make them a bit better by using weights. First we need to explain the estimators.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.1-Mean-estimators","page":"Example 2: Asset statistics","title":"2.3.1 Mean estimators","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Lets start with the easier one, PortfolioOptimiser.MeanEstimator. There are four of these, MuSimple, MuJS, MuBS, MuBOP. As you can see, they are all subtypes of PortfolioOptimiser.MeanEstimator, we will use this later on to define our own method. Lets first focus on the first estimator, which is also the default.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We've already seen its default behaviour, we know from above it's the same as the arithmetic mean. But it can take a vector of AbstractWeights.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"First lets get the number of timestamps T, and number of assets N. We'll use T for defining our weights.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"T, N = size(portfolio.returns)","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"There are a variety of weights, but the only ones that make sense with no prior knowledge are exponential weights. Now lets use this to compute the asset expected returns vector, we do this by passing the argument mu_type = mu_type_1 to the function, we've also set the set_cov = false so it doesn't recompute the covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# Play around with the value of lambda (1/T, in the example) to see the effect\n# it has on the weights and computed expected returns vector.\nw = eweights(1:T, 1 / T; scale = true)\nmu_type_1 = MuSimple(; w = w)\nasset_statistics!(portfolio; mu_type = mu_type_1, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu2 = copy(portfolio.mu)\n\nprintln(isapprox(mu1, mu2)) # false","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The other three estimators included in PortfolioOptimiser require a target and a covariance matrix, since they use these to correct the estimate of the arithmetic mean. The available targets are GM, VW, SE, they all default to GM. They can also take an AbstractWeights, which they will use to compute the arithmetic mean that is then corrected with the target and covariane matrix. We'll try a few combinations.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The covariance matrix is not needed, if it is empty, it will be computed by asset_statistics! from the parameters given to it via cov_type even if set_cov = false, it just won't replace the old covariance matrix with the one that's been computed for the mean estimator, once the calculation is done, the sigma field of the estimator will be set to empty once more. If a covariance matrix is provided, then asset_statistics! will use this rather than computing one for it.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Feel free to mix and match, and to play around with various combinations.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"mu_type_2 = MuJS(; target = GM())\nasset_statistics!(portfolio; mu_type = mu_type_2, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu3 = copy(portfolio.mu)\n\nmu_type_3 = MuBS(; target = VW(), w = w)\nasset_statistics!(portfolio; mu_type = mu_type_3, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu4 = copy(portfolio.mu)\n\n# Using a custom covariance with random noise.\n# It's not guaranteed to be positive definite.\nnoise = randn(N, N) / N^2\nnoise = transpose(noise) * noise\nmu_type_4 = MuBOP(; target = SE(), sigma = cov1 + noise)\nasset_statistics!(portfolio; mu_type = mu_type_4, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu5 = copy(portfolio.mu);\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"All targets subtype PortfolioOptimiser.MeanTarget. It is possible for users to define a one by creating a concrete subtype of PortfolioOptimiser.MeanTarget and defining a new target_mean for the custom target.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"struct CustomMeanTarget <: MeanTarget\n    ...\nend\nfunction target_mean(ct::CustomMeanTarget, mu::AbstractVector,\n                     sigma::AbstractMatrix, inv_sigma,\n                     T::Integer, N::Integer)\n    ...\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"However, this limits the target to using the same data as the current ones. It's easier to define a new concrete subtype of PortfolioOptimiser.MeanEstimator. We will do this in the following section.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.2-Defining-a-custom-mean-method","page":"Example 2: Asset statistics","title":"2.3.2 Defining a custom mean method","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"In order to define a new method all you need to do is create a new subtype of PortfolioOptimiser.MeanEstimator (it's not exported so it must be qualified) and define a new StatsBase.mean function.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This is all we need, we can now define a custom mean that is the same as the MuSimple, but scales the vector. You can scale the vector uniformly, by providing a scalar, or scale each item individually by providing an AbstractVector.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"mutable struct MyScaledMean{T1, T2} <: PortfolioOptimiser.MeanEstimator\n    scale::T1\n    w::T2\nend\nfunction MyScaledMean(; scale::Union{<:AbstractVector{<:Real}, Real} = 1, w = nothing)\n    return MyScaledMean{typeof(scale), typeof(w)}(scale, w)\nend\n\n# We have to turn this into a vec so we can scale by a vector.\nfunction StatsBase.mean(me::MyScaledMean, X::AbstractArray; dims::Int = 1)\n    return me.scale .*\n           vec((isnothing(me.w) ? mean(X; dims = dims) : mean(X, me.w; dims = dims)))\nend\n\nscale = 5\nmu_type_5 = MyScaledMean(; scale = scale)\nasset_statistics!(portfolio; mu_type = mu_type_5, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu6 = copy(portfolio.mu)\n# Should be a vector of 5's.\nprintln(mu6 ./ mu1)\n\nscale = 1:N\nmu_type_6 = MyScaledMean(; scale = scale)\nasset_statistics!(portfolio; mu_type = mu_type_6, set_cov = false, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nmu7 = copy(portfolio.mu)\n# Should be a vector going from 1 to N.\nprintln(mu7 ./ mu1)","category":"page"},{"location":"examples/2_asset_statistics/#2.3.3-Covariance-estimators","page":"Example 2: Asset statistics","title":"2.3.3 Covariance estimators","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"PortfolioOptimiser comes with quite a few covariance estimators. However, it is best to wrap them all with PortCovCor. This is because it contains methods for denoising, fixing non-positive definite matrices, and using a graph-based algorithm for computing the covariance based on its relational structure.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Portfoliooptimiser's mean and covariance estimators are based on the idea of subtyping StatsBase.CovarianceEstimator to specialise their respective functions.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We will also not illustrate how to define custom methods as it follows the same principles as for the mean estimators, but instead by creating a concrete subtype (a struct) of StatsBase.CovarianceEstimator and implementing StatsBase.cov for the custom type.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"All estimators are different, some can nest other estimators, and those estimators may or may not support weights or even certain types of weights. There are so many different permutations that we will not go over an exhaustive list. For details on external methods please refer back to the documentation in their respective packages. For details on PortfolioOptimiser's estimators please refer to the docs.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"As far as my recommendation/preference, I like the CorGerberSB1 as it's fairly tuneable and produces less noisy matrices, but it is among the more expensive ones to compute.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"# `corrected = true` does not support weights\nce0_a = StatsBase.SimpleCovariance(; corrected = false)\n\n# Method from [CovarianceEstimation.jl](https://github.com/mateuszbaran/CovarianceEstimation.jl),\n# does not support weights.\nce0_b = CovarianceEstimation.AnalyticalNonlinearShrinkage()\n\n# Exponential weights, try something else if you wish.\nw = eweights(1:T, 1 / sqrt(T); scale = true)\n\n# Risk free rate, we will use as the minimum acceptable return for the semi covariance.\nrf = 3.5 / 100 / 252","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Lets put our estimators in a vector to make programming easier.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces = CovarianceEstimator[]\n# Full covariance.\npush!(ces, CovFull(; ce = ce0_a, w = w))\n\n# Semi covariance, only focuses on variations that take\n# the returns below the target value.\npush!(ces, CovSemi(; ce = ce0_b, target = rf))\n\n# This bins the data and uses the information overlap between variables.\npush!(ces, CorMutualInfo())\n\n# This computes the distance covariance.\npush!(ces, CovDistance())\n\n# This uses how closely related the lower tail of the returns are between assets.\n# It combines the idea behind the Value at Risk and rank correlation.\npush!(ces, CorLTD())\n\n# The Gerber family of robust covariance estimators that count\n# co-movements and filters large and small movements by classifying\n# them into zones. They are a rank-based (counting) approach.\npush!(ces, CorGerber0())\npush!(ces, CorGerber1())\npush!(ces, CorGerber2())\n\n# Smyth-Broby family of covariance estimators that modifies the\n# Gerber statistics by scoring the quality of the classification\n# of co-movements (instead of adding 1 they add a score).\npush!(ces, CorSB0())\npush!(ces, CorSB1())\n\n# Smyth-Broby-Gerber family of covariance estimators that modifies\n# the Gerber statistics by counting co-movements, scoring them,\n# and then it multiplies the scores by the counts.\npush!(ces, CorGerberSB0())\npush!(ces, CorGerberSB1());\nnothing #hide","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We then instantiate some PortCovCor estimators and push them to a vector for convenience.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"pces = PortCovCor[]\nfor ce ∈ ces\n    push!(pces, PortCovCor(; ce = ce))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We can now call asset_statistics! with all these different estimators.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"covs = Matrix[]\nfor pce ∈ pces\n    asset_statistics!(portfolio; cov_type = pce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx 1 to 12, see how different the covariances look. What happens if you change some parameter in the covariance estimators? Are there methods that give you the most obvious ones? Try to see if you can spot patterns in the relationships between certain assets (ape together strong).","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"We're showing the correlation matrix since it makes it easier to see the differences. We've set the colour limits to go from 0 to 1 clim = (0, 1), since all these assets appear to be postively correlated. Strictly speaking, only CorMutualInfo, CovDistance and CorLTD are guaranteed to be only positive. More information on all the methods is found in the docs.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:12\n   plot(cov2cor(covs[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/#2.3.4-Covariance-denoising","page":"Example 2: Asset statistics","title":"2.3.4 Covariance denoising","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Though the Gerber and its modified methods work well out of the box, other methods can benefit from extra processing. We'll use the default CovFull for this. First we will denoise it, for which we have three methods, DenoiseFixed, DenoiseSpectral, DenoiseShrink, which use fixed, spectral and shrink denoising methods described in [1, Chapter 2]. Each denoise method contains various tuning parameters. We will only explore the effects of detone and mkt_comp and leave the rest as defaults.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_denoise = PortCovCor[]\npush!(ces_denoise, PortCovCor(;))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseFixed()))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseSpectral()))\npush!(ces_denoise, PortCovCor(; denoise = DenoiseShrink()))\ncovs_denoise = Matrix[]\nfor ce ∈ ces_denoise\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_denoise, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 4 to see how the matrix changes.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:4\n   plot(cov2cor(covs_denoise[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The market prices are not independent of each other, they are subject to market forces that affect all products. Hence why most assets have positive covariances with other assets. These market forces can wash out the true relationships between assets. To do this, we can detone the denoised matrix by removing the largest M eigenvalues. Typically, only the one largest is removed but we give the option for removing more. This operation however, can make the matrix singular. Which means it can't be used for mean variance optimisation, but can be more useful for clustering than a standard covariance. However, PortCovCor also contains an option for fixing non-positive definite correlation matrices, which may be able to make the detoned matrix non-singular. We will pass the argument posdef = NoPosdef() to ensure the matrices aren't fixed.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Although detoned matrices may be singular, and therefore unsuitable for traditional optimisation, they can be very useful in hierarchical optimisations since they remove market forces and thus only the true relationships between assets remain.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_detone = PortCovCor[]\npush!(ces_detone, PortCovCor(;))\n\n# `mkt_comp` defaults to 1 when `detone == true`, the value of `mkt_comp`\n# defines how many of the largest eigenvalues are removed from the denoised matrix.\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseFixed(; detone = true, mkt_comp = 1)))\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseSpectral(; detone = true, mkt_comp = 1)))\npush!(ces_detone,\n      PortCovCor(; posdef = NoPosdef(),\n                 denoise = DenoiseShrink(; detone = true, mkt_comp = 1)))\ncovs_detone = Matrix[]\nfor ce ∈ ces_detone\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_detone, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 4 to see how the matrix changes. Try commenting out posdef = NoPosdef() from the cell above and see how it changes the output of this cell.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:4\n   plot(cov2cor(covs_detone[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\n   println(\"idx = $idx, isposdef = $(isposdef(covs_detone[idx]))\")\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Denoising and detoning can be applied to any PortfolioOptimiser.PortfolioOptimiserCovCor method, but others already have contingencies for capturing true signals. Denoising has to be applied with care, otherwise you risk washing out true effects. Denoising and detoning can be quite powerful for clustering assets, since it can remove market noise as well as systemic market effects.","category":"page"},{"location":"examples/2_asset_statistics/#2.3.5-LoGo-covariance","page":"Example 2: Asset statistics","title":"2.3.5 LoGo covariance","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The LoGo covariance uses graph theory to sparsify the inverse covariance matrix according to graph cliques and separators. This ensures only the strongest components of the realtionships are reflected in the covariance matrix. Although the inverse covariance is sparsified, the actual covariance is not, therefore it still encodes relationships between all assets.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The structure LoGo contains a distance and a similarity parameter, details can be found in its documentation. We will use the defaults, feel free to change them or create your by subtyping the relevant abstract types and defining the relevant methods.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"ces_logo = PortCovCor[]\npush!(ces_logo, PortCovCor(;))\npush!(ces_logo, PortCovCor(; logo = LoGo(;)))\n\ncovs_logo = Matrix[]\nfor ce ∈ ces_logo\n    asset_statistics!(portfolio; cov_type = ce, set_mu = false, set_kurt = false,\n                      set_skurt = false, set_skew = false, set_sskew = false)\n    push!(covs_logo, copy(portfolio.cov))\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"Try changing idx from 1 to 2 to see how the matrix changes.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"for idx ∈ 1:2\n   plot(cov2cor(covs_logo[idx]); st = :heatmap, clim = (0, 1),\n                yticks = (1:N, portfolio.assets), xticks = (1:N, portfolio.assets),\n                xrotation = 90, colorbar = true, xlim = (0.5, N + 0.5),\n                ylim = (0.5, N + 0.5), color = cgrad(:Spectral), yflip = true,\n                aspect_ratio = :equal)\nend","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"The LoGo covariance algorithm computes the sparsified inverse covariance, which is inverted to recover the LoGo covariance. The inversion is numerical, so if we invert the covariance, we will get some very small, non-zero values. We remove them to show the sparsified inverse covariance.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"J = covs_logo[2] \\ I\nJ[abs.(J) .<= 1e-10] .= zero(eltype(J))\nsparse(J)","category":"page"},{"location":"examples/2_asset_statistics/#Other-statistics","page":"Example 2: Asset statistics","title":"Other statistics","text":"","category":"section"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"There are other asset statistics that can be computed with asset_statistics!. However, they do not use anything that has not been covered in this tutorial. For further details refer to the docs of asset_statistics!.","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"","category":"page"},{"location":"examples/2_asset_statistics/","page":"Example 2: Asset statistics","title":"Example 2: Asset statistics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"M. M. López de Prado. Machine Learning for Asset Managers. Elements in Quantitative Finance (Cambridge University Press, 2020).\n\n\n\nM. L. De Prado. Building diversified portfolios that outperform out of sample. The Journal of Portfolio Management 42, 59–69 (2016).\n\n\n\nA. Hacine-Gharbi, P. Ravier, R. Harba and T. Mohamadi. Low bias histogram-based estimation of mutual information for feature selection. Pattern Recognition Letters 33, 1302–1308 (2012).\n\n\n\nW.-M. Song, T. Di Matteo and T. Aste. Hierarchical information clustering by means of topologically embedded graphs. PloS one 7, e31929 (2012).\n\n\n\nW.-M. Song, T. . Matteo and T. Aste. Nested hierarchies in planar graphs. Discrete Applied Mathematics 159, 2135–2146 (2011).\n\n\n\nW. Barfuss, G. P. Massara, T. Di Matteo and T. Aste. Parsimonious modeling with information filtering networks. Phys. Rev. E 94, 062306 (2016).\n\n\n\nG. P. Massara, T. Di Matteo and T. Aste. Network Filtering for Big Data: Triangulated Maximally Filtered Graph. Journal of Complex Networks 5, 161–178 (2016), arXiv:https://academic.oup.com/comnet/article-pdf/5/2/161/13794756/cnw015.pdf.\n\n\n\nT. Bodnar, O. Okhrin and N. Parolya. Optimal shrinkage estimator for high-dimensional mean vector. Journal of Multivariate Analysis 170, 63–79 (2019). Special Issue on Functional Data Analysis and Related Topics.\n\n\n\nP. Jorion. Bayes-Stein Estimation for Portfolio Analysis. The Journal of Financial and Quantitative Analysis 21, 279–292 (1986). Accessed on Mar 1, 2024.\n\n\n\nA. Meucci. Risk and asset allocation. Vol. 1 (Springer, 2005).\n\n\n\nY. Feng and D. P. Palomar. A Signal Processing Perspective on Financial Engineering. Foundations and Trends® in Signal Processing 9, 1–231 (2016).\n\n\n\nD. Cajas. Higher Order Moment Portfolio Optimization with L-Moments. Available at SSRN 4393155 (2023).\n\n\n\n","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Risk-measures","page":"Risk measures","title":"Risk measures","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#Public","page":"Risk measures","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Private","page":"Risk measures","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#Matrix-denoising","page":"Matrix denoising","title":"Matrix denoising","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#Public","page":"Matrix denoising","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseFixed","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseFixed","text":"@kwdef mutable struct DenoiseFixed{T1, T2, T3, T4} <: Denoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the fixed method in denoise! [1, Chapter 2]. This method performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to their average, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: remove the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to remove from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseShrink","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseShrink","text":"@kwdef mutable struct DenoiseShrink{T1, T2, T3, T4, T5} <: Denoise\n    alpha::Real = 0.0\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the shrink method in denoise! [1, Chapter 2]. This method shrinks the covariance to a target of unequal variance of the matrix reconstructed with the eigenvalues that are below the noise significance value. The degree of shrinkage is parametrised by alpha.\n\nbeginalign\nmathbfC = mathbfC_u + alpha mathbfC_l + (1 - alpha) mathrmDiag(mathbfC)\nmathbfC_u = mathbfE_u mathbflambda_u mathbfE_u^intercal\nmathbfC_l = mathbfE_l mathbflambda_l mathbfE_l^intercal\nendalign\n\nWhere:\n\nmathbfC is the denoised correlation matrix.\nmathbfC_u is the reconstructed correlation matrix out of the eigenvalues that are above the noise significance threshold, and their corresponding eigenvectors.\nmathbfC_l is the reconstructed correlation matrix out of the eigenvalues that are below the noise significance threshold, and their corresponding eigenvectors.\nmathbfE_u are the eigenvectors corresponding to the eigenvalues that are above the noise significance threshold.\nmathbflambda_u is the diagonal matrix of eigenvalues that are above the noise significance threshold.\nmathbfE_l are the eigenvectors corresponding to the eigenvalues that are below the noise significance threshold.\nmathbflambda_l is the diagonal matrix of eigenvalues that are below the noise significance threshold.\n\nParameters\n\nalpha: tuning parameter for how much the matrix should be shrunk, alpha ∈ [0, 1].\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseSpectral","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseSpectral","text":"@kwdef mutable struct DenoiseSpectral{T1, T2, T3, T4} <: Denoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the spectral method in denoise! [1, Chapter 2]. This method performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to zero, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.NoDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.NoDenoise","text":"struct NoDenoise <: Denoise end\n\nApply no denoising in denoise!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.denoise!-Tuple{PortfolioOptimiser.Denoise, PortfolioOptimiser.PosdefFix, AbstractMatrix, Real}","page":"Matrix denoising","title":"PortfolioOptimiser.denoise!","text":"denoise!(ce::Denoise, posdef::PosdefFix, X::AbstractMatrix, q::Real)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Private","page":"Matrix denoising","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.Denoise","page":"Matrix denoising","title":"PortfolioOptimiser.Denoise","text":"abstract type Denoise end\n\nAbstract type for subtyping denoising methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#Ordered-Weight-Arrays","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#Public","page":"Ordered Weight Arrays","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.CRRA","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.CRRA","text":"@kwdef mutable struct CRRA{T1 <: Real} <: OWAMethods\n    g::T1 = 0.5\nend\n\nNormalised Constant Relative Risk Aversion Coefficients.\n\nParameters\n\ng: Risk aversion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MaxEntropy","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MaxEntropy","text":"@kwdef mutable struct MaxEntropy{T1 <: Real} <: OWAMethods\n    max_phi::T1 = 0.5\nend\n\nMaximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSqDist","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSqDist","text":"@kwdef mutable struct MinSqDist{T1 <: Real} <: OWAMethods\n    max_phi::T1 = 0.5\nend\n\nMinimum Square Distance. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSumSq","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSumSq","text":"@kwdef mutable struct MinSumSq{T1 <: Real} <: OWAMethods\n    max_phi::T1 = 0.5\nend\n\nMinimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_cvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_cvar","text":"owa_cvar(T::Integer; alpha::Real = 0.05)\n\nCalculate the OWA weights corresponding to the Critical Value at Risk (CVaR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_gmd-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_gmd","text":"owa_gmd(T::Integer)\n\nComputes the Gini Mean Difference (GMD) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n[OWA]: Cajas, Dany, OWA Portfolio Optimization: A Disciplined Convex Programming Framework (December 18, 2021). Available at SSRN: https://ssrn.com/abstract=3988927 or http://dx.doi.org/10.2139/ssrn.3988927\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment","text":"owa_l_moment(T::Integer; k::Integer = 2)\n\nCalculates the OWA weights of the k'th linear moment (L-moment) of a returns series [12].\n\nInputs\n\nk: order of the L-moment.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment_crm-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment_crm","text":"owa_l_moment_crm(T::Integer; k::Integer = 2, method::Symbol = :SD, g::Real = 0.5,\n                 max_phi::Real = 0.5, solvers = Dict())\n\nCompute the OWA weights for the convex risk measure considering higher order L-moments [12].\n\nInputs\n\nk: order of the L-moment, k ≥ 2.\nmethod: method for computing the weights used to combine L-moments higher than 2, used in OWAMethods.\n:CRRA: Normalised Constant Relative Risk Aversion Coefficients.\n:E: Maximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n:SS: Minimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n:SD: Minimum Square Distance. Solver must support MOI.SecondOrderCone.\ng: the risk aversion coefficient.\nmax_phi: maximum weight constraint of the L-moments.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rcvar-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rcvar","text":"owa_rcvar(T::Integer; alpha::Real = 0.05, beta::Real = alpha)\n\nCompute the OWA weights for the CVaR Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rg","text":"owa_rg(T::Integer)\n\nCompute the OWA weights for the Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rtg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rtg","text":"owa_rtg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100,\n        beta_i::Real = alpha_i, beta::Real = alpha, b_sim::Integer = a_sim)\n\nCompute the OWA weights for the Tail Gini Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rwcvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rwcvar","text":"owa_rwcvar(T::Integer, alphas::AbstractVector{<:Real}, weights_a::AbstractVector{<:Real};\n           betas::AbstractVector{<:Real} = alphas,\n           weights_b::AbstractVector{<:Real} = weights_b)\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of the losses for each CVaR model, where N is the number of losses models, each .\nweights_a: N×1 vector of weights of the losses for each CVaR model, where N is the number of losses models.\nbetas: M×1 vector of significance levels of the gains for each CVaR model, where M is the number of gains models, each .\nweights_b: M×1 vector of weights of the gains for each CVaR model, where M is the number of gains models.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_tg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_tg","text":"owa_tg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100)\n\nCompute the OWA weights for the Tail Gini of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wcvar-Tuple{Integer, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wcvar","text":"owa_wcvar(T::Integer, alphas::AbstractVector{<:Real}, weights::AbstractVector{<:Real})\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of each CVaR model, where N is the number of models, each .\nweights: N×1 vector of weights of each CVaR model, where N is the number of models.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wr-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wr","text":"owa_wr(T::Integer)\n\nCompute the OWA weights for the Worst Realisation (WR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#Private","page":"Ordered Weight Arrays","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.OWAMethods","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.OWAMethods","text":"abstract type OWAMethods end\n\nAbstract type for subtyping Ordered Weight Array (OWA) methods for computing the weights used to combine L-moments higher than 2 [12] in owa_l_moment_crm.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser._crra_method-Tuple{AbstractMatrix{<:Real}, Integer, Real}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser._crra_method","text":"_crra_method(weights::AbstractMatrix{<:Real}, k::Integer, g::Real)\n\nInternal function for computing the Normalized Constant Relative Risk Aversion coefficients.\n\nInputs\n\nweights: T×(k-1) matrix where T is the number of observations and k the order of the L-moments to combine, the i'th column contains the weights for the (i+1)'th L-moment.\nk: the maximum order of the L-moments.\ng: the risk aversion coefficient.\n\nOutputs\n\nw: T×1 ordered weight vector of the combined L-moments.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser._optimise_JuMP_model-Tuple{Any, Any}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser._optimise_JuMP_model","text":"_optimise_JuMP_model(model, solvers)\n\nInternal function to optimise an OWA JuMP model.\n\nInputs\n\nmodel: JuMP model.\n\nOutputs\n\nterm_status: JuMP termination status.\nsolvers_tried: Dictionary that contains a dictionary of failed optimisations. Dict(key => Dict(...)), where key is the solver key used for the iteration of solver that failed.\nIf an MOI call fails on a model:\nDict(:jump_error => jump_error): JuMP error code.\nIf the optimiser fails to optimise the model satisfactorily:\nDict(:objective_val => JuMP.objective_value(model), :term_status => term_status, :params => haskey(val, :params) ? val[:params] : missing), where val is the value of the dictionary corresponding to key.\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Entropic-and-relativistic-moments","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/#Public","page":"Entropic and relativistic moments","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationGetZ.jl\"]","category":"page"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z-Tuple{Portfolio, Union{PortfolioOptimiser.RiskMeasure, AbstractVector}, Any}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z","text":"get_z\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z_from_model-Tuple{JuMP.Model, EVaR, Any}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z_from_model","text":"get_z_from_model\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Private","page":"Entropic and relativistic moments","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationGetZ.jl\"]","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"EditURL = \"../../../examples/4_hrp_portfolios.jl\"","category":"page"},{"location":"examples/4_hrp_portfolios/#Example-4:-Hierarchical-risk-parity","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This example focuses on the HRP optimisation type of HCPortfolio.","category":"page"},{"location":"examples/4_hrp_portfolios/#4.1-Downloading-the-data","page":"Example 4: Hierarchical risk parity","title":"4.1 Downloading the data","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/4_hrp_portfolios/#4.2-Instantiating-an-instance-of-[HCPortfolio](@ref).","page":"Example 4: Hierarchical risk parity","title":"4.2 Instantiating an instance of HCPortfolio.","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Since we're going to be performing HRP optimisations, we only need solvers for entropic and relativistic risk measures. Others don't make use of a solver, they can be computed from the asset statistics.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"portfolio = HCPortfolio(; prices = prices,\n                        # Continuous optimiser.\n                        solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                         :check_sol => (allow_local = true,\n                                                                        allow_almost = true),\n                                                         :params => Dict(\"verbose\" => false))),\n                        # MIP optimiser for the discrete allocation.\n                        alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                            :check_sol => (allow_local = true,\n                                                                           allow_almost = true),\n                                                            :params => Dict(\"log_to_console\" => false))));\nnothing #hide","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will first use the most basic statistics. We'll later see how we can change the characteristics by changing them.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"cov_type = PortCovCor()\ncor_type = PortCovCor()\ndist_type = DistCanonical()\nasset_statistics!(portfolio; cov_type = cov_type, cor_type = cor_type,\n                  dist_type = dist_type)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3-Basic-HRP-portfolio","page":"Example 4: Hierarchical risk parity","title":"4.3 Basic HRP portfolio","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/#4.3.1-Hierarchical-clustering","page":"Example 4: Hierarchical risk parity","title":"4.3.1 Hierarchical clustering","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"All [HCPortfolio]s use the assets' correlation structure to optimise the portfolios based on their correlation structure. PortfolioOptimiser comes with two clustering methods.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Hierarchical clustering using Clustering.jl.\nDirect Bubble Hierarchy Trees.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll use the default values for everything, see optimise! for details.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Standard deviation\nrm = SD()\n\n# Hierachical clustering with Ward's linkage.\nhclust_alg = HAC(; linkage = :ward)\n# Method for determining the number of clusters is the two-difference gap statistic [`TwoDiff`](@ref).\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\n# Optimise.\nw1 = optimise!(portfolio; rm = rm)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"HRP uses the clustering structure, but it splits the dendrogram naïvely down the middle. This means it can't take full advantage of the clustering structure, and may split closely related assets into separate clusters, which is not ideal. However, the next example will go over the HERC optimisation type, which does consider the clustering structure.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Regardless, we'll plot the clusters to see the structure of the relationships between assets. We don't want to clusterise again so we'll set cluster = false, which is also a flag in optimise!, which saves on processing when the assets have been previously clusterised, the default is cluster = true.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"plot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Before moving on to DBHT clustering, we'll use a different linkage function. Generally speaking, Ward's clustering is the most robust when dealing with noisy data, which is why it's the default method. Lets see what complete clustering looks like. And now we'll use a different method for determining the clusters, StdSilhouette.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Hierarchical clustering with complete linkage.\nhclust_alg = HAC(; linkage = :complete)\n# Method for determining the number of clusters is the Standard silhouette score [`StdSilhouette`](@ref).\nhclust_opt = HCOpt(; k_method = StdSilhouette())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\n# Optimise.\nw2 = optimise!(portfolio; rm = rm)\npretty_table(w2; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3.2-DBHT-clustering","page":"Example 4: Hierarchical risk parity","title":"4.3.2 DBHT clustering","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Direct Bubble Hierarchy Tree (DBHT) clustering, is a type of clustering based on graph-theoretic filtering. The same idea is used to compute the LoGo covariance, which we explored in Example 2.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"DBHT clustering also uses a similarity matrix, the original MATLAB code proposes two methods. PortfolioOptimiser implements them both using DBHTMaxDist and DBHTExp. Though users can define their own creating a concrete subtype of PortfolioOptimiser.DBHTSimilarity and implementing dbht_similarity for it. There are also two methods for defining roots of graphs, either of which can be used UniqueDBHT and EqualDBHT.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"For now we will use teh defaults.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Again we will use default parameters first. We're not setting cluster = flase in this optimisation since we want the assets to be clustered using this new algorithm.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# DBHT clustering, using the distance from the maximum value of the dissimilarity matrix [`DBHTMaxDist`](@ref).\nhclust_alg = DBHT(; similarity = DBHTMaxDist())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\nw3 = optimise!(portfolio; rm = rm)\npretty_table(w3; formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will again plot the clusters. Note how different the clusters are.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"plot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll see the effect changing the similarity matrix calculation to exponential decay of the disimilarity score.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTExp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw4 = optimise!(portfolio; rm = rm)\npretty_table(w4; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll define our own method for the similarity matrix. We'll use one of the potential definitions given in DBHTs.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As a general rule, PortfolioOptimiser doesn't export abstract types, so they have to be explicitly imported.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll define our similarity matrix using only the correlation, denoted here by S, the distance matrix is denoted by D dbht_similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"struct DBHTClamp <: PortfolioOptimiser.DBHTSimilarity end\nfunction PortfolioOptimiser.dbht_similarity(::DBHTClamp, S, D)\n    return S .+ abs(minimum(S))\nend\nhclust_alg = DBHT(; similarity = DBHTClamp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw5 = optimise!(portfolio; rm = rm)\npretty_table(w5; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We'll make another method that uses both the correlation and distance matrices to create the DBHT similarity matrix. We'll also make it tuneable.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"@kwdef mutable struct DBHTTuneableLinComboMaxDistExp{T1 <: Real, T2 <: Real, T3 <: Real} <:\n                      PortfolioOptimiser.DBHTSimilarity\n    maxdist_c::T1 = 1.0\n    expdeca_c::T2 = 1.0\n    argcoef::T3 = 0.5\nend\nfunction PortfolioOptimiser.dbht_similarity(DBHT::DBHTTuneableLinComboMaxDistExp, S, D)\n    max_dist = DBHT.maxdist_c * PortfolioOptimiser.dbht_similarity(DBHTMaxDist(), S, D)\n    exp_dec = exp.(-DBHT.argcoef * D)\n    return max_dist + exp_dec\nend\nhclust_alg = DBHT(;\n                  similarity = DBHTTuneableLinComboMaxDistExp(; maxdist_c = 0.3,\n                                                              expdeca_c = 1, argcoef = 0.4))\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw6 = optimise!(portfolio; rm = rm)\npretty_table(w6; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/#4.3.3-Using-detoned-matrices.","page":"Example 4: Hierarchical risk parity","title":"4.3.3 Using detoned matrices.","text":"","category":"section"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As mentioned in Example 2, detoned matrices can be of great value in hierarchical optimisations. We'll see their effect here.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"We will repeat the exact same steps as above, but without redefining the structures.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"cov_type = PortCovCor(; denoise = DenoiseFixed(; detone = true))\ncor_type = PortCovCor(; denoise = DenoiseFixed(; detone = true))\ndist_type = DistCanonical()\nasset_statistics!(portfolio; cov_type = cov_type, cor_type = cor_type,\n                  dist_type = dist_type)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"First we try Ward's linkage.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = HAC(; linkage = :ward)\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw7 = optimise!(portfolio; rm = rm)\npretty_table(w7; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Then complete, and we'll see categorise the number of clusters according to the standard silhouette score.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = HAC(; linkage = :complete)\nhclust_opt = HCOpt(; k_method = StdSilhouette())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw8 = optimise!(portfolio; rm = rm)\npretty_table(w8; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll use DBHT clustering with max distance similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTMaxDist())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw9 = optimise!(portfolio; rm = rm)\npretty_table(w9; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll use the exponential decay similarity.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTExp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw10 = optimise!(portfolio; rm = rm)\npretty_table(w10; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"Now we'll try the clamp method.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(; similarity = DBHTClamp())\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw11 = optimise!(portfolio; rm = rm)\npretty_table(w11; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"And finally the tuneable linear combination of max distance and exponential decay.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"hclust_alg = DBHT(;\n                  similarity = DBHTTuneableLinComboMaxDistExp(; maxdist_c = 0.3,\n                                                              expdeca_c = 1, argcoef = 0.4))\nhclust_opt = HCOpt(; k_method = TwoDiff())\ncluster_assets!(portfolio; hclust_alg = hclust_alg, hclust_opt = hclust_opt)\n\nw12 = optimise!(portfolio; rm = rm)\npretty_table(w12; formatters = fmt1)\nplot_clusters(portfolio; cluster = false)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"As you can see, there are drastic differences in the correlation matrices. We'll display the weights of the sample  correlations and covariances (:weights) and their detoned counterparts (:weights_d) side by side.","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"# Ward's linkage\npretty_table(DataFrames.rename!(hcat(w1, w7.weights), :x1 => :weights_d); formatters = fmt1)\n# complete linkage\npretty_table(DataFrames.rename!(hcat(w2, w8.weights), :x1 => :weights_d); formatters = fmt1)\n# DBHT max dist\npretty_table(DataFrames.rename!(hcat(w3, w9.weights), :x1 => :weights_d); formatters = fmt1)\n# DBHT exp decay\npretty_table(DataFrames.rename!(hcat(w4, w10.weights), :x1 => :weights_d);\n             formatters = fmt1)\n# DBHT clamp (custom method)\npretty_table(DataFrames.rename!(hcat(w5, w11.weights), :x1 => :weights_d);\n             formatters = fmt1)\n# DBHT tuneable linear combination max dist exp decay\npretty_table(DataFrames.rename!(hcat(w6, w12.weights), :x1 => :weights_d);\n             formatters = fmt1)","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"","category":"page"},{"location":"examples/4_hrp_portfolios/","page":"Example 4: Hierarchical risk parity","title":"Example 4: Hierarchical risk parity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Constraints/WeightConstraints/#Weight-constraints","page":"Weight constraints","title":"Weight constraints","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#Public","page":"Weight constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.asset_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.asset_constraints","text":"asset_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the linear constraint matrix A and vector B:\n\nmathbfA bmw geq bmB.\n\nInputs\n\nconstraints: Nc×10 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nSubset: whole class.\nAll Assets: all assets.\nAll Subsets: all asset classes.\nEach Asset in Subset: specific assets in a class.\nSet: (String) if Type is Subset, All Subsets or Each Asset in Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nRelative_Type: (String) specifies to what the constraint is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative constraint.\nFactor: (<:Real) the factor of the relative constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nA: Nc×Na matrix of constraints where  and .\nB: Nc×1 vector of constraints where .\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\", \"FCN\",\n                                   \"TKO\", \"ZOO\", \"ZVO\", \"ZX\", \"ZZA\", \"ZZB\", \"ZZC\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\", \"Equity\", \"Equity\",\n                                     \"Equity\", \"Fixed Income\", \"Fixed Income\", \"Equity\",\n                                     \"Fixed Income\", \"Equity\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\", \"Financial\",\n                                     \"Entertainment\", \"Treasury\", \"Financial\", \"Financial\",\n                                     \"Entertainment\", \"Technology\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true, true, true, true,\n                                      true, true, true, true, true, true],\n                        \"Type\" => [\"Subset\", \"All Subsets\", \"Asset\", \"Asset\", \"Subset\",\n                                   \"All Assets\", \"Each Asset in Subset\", \"Asset\",\n                                   \"All Assets\", \"All Assets\", \"Subset\", \"All Subsets\",\n                                   \"All Subsets\", \"Each Asset in Subset\",\n                                   \"Each Asset in Subset\"],\n                        \"Set\" => [\"Class 1\", \"Class 1\", \"\", \"\", \"Class 2\", \"\", \"Class 1\",\n                                  \"Class 1\", \"Class 2\", \"\", \"Class 1\", \"Class 2\", \"Class 2\",\n                                  \"Class 2\", \"Class 1\"],\n                        \"Position\" => [\"Equity\", \"Fixed Income\", \"BAC\", \"WFC\", \"Financial\",\n                                       \"\", \"Equity\", \"FCN\", \"TKO\", \"ZOO\", \"Fixed Income\",\n                                       \"Treasury\", \"Entertainment\", \"Treasury\", \"Equity\"],\n                        \"Sign\" => [\"<=\", \"<=\", \"<=\", \"<=\", \">=\", \">=\", \">=\", \"<=\", \">=\",\n                                   \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\"],\n                        \"Weight\" => [0.6, 0.5, 0.1, \"\", \"\", 0.02, \"\", \"\", \"\", \"\", \"\", \"\",\n                                     \"\", 0.27, \"\"],\n                        \"Relative_Type\" => [\"\", \"\", \"\", \"Asset\", \"Subset\", \"\", \"Asset\",\n                                            \"Subset\", \"Asset\", \"Subset\", \"Asset\", \"Asset\",\n                                            \"Subset\", \"\", \"Subset\"],\n                        \"Relative_Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"\", \"\", \"Class 1\", \"\",\n                                           \"Class 2\", \"\", \"Class 2\", \"Class 2\", \"\",\n                                           \"Class 2\"],\n                        \"Relative_Position\" => [\"\", \"\", \"\", \"FB\", \"Fixed Income\", \"\", \"TLT\",\n                                                \"Equity\", \"NTFX\", \"Financial\", \"WFC\", \"ZOO\",\n                                                \"Entertainment\", \"\", \"Entertainment\"],\n                        \"Factor\" => [\"\", \"\", \"\", 1.2, 0.5, \"\", 0.4, 0.7, 0.21, 0.11, 0.13,\n                                     -0.17, 0.23, \"\", -0.31])\nA, B = asset_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.factor_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.factor_constraints","text":"factor_constraints(constraints::DataFrame, loadings::DataFrame)\n\nCreate the factor constraints matrix C and vector D:\n\nmathbfC bmw geq bmD.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nFactor: (String) name of the constraint's factor.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the constraint is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nC: Nc×Nf matrix of constraints where  and .\nD: Nc×1 vector of constraints where .\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true],\n                        \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\", \"const\"],\n                        \"Sign\" => [\"<=\", \"<=\", \">=\", \">=\"],\n                        \"Value\" => [0.9, -1.2, 0.3, -0.1],\n                        \"Relative_Factor\" => [\"USMV\", \"\", \"\", \"SIZE\"])\nC, D = factor_constraints(constraints, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.hrp_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.hrp_constraints","text":"hrp_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the upper and lower bounds constraints for hierarchical risk parity portfolios.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nAll Assets: all assets.\nEach Asset in Subset: specific assets in a class.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nw_min: Na×1 vector of the lower bounds for asset weights.\nw_max: Na×1 vector of the upper bounds for asset weights.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true],\n                        \"Type\" => [\"Asset\", \"Asset\", \"All Assets\", \"All Assets\",\n                                   \"Each Asset in Subset\", \"Each Asset in Subset\"],\n                        \"Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"Class 2\"],\n                        \"Position\" => [\"BAC\", \"FB\", \"\", \"\", \"Fixed Income\", \"Financial\"],\n                        \"Sign\" => [\">=\", \"<=\", \"<=\", \">=\", \"<=\", \"<=\"],\n                        \"Weight\" => [0.02, 0.085, 0.09, 0.01, 0.07, 0.06])\nw_min, w_max = hrp_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.rp_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.rp_constraints","text":"rp_constraints(asset_sets::DataFrame; type::Symbol = :Asset,\n               class_col::Union{String, Symbol, Nothing} = nothing)\n\nConstructs risk contribution constraint vector for the risk parity optimisation (:RP and :RRP types of PortTypes).\n\nInputs\n\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets. They are only used if type == :Subset.\nclass_col: index of set of classes from asset_sets to use in when type == :Subset.\n\nOutputs\n\nrw: risk contribution constraint vector.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\n\nrw_a = rp_constraints(asset_sets, :Asset)\nrw_c = rp_constraints(asset_sets, :Subset, \"Class 2\")\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.turnover_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.turnover_constraints","text":"turnover_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\n\"Asset\"\n\"All Assets\"\n\"Each Asset in Subset\"\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#Private","page":"Weight constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Finalisation-functions","page":"Finalisation functions","title":"Finalisation functions","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Public","page":"Finalisation functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Private","page":"Finalisation functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"EditURL = \"../../../examples/3_shorting_portfolios.jl\"","category":"page"},{"location":"examples/3_shorting_portfolios/#Example-3:-Shorting-and-leveraged-portfolios","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This example focuses on using the shorting constraints available to Trad and WC optimisations of Portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/#3.1-Downloading-the-data","page":"Example 3: Shorting and leveraged portfolios","title":"3.1 Downloading the data","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/#3.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 3: Shorting and leveraged portfolios","title":"3.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"mu_type = MuSimple()\ncov_type = PortCovCor()\nasset_statistics!(portfolio; mu_type = mu_type, cov_type = cov_type)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Risk free rate.\nrf = 3.5 / 100 / 252\n# Risk aversion.\nl = 2.0\n# Objective function.\nobj = MinRisk()\n# Risk measure.\nrm = SD()\n# Money available to us.\ninvestment = 6750;\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.1-Long-only-portfolio","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.1 Long-only portfolio","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"First we will optimise the portfolio without shorting and plot the weights and the efficient frontier.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = false\nportfolio.optimal[:ns] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :ns)\nportfolio.frontier[:ns] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :ns)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"We'll now allocate the portfolio according to our means. We'll use both allocation methods:","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Linear Mixed-integer Programming (LP): (default) can only allocate discrete integer shares and requires an MIP solver.\nGreedy algorithm, can round down to the nearest integer + N*rounding, but is not guaranteed to be globally optimal. The rounding also rounds down, as it ensures the investment will not be exceeded.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.optimal[:nsal] = allocate!(portfolio; type = :ns, method = LP(),\n                                     investment = investment)\nportfolio.optimal[:nsag] = allocate!(portfolio; type = :ns,\n                                     method = Greedy(; rounding = 0.3),\n                                     investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available. We'll also compare the would-be optimal portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:ns].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment = $(sum(investment * portfolio.optimal[:ns].weights[long_optimal_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:ns].weights[long_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:nsal].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:nsal].shares[long_LP_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:nsal].weights[long_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:nsag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:nsag].shares[long_Greedy_idx]))\")\nprintln(\"Sum of weights = $(sum(portfolio.optimal[:nsag].weights[long_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"As you can see, the greedy algorithm doesn't make optimal use of the available investment.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets now see what the long-only portfolio looks like, in both optimal and allocated form.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights without shorting.\n                       ns_w = portfolio.optimal[:ns].weights,\n                       # Discretely allocated optimal weights without shorting.\n                       # Linear programming.\n                       nsal_w = portfolio.optimal[:nsal].weights,\n                       # Discretely allocated shares without shorting.\n                       # Linear programming.\n                       nsal_s = portfolio.optimal[:nsal].shares,\n                       # Discretely allocated optimal weights without shorting.\n                       # Greedy algorithm.\n                       nsag_w = portfolio.optimal[:nsag].weights,\n                       # Discretely allocated shares without shorting.\n                       # Greedy algorithm.\n                       nsag_s = portfolio.optimal[:nsag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.2-Shorting","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.2 Shorting","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Enabling shorting is very simple. This will allow negative weights, which correspond to shorting portfolios. It is generally a good idea to start with little to no leverage.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = true;\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"How short- or long-heavy we want to be is mediated by the short_u, long_u, short_budget and budget properties. They set the upper bound for the absolute value of the sum of the short and long weights respectively.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"budget: the sum of all the weights will be equal to this value.\nshort_budget: upper bound for the absolute value of the sum of the short weights.\nlong_u: upper bound of each of the long weights.\nshort_u: upper bound of the absolute value of each of the short weights.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"These values multiply the cash at our disposal when we allocate the portfolio. So when allocate! is called, the long investment will be investment * long_u. And if shorting is enabled, the short investment (the amount shorted) will be short_u * investment.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets short the market whithout reinvesting the earnings, meaning we'll have a cash reserve in our balance that is equal to the short sale value. You can change this by increasing long_u, if you set it to 1 + short_u it means the profits from short selling will be reinvested into the portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"We will use the default values.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# The absolute value of the sum of the short weights is equal to `0.2`.\nportfolio.short_budget = 0.2\n# The portfolio weights will add up to 0.8, meaning the portfolio will be underleveraged.\nportfolio.budget = 0.8;\n# Each short position can have a maximum value of -0.2.\nportfolio.short_u = 0.2\n# Each long position can have a maximum value of 1.\nportfolio.long_u = 1.0","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"The portfolio budget gives us the leverage characteristics of the portfolio. This is a property that is automatically computed and cannot be cahnged. There are verious scenarios that budget describes.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"budget < 0: the short sale value of the portfolio is higher than the long-sale value.\nbudget == 0: the short and long values of the portfolio are equal. The market neutral portfolio is found by maximising the return given these conditions.\n0 < budget < 1: the portfolio is under-leveraged, meaning there is a cash reserve that is not being used.\nbudget == 1: the portfolio has no leverage. If shorting is enabled, this means the profits from shorting are being invested in long positions.\nbudget > 1: the portfolio is leveraged, meaning it's using more money than is available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here the portfolio is under-leveraged.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets optimise the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.optimal[:s] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :s)\nportfolio.frontier[:s] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :s)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets allocate the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Allocating the short-long portfolio.\nportfolio.optimal[:sal] = allocate!(portfolio; type = :s, investment = investment)\nportfolio.optimal[:sag] = allocate!(portfolio; type = :s, method = Greedy(; rounding = 0.3),\n                                    investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:s].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment\")\nprintln(\"long = $(sum(investment * portfolio.optimal[:s].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(investment * portfolio.optimal[:s].weights[short_optimal_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:s].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:s].weights[short_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:sal].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:sal].shares[long_LP_idx]))\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sal].shares[short_LP_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sal].weights[long_LP_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sal].weights[short_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:sag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:sag].shares[long_Greedy_idx]))\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:sag].shares[short_Greedy_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sag].weights[long_Greedy_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sag].weights[short_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here's what the short-long portfolio looks like. See how this differs from the long-only portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights with shorting.\n                       s_w = portfolio.optimal[:s].weights,\n                       # Discretely allocated optimal weights with shorting.\n                       # Linear programming.\n                       sal_w = portfolio.optimal[:sal].weights,\n                       # Discretely allocated shares with shorting.\n                       # Linear programming.\n                       sal_s = portfolio.optimal[:sal].shares,\n                       # Discretely allocated optimal weights with shorting.\n                       # Greedy algorithm.\n                       sag_w = portfolio.optimal[:sag].weights,\n                       # Discretely allocated shares with shorting.\n                       # Greedy algorithm.\n                       sag_s = portfolio.optimal[:sag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/#3.3.3-Shorting-with-reinvestment","page":"Example 3: Shorting and leveraged portfolios","title":"3.3.3 Shorting with reinvestment","text":"","category":"section"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"In this section we'll reinvest the money made from short selling, this can be acomplished by setting the value of long_u = 1 + short_u.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"portfolio.short = true\n\n# The absolute value of the sum of the short weights is equal to `0.2`.\nportfolio.short_budget = 0.2\n# Reinvest the earnings from short selling.\nportfolio.budget = 1\n\nportfolio.optimal[:sr] = optimise!(portfolio; rm = rm, obj = obj)\nplot_bar(portfolio; type = :sr)\nportfolio.frontier[:sr] = efficient_frontier!(portfolio; rm = rm, points = 30)\nplot_frontier(portfolio; type = :sr)","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets allocate the short-long portfolio.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"# Allocating the short-long portfolio.\nportfolio.optimal[:sral] = allocate!(portfolio; type = :sr, investment = investment)\nportfolio.optimal[:srag] = allocate!(portfolio; type = :sr,\n                                     method = Greedy(; rounding = 0.3),\n                                     investment = investment);\nnothing #hide","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Lets verify that the allocations used the money we have available.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Optimal portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_optimal_idx = portfolio.optimal[:sr].weights .>= 0\nshort_optimal_idx = .!long_optimal_idx\nprintln(\"Optimal investment\")\nprintln(\"long = $(sum(investment * portfolio.optimal[:sr].weights[long_optimal_idx]))\")\nprintln(\"long = $(investment + abs(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))) = $(investment) + $(abs(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))) = investment + short_profit\")\nprintln(\"short = $(sum(investment * portfolio.optimal[:sr].weights[short_optimal_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sr].weights[long_optimal_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sr].weights[short_optimal_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"LP allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_LP_idx = portfolio.optimal[:sral].weights .>= 0\nshort_LP_idx = .!long_LP_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_LP_idx], portfolio.optimal[:sral].shares[long_LP_idx]))\")\nprintln(\"long ≈ $(investment + abs(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))) ≈ $(investment) + $(abs(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))) ≈ investment + short_profit\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_LP_idx], portfolio.optimal[:sral].shares[short_LP_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:sral].weights[long_LP_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:sral].weights[short_LP_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Greedy allocated portfolio","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"long_Greedy_idx = portfolio.optimal[:srag].weights .>= 0\nshort_Greedy_idx = .!long_Greedy_idx\nprintln(\"Allocation investment\")\nprintln(\"long = $(dot(portfolio.latest_prices[long_Greedy_idx], portfolio.optimal[:srag].shares[long_Greedy_idx]))\")\nprintln(\"long ≈ $(investment + abs(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))) ≈ $(investment) + $(abs(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))) ≈ investment + short_profit\")\nprintln(\"short = $(dot(portfolio.latest_prices[short_Greedy_idx], portfolio.optimal[:srag].shares[short_Greedy_idx]))\")\nprintln(\"Sum of weights\")\nprintln(\"long = $(sum(portfolio.optimal[:srag].weights[long_Greedy_idx]))\")\nprintln(\"short = $(sum(portfolio.optimal[:srag].weights[short_Greedy_idx]))\")","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"Here's what the short-long portfolio looks like when we reinvest profits from shorting.","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"pretty_table(DataFrame(; tickers = portfolio.assets,\n                       # Optimal weights with shorting.\n                       s_w = portfolio.optimal[:sr].weights,\n                       # Discretely allocated optimal weights with shorting.\n                       # Linear programming.\n                       sal_w = portfolio.optimal[:sral].weights,\n                       # Discretely allocated shares with shorting.\n                       # Linear programming.\n                       sal_s = portfolio.optimal[:sral].shares,\n                       # Discretely allocated optimal weights with shorting.\n                       # Greedy algorithm.\n                       sag_w = portfolio.optimal[:srag].weights,\n                       # Discretely allocated shares with shorting.\n                       # Greedy algorithm.\n                       sag_s = portfolio.optimal[:srag].shares))","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"","category":"page"},{"location":"examples/3_shorting_portfolios/","page":"Example 3: Shorting and leveraged portfolios","title":"Example 3: Shorting and leveraged portfolios","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"EditURL = \"../../../examples/5_risk_parity_portfolios.jl\"","category":"page"},{"location":"examples/5_risk_parity_portfolios/#Example-5:-Risk-parity","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This example focuses on the RP optimisation type of Portfolio.","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.1-Downloading-the-data","page":"Example 5: Risk parity","title":"5.1 Downloading the data","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 5: Risk parity","title":"5.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/5_risk_parity_portfolios/#5.3-Optimising-the-portfolio","page":"Example 5: Risk parity","title":"5.3 Optimising the portfolio","text":"","category":"section"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"The RP uses a risk budget vector for defining the risk contribution of each asset. The vector defaults to equal risk contribution for all assets.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Risk parity portfolios don't use a user-provided objective function. They minimise the risk subject to a constraint that minimises the deviation","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"rm = SD()\ntype = RP()\nw1 = optimise!(portfolio; type = type, rm = rm)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We can check that the risk budget and risk contribution match.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# Risk budget.\nrb = portfolio.risk_budget\n# Compute the risk contribution, for the [`SD`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = rm)\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\n\npretty_table(hcat(w1, DataFrame(; budget = rb, contribution = rc)); formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"As you can see, the weights of each asset in the portfolio are such that the asset contributes 4% of the risk of the portfolio. This is because we used the default value for the risk budget, which defaults to equal risk contribution per asset, which is equal to 1/N, where N is the number of assets.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We can also plot the risk contribution in asbolute and relative terms.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"plot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets change the risk budget to something a little bit more interesting. The risk budget can be provided from to the Portfolio constructor, or after instatiation. Either way, the risk budget will be normalised to add up to 1. If using the latter method, the element type of the vector provided must match that of risk_budget because the normalisation is done in-place to avoid unecessary allocations.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"x = range(; start = 0, stop = 2pi, length = length(w1.weights))\nportfolio.risk_budget = sin.(x) .^ 2;\nnothing #hide","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets optimise using this risk budget to see what happens.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"w1 = optimise!(portfolio; type = type, rm = rm)\nrb = portfolio.risk_budget\n# Compute the risk contribution, for the [`SD`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = rm)\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\npretty_table(hcat(w1, DataFrame(; budget = rb, contribution = rc)); formatters = fmt1)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"Lets plot the results.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"plot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = rm, type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"We've used the SD risk function for computing the risk parity portfolio, as well as for computing and plotting the risk contribution, but there's nothing stopping us from computing the risk contribution and/or plotting the risk contribution for risk measures other than the one that was optimised.","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"# Compute the risk contribution, for the [`CDaR`](@ref) risk measure.\nrc = risk_contribution(portfolio; type = :RP, rm = CDaR())\n# Normalise risk contribution so it adds up to 1 a.k.a. 100%.\nrc ./= sum(rc)\npretty_table(hcat(w1, DataFrame(; budget_SD = rb, contribution_CDaR = rc));\n             formatters = fmt1)\n\nplot_risk_contribution(portfolio; rm = CDaR(), type = :RP, percentage = false)\nplot_risk_contribution(portfolio; rm = CDaR(), type = :RP, percentage = true)","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"","category":"page"},{"location":"examples/5_risk_parity_portfolios/","page":"Example 5: Risk parity","title":"Example 5: Risk parity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Optimisation/OptimisationReturns/#Returns","page":"Returns","title":"Returns","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/#Public","page":"Returns","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"Optimisation/OptimisationReturns/#Private","page":"Returns","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#Covariance,-correlation,-cokurtosis-and-coskewness","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#Public","page":"Covariance, correlation, cokurtosis and coskewness","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber0","text":"@kwdef mutable struct CorGerber0{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber1","text":"@kwdef mutable struct CorGerber1{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber2","text":"@kwdef mutable struct CorGerber2{T1 <: Real} <: CorGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nGerber type 2 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Gerber type 2 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB0","text":"@kwdef mutable struct CorGerberSB0{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification with vote counting of the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB1","text":"@kwdef mutable struct CorGerberSB1{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification with vote counting of the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorKendall","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorKendall","text":"@kwdef mutable struct CorKendall <: CorRank\n    absolute::Bool = false\nend\n\nKendall type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corkendall(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorLTD","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorLTD","text":"mutable struct CorLTD <: PortfolioOptimiserCovCor\n    alpha::Real\n    ve::StatsBase.CovarianceEstimator\n    w::Union{<:AbstractWeights, Nothing}\nend\n\nLower tail dependence correlation and covariance matrix estimator.\n\nParameters\n\nalpha: significance level of the lower tail dependence, alpha ∈ (0, 1).\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorMutualInfo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorMutualInfo","text":"@kwdef mutable struct CorMutualInfo <: PortfolioOptimiserCovCor\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nMutual information correlation matrix estimator.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB0","text":"@kwdef mutable struct CorSB0{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification of the Gerber type 0 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB1","text":"@kwdef mutable struct CorSB1{T1, T2, T3, T4, T5} <: CorSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::PosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: method for fixing the Smyth-Broby modification of the Gerber type 1 correaltion matrix PosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSpearman","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSpearman","text":"@kwdef mutable struct CorSpearman <: CorRank\n    absolute::Bool = false\nend\n\nSpearman type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corspearman(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovDistance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovDistance","text":"mutable struct CovDistance <: PortfolioOptimiserCovCor\n    distance::Distances.Metric\n    dist_args::Tuple\n    dist_kwargs::NamedTuple\n    mean_w1::Union{<:AbstractWeights, Nothing}\n    mean_w2::Union{<:AbstractWeights, Nothing}\n    mean_w3::Union{<:AbstractWeights, Nothing}\nend\n\nDistance covariance and correlation matrix estimator.\n\nParameters\n\ndistance: distance metric from Distances.jl.\ndist_args: args for the Distances.pairwise function of Distances.jl.\ndist_kwargs: kwargs for the Distances.pairwise function of Distances.jl.\nmean_w1: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its rows (dims = 1).\nmean_w2: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its columns (dims = 2).\nmean_w3: optional T×1 vector of weights for computing the mean of the entirety of the pairwise distance matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovFull","text":"@kwdef mutable struct CovFull <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nFull Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSemi","text":"@kwdef mutable struct CovSemi <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSemi Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtFull","text":"@kwdef mutable struct KurtFull <: KurtEstimator\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nFull cokurtosis estimator.\n\nParameters\n\nposdef: method for fixing non a positive definite cokurtosis matrix PosdefFix.\ndenoise: method for denoising the cokurtosis matrix Denoise.\nlogo: method for computing the LoGo cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtSemi","text":"@kwdef mutable struct KurtSemi <: KurtEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nposdef: method for fixing non a positive definite semi cokurtosis matrix PosdefFix.\ndenoise: method for denoising the semi cokurtosis matrix Denoise.\nlogo: method for computing the LoGo semi cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.LoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.LoGo","text":"@kwdef mutable struct LoGo <: AbstractLoGo\n    distance::DistMethod = DistMLP()\n    similarity::DBHTSimilarity = DBHTMaxDist()\nend\n\nCompute the LoGo covariance and correlation matrix estimator.\n\nParameters\n\ndistance: method for computing the distance (disimilarity) matrix from the correlation matrix if the distance matrix is not provided to logo!.\nsimilarity: method for computing the similarity matrix from the correlation and distance matrices. The distance matrix is used to compute sparsity pattern of the inverse of the LoGo covariance and correlation matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.NoLoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.NoLoGo","text":"struct NoLoGo <: AbstractLoGo end\n\nLeave the matrix as is.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortCovCor","text":"@kwdef mutable struct PortCovCor <: PortfolioOptimiserCovCor\n    ce::CovarianceEstimator = CovFull(;)\n    posdef::PosdefFix = PosdefNearest(;)\n    denoise::Denoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nPortfolioOptimiser covariance and correlation estimator.\n\nParameters\n\nce: covariance estimator.\nposdef: method for fixing the portfolio covariance or correlation matrix PosdefFix.\ndenoise: method for denoising the portfolio covariance or correlation matrix Denoise.\nlogo: method for computing the LoGo portfolio covariance or correlation matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SimpleVariance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SimpleVariance","text":"@kwdef mutable struct SimpleVariance <: StatsBase.CovarianceEstimator\n    corrected::Bool = true\nend\n\nSimple variance estimator.\n\nParameters\n\ncorrected:\nif true: correct the bias dividing by N-1 instead of N.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewFull","text":"struct SkewFull <: SkewEstimator end\n\nFull cokurtosis estimator.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewSemi","text":"@kwdef mutable struct SkewSemi <: SkewEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewFull, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(::SkewFull, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewSemi, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(se::SkewSemi, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.logo!","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.logo!","text":"logo!(::NoLoGo, ::PosdefFix, ::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.logo!-2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.logo!","text":"logo!(je::LoGo, posdef::PosdefFix, X::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/CovCorKurtSkew/#Private","page":"Covariance, correlation, cokurtosis and coskewness","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PosdefFixCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PosdefFixCovCor","text":"const PosdefFixCovCor = Union{<:CorGerber, PortCovCor}\n\nCovariance and correlation estimators that support positive definite fixes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.AbstractLoGo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.AbstractLoGo","text":"abstract type AbstractLoGo end\n\nAbstract type for subtyping LoGo covariance and correlation matrix estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerber","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerber","text":"abstract type CorGerber <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberBasic","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberBasic","text":"abstract type CorGerberBasic <: CorGerber end\n\nAbstract type for subtyping the original Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorGerberSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorGerberSB","text":"abstract type CorSB <: CorGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications with vote counting of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorPearson","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorPearson","text":"abstract type CorPearson <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Pearson type covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorRank","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorRank","text":"abstract type CorRank <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping rank based covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSB","text":"abstract type CorSB <: CorGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtEstimator","text":"abstract type KurtEstimator end\n\nAbstract type for subtyping cokurtosis estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortfolioOptimiserCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortfolioOptimiserCovCor","text":"abstract type PortfolioOptimiserCovCor <: StatsBase.CovarianceEstimator end\n\nAbstract type for subtyping portfolio covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewEstimator","text":"abstract type SkewEstimator end\n\nAbstract type for subtyping coskew estimators.\n\n\n\n\n\n","category":"type"},{"location":"PlotsExtension/#Plots-extension","page":"Plots Extension","title":"Plots extension","text":"","category":"section"},{"location":"PlotsExtension/#Public","page":"Plots Extension","title":"Public","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = true\nPrivate = false\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#Private","page":"Plots Extension","title":"Private","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = false\nPrivate = true\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#PortfolioOptimiser.plot_returns-NTuple{4, Any}","page":"Plots Extension","title":"PortfolioOptimiser.plot_returns","text":"plot_returns(timestamps, assets, returns, weights; per_asset = false, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Asset-allocation","page":"Asset allocation","title":"Asset allocation","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#Public","page":"Asset allocation","title":"Public","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.LP","page":"Asset allocation","title":"PortfolioOptimiser.LP","text":"struct LP <: AllocationMethod end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.allocate!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Asset allocation","title":"PortfolioOptimiser.allocate!","text":"allocate!(port::AbstractPortfolio;\n                   type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                   method::AllocationMethod = LP(), latest_prices = port.latest_prices,\n                   investment::Real = 1e6, \n                   string_names::Bool = false)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Private","page":"Asset allocation","title":"Private","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.roundmult-Tuple{Any, Any, Vararg{Any}}","page":"Asset allocation","title":"PortfolioOptimiser.roundmult","text":"roundmult(val, prec [, args...] [; kwargs...])\n\nRound a number to a multiple of prec. Uses the same defaults and has the same args and kwargs of the built-in Base.round.\n\nEquivalent to:\n\nround(div(val, prec) * prec, args...; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Regression","page":"Regression","title":"Regression","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#Public","page":"Regression","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AIC","page":"Regression","title":"PortfolioOptimiser.AIC","text":"struct AIC <: MinValStepwiseRegressionCriteria end\n\nAkaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AICC","page":"Regression","title":"PortfolioOptimiser.AICC","text":"struct AICC <: MinValStepwiseRegressionCriteria end\n\nCorrected Akaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AdjRSq","page":"Regression","title":"PortfolioOptimiser.AdjRSq","text":"struct AdjRSq <: MaxValStepwiseRegressionCriteria end\n\nAdjusted R² for a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BIC","page":"Regression","title":"PortfolioOptimiser.BIC","text":"struct BIC <: MinValStepwiseRegressionCriteria end\n\nBayesian Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BReg","page":"Regression","title":"PortfolioOptimiser.BReg","text":"@kwdef mutable struct BReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nBackward stepwise regression. Starts by assuming all features are significant and uses criterion to remove the worst performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FReg","page":"Regression","title":"PortfolioOptimiser.FReg","text":"@kwdef mutable struct FReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nForward stepwise regression. Starts by assuming no factor is significant and uses criterion to add the best performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FactorType","page":"Regression","title":"PortfolioOptimiser.FactorType","text":"@kwdef mutable struct FactorType\n    error::Bool = true\n    B::Union{Nothing, DataFrame} = nothing\n    method::RegressionType = FReg(;)\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    var_w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCAReg","page":"Regression","title":"PortfolioOptimiser.PCAReg","text":"@kwdef mutable struct PCAReg <: DimensionReductionRegression\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    target::DimensionReductionTarget = PCATarget(;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCATarget","page":"Regression","title":"PortfolioOptimiser.PCATarget","text":"@kwdef mutable struct PCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PPCATarget","page":"Regression","title":"PortfolioOptimiser.PPCATarget","text":"@kwdef mutable struct PPCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PVal","page":"Regression","title":"PortfolioOptimiser.PVal","text":"@kwdef mutable struct PVal{T1 <: Real} <: StepwiseRegressionCriteria\n    threshold::T1 = 0.05\nend\n\nP-value as feature selection criterion.\n\nParameters\n\nthreshold: threshold for classifying significant p-values. Only features whose p-values are lower than threshold are considered significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RSq","page":"Regression","title":"PortfolioOptimiser.RSq","text":"struct RSq <: MaxValStepwiseRegressionCriteria end\n\nR² of a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.loadings_matrix","page":"Regression","title":"PortfolioOptimiser.loadings_matrix","text":"loadings_matrix(x::DataFrame, y::DataFrame, method::RegressionType = FReg())\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Regression/#Private","page":"Regression","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionRegression","page":"Regression","title":"PortfolioOptimiser.DimensionReductionRegression","text":"abstract type DimensionReductionRegression <: RegressionType end\n\nAbstract type for subtyping dimensionality reduction regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionTarget","page":"Regression","title":"PortfolioOptimiser.DimensionReductionTarget","text":"abstract type DimensionReductionTarget end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MaxValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MaxValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where larger values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MinValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MinValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where smaller values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RegressionType","page":"Regression","title":"PortfolioOptimiser.RegressionType","text":"abstract type RegressionType end\n\nAbstract type for subtyping regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegression","page":"Regression","title":"PortfolioOptimiser.StepwiseRegression","text":"abstract type StepwiseRegression <: RegressionType end\n\nAbstract type for subtyping stepwise regression methods for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.StepwiseRegressionCriteria","text":"abstract type StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria for selecting significant features when using StepwiseRegression methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#Expected-returns","page":"Expected returns","title":"Expected returns","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#Public","page":"Expected returns","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.GM","page":"Expected returns","title":"PortfolioOptimiser.GM","text":"struct GM <: MeanTarget end\n\nGrand mean target.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBOP","page":"Expected returns","title":"PortfolioOptimiser.MuBOP","text":"@kwdef mutable struct MuBOP <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBodnar-Okhrin-Parolya [8] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBS","page":"Expected returns","title":"PortfolioOptimiser.MuBS","text":"@kwdef mutable struct MuBS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBayes-Stein [9] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuJS","page":"Expected returns","title":"PortfolioOptimiser.MuJS","text":"@kwdef mutable struct MuJS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nJames-Stein [10, 11] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuSimple","page":"Expected returns","title":"PortfolioOptimiser.MuSimple","text":"@kwdef mutable struct MuSimple <: MeanEstimator\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSimple expected returns vector estimator.\n\nParameters\n\nw: optional T×1 vector of weights for computing the expected returns vector.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.SE","page":"Expected returns","title":"PortfolioOptimiser.SE","text":"struct SE <: MeanTarget end\n\nMean square error of sample mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.VW","page":"Expected returns","title":"PortfolioOptimiser.VW","text":"struct VW <: MeanTarget end\n\nVolatility-weighted grand mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.target_mean-Tuple{GM, AbstractVector, AbstractMatrix, Any, Integer, Integer}","page":"Expected returns","title":"PortfolioOptimiser.target_mean","text":"target_mean(::GM, mu::AbstractVector, sigma::AbstractMatrix, inv_sigma, T::Integer,\n                     N::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MeanEstimators/#Private","page":"Expected returns","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanEstimator","text":"abstract type MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanSigmaEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanSigmaEstimator","text":"abstract type MeanSigmaEstimator <: MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanTarget","page":"Expected returns","title":"PortfolioOptimiser.MeanTarget","text":"abstract type MeanTarget end\n\nAbstract type for subtyping correction targets of expected returns estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Worst-case-mean-variance-sets","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#Public","page":"Worst case mean variance sets","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.ArchWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.ArchWC","text":"@kwdef mutable struct ArchWC{T1 <: Integer, T2 <: Integer, T3 <: Real} <: WorstCaseMethod\n    bootstrap::WorstCaseArchMethod = StationaryBS()\n    n_sim::T1 = 3_000\n    block_size::T2 = 3\n    q::T3 = 0.05\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Box","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Box","text":"struct Box <: WorstCaseSet end\n\nBox sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.CircularBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.CircularBS","text":"struct CircularBS <: WorstCaseArchMethod end\n\nCircular block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.DeltaWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.DeltaWC","text":"@kwdef mutable struct DeltaWC{T1 <: Real, T2 <: Real} <: WorstCaseMethod\n    dcov::T1 = 0.1\n    dmu::T2 = 0.1\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Ellipse","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Ellipse","text":"struct Ellipse <: WorstCaseSet end\n\nElliptical sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KGeneralWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KGeneralWC","text":"struct KGeneralWC <: WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KNormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KNormalWC","text":"struct KNormalWC <: WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.MovingBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.MovingBS","text":"struct MovingBS <: WorstCaseArchMethod end\n\nMoving block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NoWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NoWC","text":"@kwdef mutable struct NoWC <: WorstCaseSet\n    formulation::SDSquaredFormulation = SOCSD()\nend\n\nUse no set for worst case mean variance optimisation.\n\nParameters\n\nformulation: quadratic expression formulation of SD risk measure to use SDSquaredFormulation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NormalWC","text":"@kwdef mutable struct NormalWC{T1 <: Integer, T2 <: Real} <: WorstCaseMethod\n    n_sim::T1 = 3_000\n    q::T2 = 0.05\n    rng::AbstractRNG = Random.default_rng()\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.StationaryBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.StationaryBS","text":"struct StationaryBS <: WorstCaseArchMethod end\n\nStationary bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCType","text":"@kwdef mutable struct WCType\n    cov_type::PortfolioOptimiserCovCor = PortCovCor(;)\n    mu_type::MeanEstimator = MuSimple(;)\n    box::WorstCaseMethod = NormalWC(;)\n    ellipse::WorstCaseMethod = NormalWC(;)\n    k_sigma::Union{<:Real, WorstCaseKMethod} = KNormalWC(;)\n    k_mu::Union{<:Real, WorstCaseKMethod} = KNormalWC(;)\n    posdef::PosdefFix = PosdefNearest(;)\n    diagonal::Bool = false\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Private","page":"Worst case mean variance sets","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseArchMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseArchMethod","text":"abstract type WorstCaseArchMethod <: WorstCaseMethod end\n\nAbstract type for subtyping methods for computing worst case mean variance for bootstrapping with arch.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseKMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseKMethod","text":"abstract type WorstCaseKMethod end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseMethod","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseMethod","text":"abstract type WorstCaseMethod end\n\nAbstract type for subtyping methods for computing worst case mean variance sets.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseSet","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseSet","text":"abstract type WorstCaseSet end\n\nAbstract type for subtyping worst case mean variance set types.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#Optimisation-kinds","page":"Optimisation kinds","title":"Optimisation kinds","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#Public","page":"Optimisation kinds","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationWC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHRP.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHERC.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationNCO.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.BasicRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.BasicRRP","text":"struct BasicRRP <: RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HERC","page":"Optimisation kinds","title":"PortfolioOptimiser.HERC","text":"struct HERC <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HRP","page":"Optimisation kinds","title":"PortfolioOptimiser.HRP","text":"struct HRP <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NCO","page":"Optimisation kinds","title":"PortfolioOptimiser.NCO","text":"@kwdef mutable struct NCO <: HCOptimType\n    opt_kwargs::NamedTuple = (;)\n    opt_kwargs_o::NamedTuple = opt_kwargs\n    port_kwargs::NamedTuple = (;)\n    port_kwargs_o::NamedTuple = port_kwargs\n    stat_kwargs_o::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NOC","page":"Optimisation kinds","title":"PortfolioOptimiser.NOC","text":"@kwdef mutable struct NOC{T1 <: Real, T2 <: AbstractVector{<:Real},\n                          T3 <: AbstractVector{<:Real}, T4 <: AbstractVector{<:Real},\n                          T5 <: AbstractVector{<:Real}, T6 <: AbstractVector{<:Real}} <:\n                      OptimType\n    type::Union{WC, Trad} = Trad()\n    bins::T1 = 20.0\n    w_opt::T2 = Vector{Float64}(undef, 0)\n    w_min::T3 = Vector{Float64}(undef, 0)\n    w_max::T4 = Vector{Float64}(undef, 0)\n    w_min_ini::T5 = Vector{Float64}(undef, 0)\n    w_max_ini::T6 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RP","page":"Optimisation kinds","title":"PortfolioOptimiser.RP","text":"struct RP <: OptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RRP","text":"@kwdef mutable struct RRP <: OptimType\n    version::RRPVersion = BasicRRP()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegPenRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RegPenRRP","text":"@kwdef mutable struct RegPenRRP{T1 <: Real} <: RRPVersion\n    penalty::T1 = 1.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegRRP","page":"Optimisation kinds","title":"PortfolioOptimiser.RegRRP","text":"struct RegRRP <: RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.Trad","page":"Optimisation kinds","title":"PortfolioOptimiser.Trad","text":"struct Trad <: OptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.WC","page":"Optimisation kinds","title":"PortfolioOptimiser.WC","text":"@kwdef mutable struct WC <: OptimType\n    mu::WorstCaseSet = Box()\n    cov::WorstCaseSet = Box()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.efficient_frontier!-Tuple{Portfolio}","page":"Optimisation kinds","title":"PortfolioOptimiser.efficient_frontier!","text":"efficient_frontier!(port::Portfolio; type::Union{Trad, NOC} = Trad(),\n                             rm::Union{AbstractVector, <:RiskMeasure} = SD(),\n                             kelly::RetType = NoKelly(), class::PortClass = Classic(),\n                             w_min_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             w_max_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             points::Integer = 20, rf::Real = 0.0)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.optimise!-Tuple{HCPortfolio}","page":"Optimisation kinds","title":"PortfolioOptimiser.optimise!","text":"optimise!(port::HCPortfolio; rm::Union{AbstractVector, <:AbstractRiskMeasure} = SD(),\n                   rm_o::Union{AbstractVector, <:AbstractRiskMeasure} = rm,\n                   type::HCOptimType = HRP(), cluster::Bool = true,\n                   hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt(),\n                   max_iter::Int = 100)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#Private","page":"Optimisation kinds","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationWC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRP.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHRP.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationHERC.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationNCO.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractOptimType","text":"abstract type AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HCOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.HCOptimType","text":"abstract type HCOptimType <: AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.OptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.OptimType","text":"abstract type OptimType <: AbstractOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRPVersion","page":"Optimisation kinds","title":"PortfolioOptimiser.RRPVersion","text":"abstract type RRPVersion end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClusterNode","page":"Clustering","title":"PortfolioOptimiser.ClusterNode","text":"struct ClusterNode{tid, tl, tr, td, tcnt}\n    id::tid\n    left::tl\n    right::tr\n    height::td\n    level::tcnt\n\n    function ClusterNode(id, left::Union{ClusterNode, Nothing} = nothing,\n                         right::Union{ClusterNode, Nothing} = nothing, height::Real = 0.0,\n                         level::Int = 1)\n        ilevel = isnothing(left) ? level : (left.level + right.level)\n\n        return new{typeof(id), typeof(left), typeof(right), typeof(height), typeof(level)}(id,\n                                                                                         left,\n                                                                                         right,\n                                                                                         height,\n                                                                                         ilevel)\n    end\nend\n\nStructure for definining a cluster node. This is used for turning a clustering result into a tree, is_leaf, pre_order, to_tree.\n\nParameters\n\nid: node ID.\nleft: node to the left.\nright: node to the right.\nheight: node height.\nlevel: node level.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHT","page":"Clustering","title":"PortfolioOptimiser.DBHT","text":"mutable struct DBHT <: HClustAlg\n    distance::DistMethod\n    similarity::DBHTSimilarity\n    root_method::DBHTRootMethod\nend\n\nDefines the parameters for computing DBHTs [4].\n\nParameters\n\ndistance: method for computing the distance matrix from correlation ones DistMethod.\nsimilarity: method for computing the similarity matrix from the correlation and/or distance ones DBHTSimilarity, dbht_similarity.\nroot_method: method for choosing clique roots DBHTRootMethod.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTExp","page":"Clustering","title":"PortfolioOptimiser.DBHTExp","text":"struct DBHTExp <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise exponential decay of the dissimilarity matrix in dbht_similarity.\n\nbeginalign\nS_ij = exp(-D_ij)\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTMaxDist","page":"Clustering","title":"PortfolioOptimiser.DBHTMaxDist","text":"struct DBHTMaxDist <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise squared distance from the maximum value of the dissimilarity matrix dbht_similarity.\n\nbeginalign\nS_ij = leftlceil (max mathbfD)^2 rightrceil - D_ij ^ 2\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\nmathbfD is the distance matrix.\n\n\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.EqualDBHT","page":"Clustering","title":"PortfolioOptimiser.EqualDBHT","text":"struct EqualDBHT <: DBHTRootMethod end\n\nCreate a clique's root from its adjacency tree in CliqueRoot.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HAC","page":"Clustering","title":"PortfolioOptimiser.HAC","text":"@kwdef mutable struct HAC <: HClustAlg\n    linkage::Symbol = :ward\nend\n\nUse a hierarchical clustering algorithm from Clustering.jl.\n\nParameters\n\nlinkage: linkage type supported by hclust.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HCOpt","page":"Clustering","title":"PortfolioOptimiser.HCOpt","text":"@kwdef mutable struct HCOpt{T1 <: Integer, T2 <: Integer}\n    branchorder::Symbol = :optimal\n    k_method::NumClusterMethod = TwoDiff()\n    k::T1 = 0\n    max_k::T2 = 0\nend\n\nDefines the options for processing clustering results in an instance of Clustering.Hclust.\n\nParameters\n\nbranchorder: parameter for ordering a dendrogram's branches accepted by Clustering.jl.\nk_method: method subtyping NumClusterMethod for computing the number of clusters.\nk:\nif iszero(k): use k_method for computing the number of clusters.\nelse: directly provide the number of clusters.\nmax_k: maximum number of clusters, capped to ⌈sqrt(N)⌉.\nif 0: defaults to ⌈sqrt(N)⌉.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.StdSilhouette","page":"Clustering","title":"PortfolioOptimiser.StdSilhouette","text":"@kwdef mutable struct StdSilhouette <: NumClusterMethod\n    metric::Union{Distances.SemiMetric, Nothing} = nothing\nend\n\nUse the standardised silhouette score for computing the number of clusters in calc_k_clusters.\n\nParameters\n\nmetric: metric for computing the silhouettes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.TwoDiff","page":"Clustering","title":"PortfolioOptimiser.TwoDiff","text":"struct TwoDiff <: NumClusterMethod end\n\nUse the two difference gap statistic for computing the number of clusters in calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.UniqueDBHT","page":"Clustering","title":"PortfolioOptimiser.UniqueDBHT","text":"struct UniqueDBHT <: DBHTRootMethod end\n\nCreate a unique root for a clique in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.calc_k_clusters-Tuple{HCOpt, AbstractMatrix, Any}","page":"Clustering","title":"PortfolioOptimiser.calc_k_clusters","text":"calc_k_clusters(hclust_opt::HCOpt, dist::AbstractMatrix, clustering)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTExp, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTExp, S, D)\n\nComputes the DBHTExp similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTMaxDist, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTMaxDist, S, D)\n\nComputes the DBHTMaxDist similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.is_leaf-Tuple{ClusterNode}","page":"Clustering","title":"PortfolioOptimiser.is_leaf","text":"is_leaf(a::ClusterNode)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.pre_order","page":"Clustering","title":"PortfolioOptimiser.pre_order","text":"pre_order(a::ClusterNode, func::Function = x -> x.id)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.to_tree-Tuple{Clustering.Hclust}","page":"Clustering","title":"PortfolioOptimiser.to_tree","text":"to_tree(a::Hclust)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTs-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DBHTs","text":"DBHTs(D::AbstractMatrix{<:Real}, S::AbstractMatrix{<:Real}; branchorder::Symbol = :optimal,\n      method::Symbol = :Unique)\n\nPerform Direct Bubble Hierarchical Tree clustering, a deterministic clustering algorithm [4]. This version uses a graph-theoretic filtering technique called Triangulated Maximally Filtered Graph (TMFG).\n\nArguments\n\nD: N×N dissimilarity matrix, e.g. a distance matrix.\nS: N×N non-negative similarity matrix, examples include:\nmathbfS = mathbfC + lvert min mathbfC rvert.\nmathbfS = lceilmax left(mathbfD^odot 2right)rceil - mathbfD^odot 2.\nmathbfS = exp odot (-mathbfD).\nWhere mathbfC is the correlation matrix, mathbfD the dissimilarity matrix D, and odot the Hadamard (elementwise) operator.\nbranchorder: parameter for ordering the final dendrogram's branches accepted by Clustering.jl.\nmethod: method for finding the root of a Direct Bubble Hierarchical Clustering Tree in case there is more than one candidate DBHTRootMethod.\n:Unique: create a unique root.\n:Equal: the root is created from the candidate's adjacency tree.\n\nOutputs\n\nT8: N×1 cluster membership vector.\nRpm: N×N adjacency matrix of the Planar Maximally Filtered Graph (PMFG).\nAdjv: Bubble cluster membership matrix from BubbleCluster8s.\nDpm: N×N shortest path length matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\nZ_hclust: Z matrix in Clustering.Hclust format.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.J_LoGo-Tuple{Any, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.J_LoGo","text":"J_LoGo(sigma, separators, cliques)\n\nCompute the sparse inverse covariance from a clique tree and separators [6].\n\nInputs\n\nsigma: N×N covariance matrix.\nseparators: list of 3-cliques that are not triangular faces.\ncliques: list of all 4-cliques.\n\nOutputs\n\njlogo: J_LoGo covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.PMFG_T2s","page":"Clustering","title":"PortfolioOptimiser.PMFG_T2s","text":"PMFG_T2s(W::AbstractMatrix{<:Real}, nargout::Integer = 3)\n\nConstructs a Triangulated Maximally Filtered Graph (TMFG) starting from a tetrahedron and recursively inserting vertices inside existing triangles (T2 move) in order to approximate a Maximal Planar Graph with the largest total weight, aka Planar Maximally Filtered Graph (PMFG). All weights are non-negative [7].\n\nArguments\n\nW: N×N matrix of non-negative weights.\nnargout: number of output arguments, the same arguments are always returne, this only controls whether some arguments are empty or not.\n\nOutputs\n\nA: adjacency matrix of the PMFG with weights.\ntri: list of triangles (triangular faces).\nclique3: list of 3-cliques taht are not triangular faces, all 3-cliques are given by [tri; clique3].\ncliques: list of all 4-cliques, if nargout <= 3, this will be returned as an empty array.\ncliqueTree: 4-cliques tree structure (adjacency matrix), if nargout <= 4, it is returned as an empty array.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTRootMethod","page":"Clustering","title":"PortfolioOptimiser.DBHTRootMethod","text":"abstract type DBHTRootMethod end\n\nAbstract type for subtyping methods creating roots of cliques in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTSimilarity","page":"Clustering","title":"PortfolioOptimiser.DBHTSimilarity","text":"abstract type DBHTSimilarity end\n\nAbstract type for subtyping methods for defining functions for computing similarity matrices from used in DBHT clustering PMFG_T2s [4, 7].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HClustAlg","page":"Clustering","title":"PortfolioOptimiser.HClustAlg","text":"abstract type HClustAlg end\n\nAbstract type for subtyping hierarchical clustering methods.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.NumClusterMethod","page":"Clustering","title":"PortfolioOptimiser.NumClusterMethod","text":"abstract type NumClusterMethod end\n\nAbstract type for subtyping methods for determining the number of clusters in a Clustering.Hclust when calling calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.AdjCliq-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.AdjCliq","text":"AdjCliq(A::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real},\n        CliqRoot::AbstractVector{<:Real})\n\nFind adjacent clique to the root candidates.\n\nInputs\n\nA: N×N adjacency matrix.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nCliqRoot: Nc×1 vector of root cliques.\n\nOutputs\n\nAdj: Nc×Nc adjacency matrix of the cliques with the root cliques.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleCluster8s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleCluster8s","text":"BubbleCluster8s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                Hb::AbstractMatrix{<:Real}, Mb::AbstractMatrix{<:Real},\n                Mv::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real})\n\nObtains non-discrete and discrete clusterings from the bubble topology of the Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nHb: undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nAdjv: N×Nk cluster membership matrix for vertices for non-discrete clustering via the bubble topology. Adjv[n, k] = 1 indicates cluster membership of vertex n to the k'th non-discrete cluster.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleHierarchy-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleHierarchy","text":"BubbleHierarchy(Pred::AbstractVector{<:Real}, Sb::AbstractVector{<:Real})\n\nBuild the bubble hierarchy.\n\nInputs\n\nPred: Nc×1 vector of predicted hierarchies.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\nOutputs\n\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleMember-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleMember","text":"BubbleMember(Rpm::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n             Mc::AbstractMatrix{<:Real})\n\nAssigns each vertex in the to a specific bubble.\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nMc: Matrix of the bubbles which coincide with the cluster.\n\nOutputs\n\nMvv: Matrix of the vertices belonging to the bubble.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BuildHierarchy-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BuildHierarchy","text":"BuildHierarchy(M::AbstractMatrix{<:Real})\n\nBuilds the predicted hierarchy.\n\nInputs\n\nM: N×Nc matrix of nodes and 3-cliques.\n\nOutputs\n\nPred: Nc×1 vector of predicted hierarchies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqHierarchyTree2s","page":"Clustering","title":"PortfolioOptimiser.CliqHierarchyTree2s","text":"CliqHierarchyTree2s(Apm::AbstractMatrix{<:Real}, method::Symbol = :Unique)\n\nLooks for 3-cliques of a Maximal Planar Graph (MPG), then construct a hierarchy of the cliques with the definition of \"inside\" a clique being a subgraph of smaller size when the entire graph is made disjoint by removing the clique [5].\n\nInputs\n\nApm: N×N adjacency matrix of an MPG.\nmethod: method for finding the root of the graph DBHTRootMethod. Uses Voronoi tesselation between tiling triangles.\nUniqueDBHT(): create a unique root.\nEqualDBHT(): the root is created from the candidate's adjacency tree.\n\nOutputs\n\nH1: Nc×Nc adjacency matrix for 3-clique hierarchical tree where Nc is the number of 3-cliques.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqueRoot-Tuple{UniqueDBHT, Any, Any, Any, Vararg{Any}}","page":"Clustering","title":"PortfolioOptimiser.CliqueRoot","text":"CliqueRoot(::UniqueDBHT, Root, Pred, Nc, args...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DendroConstruct-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Union{Real, AbstractVector{<:Real}}}","page":"Clustering","title":"PortfolioOptimiser.DendroConstruct","text":"DendroConstruct(Zi::AbstractMatrix{<:Real}, LabelVec1::AbstractVector{<:Real},\n                LabelVec2::AbstractVector{<:Real},\n                LinkageDist::Union{<:Real, AbstractVector{<:Real}})\n\nConstruct the linkage matrix by continuially adding rows to the matrix.\n\nInputs\n\nZi: Linkage matrix at iteration i in the same format as the output from Matlab.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: Linkage matrix at iteration i + 1 in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DirectHb-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DirectHb","text":"DirectHb(Rpm::AbstractMatrix{<:Real}, Hb::AbstractMatrix{<:Real},\n         Mb::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n         CliqList::AbstractMatrix{<:Real})\n\nComputes the directions on each separating 3-clique of a Maximal Planar Graph (MPH), hence computes the Directed Bubble Hierarchy Tree (DBHT).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the Planar Maximally Filtered Graph (MPFG).\nHb: Undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nHc: Nb×Nb unweighted directed adjacency matrix of the DBHT. Hc[i, j]=1 indicates a directed edge from bubble i to bubble j.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.FindDisjoint-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.FindDisjoint","text":"FindDisjoint(Adj::AbstractMatrix{<:Real}, Cliq::AbstractVector{<:Real})\n\nFinds disjointed cliques in adjacency matrix.\n\nInputs\n\nAdj: N×N adjacency matrix.\nCliq: 3×1 vector of 3-cliques.\n\nOutputs\n\nT: N×1 vector containing the adjacency number of each node.\nIndxNot: N×1 vector of nodes with no adjacencies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HierarchyConstruct4s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.HierarchyConstruct4s","text":"HierarchyConstruct4s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                     Tc::AbstractVector{<:Real}, Mv::AbstractMatrix{<:Real})\n\nConstructs the intra- and inter-cluster hierarchy by utilizing Bubble Hierarchy structure of a Maximal Planar graph, in this a Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\n\nOutputs\n\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.LinkageFunction-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.LinkageFunction","text":"LinkageFunction(d::AbstractMatrix{<:Real}, labelvec::AbstractVector{<:Real})\n\nLooks for the pair of clusters with the best linkage.\n\nInputs\n\nd: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nlabelvec: label vector for the vertices in the bubble.\n\nOutputs\n\nPairLink: pair of links with the best linkage.\ndvu: value of the best linkage.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser._build_link_and_dendro-Tuple{AbstractRange, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser._build_link_and_dendro","text":"_build_link_and_dendro(rg::AbstractRange, dpm::AbstractMatrix{<:Real},\n                       LabelVec::AbstractVector{<:Real}, LabelVec1::AbstractVector{<:Real},\n                       LabelVec2::AbstractVector{<:Real}, V::AbstractVector{<:Real},\n                       nc::Real, Z::AbstractMatrix{<:Real})\n\nComputes iterates over the vertices to construct the linkage matrix iteration by iteration.\n\nInputs\n\nrg: range of indices of the vertices in a bubble.\ndpm: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nLabelVec: vector labels of all vertices.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: updated linkage matrix in the same format as the output from Matlab.\nnc: updated inverse of the linkage distance.\nLabelVec1: updated LabelVec1 for the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.breadth-Tuple{AbstractMatrix{<:Real}, Integer}","page":"Clustering","title":"PortfolioOptimiser.breadth","text":"breadth(CIJ::AbstractMatrix{<:Real}, source::Integer)\n\nBreadth-first search.\n\nInputs\n\nCIJ: binary (directed/undirected) connection matrix.\nsource: source vertex.\n\nOutputs\n\ndistance: distance between source and i'th vertex (0 for source vertex).\nbranch: vertex that precedes i in the breadth-first search tree (-1 for source vertex).\n\nnote: Note\nBreadth-first search tree does not contain all paths (or all shortest paths), but allows the determination of at least one path with minimum distace. The entire graph is explored, starting from source vertex source.    # ColoursOriginal written by: Olaf Sporns, Indiana University, 2002/2007/2008\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.clique3-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.clique3","text":"clique3(A::AbstractMatrix{<:Real})\n\nComputes the list of 3-cliques.\n\nInputs\n\nA: N×N adjacency matrix of a Maximal Planar Graph (MPG).\n\nOutputs\n\nK3: vector of vectors with the corresponding indices of candidate cliques.\nE: matrix with non-zero indices and entries of candidate cliques.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.distance_wei-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.distance_wei","text":"distance_wei(L::AbstractMatrix{<:Real})\n\nThe distance matrix contains lengths of shortest paths between all node pairs. An entry [u, v] represents the length of the shortest path from node u to node v. The average shortest path length is the characteristic path length of the network. The function uses Dijkstra's algorithm.\n\nInputs\n\nL: Directed/undirected connection-length matrix.\nLengths between disconnected nodes are set to Inf.\nLengths on the main diagonal are set to 0.\n\nnote: Note\nThe input matrix must be a connection-length matrix typically obtained via a mapping from weight to length. For instance, in a weighted correlation network, higher correlations are more naturally interpreted as shorter distances, and the input matrix should therefore be some inverse of the connectivity matrix, i.e. a distance matrix.The number of edges in the shortest weighted path may in general exceed the number of edges in the shortest binary paths (i.e. the shortest weighted paths computed on the binarised connectivity matrix), because the shortest weighted paths have the minimal weighted distance, not necessarily the minimal number of edges.\n\nOutputs\n\nD: distance (shortest weighted path) matrix.\nB: number of edged in the shortest weigthed path matrix.\n\nnote: Note\nBased on a Matlab implementation by:Mika Rubinov, UNSW/U Cambridge, 2007-2012.\nRick Betzel and Andrea Avena, IU, 2012\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.turn_into_Hclust_merges-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.turn_into_Hclust_merges","text":"turn_into_Hclust_merges(Z::AbstractMatrix{<:Real})\n\nTurns a Matlab-style linkage matrix to a useable format for Hclust.\n\nInputs\n\nZ: Matlab-style linkage matrix.\n\nOutputs\n\nZ: Hclust-style linkage matrix.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PortfolioOptimiser","category":"page"},{"location":"#PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Category Badge\nDocs (Image: Stable) (Image: Dev)\nExamples (Image: Binder)\nCI (Image: Tests) (Image: Documentation) (Image: Aqua)\nCoverage (Image: Codecov) (Image: Coveralls)","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser is a library for portfolio optimisation. It was written with composability and extensibility in mind. It offers a broad range of functionality out of the box. It wraps a lot of external functionality in types for dispatch purposes and to allow easy development and extensibility.","category":"page"},{"location":"#Parameter-estimation","page":"Home","title":"Parameter estimation","text":"","category":"section"},{"location":"#Matrix-processing","page":"Home","title":"Matrix processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These only apply to covariance, correlation, and cokurtosis estimators. Dissimilarity and similarity matrices use the results of correlation estimators, so they are indirectly used there.","category":"page"},{"location":"#Sparsification","page":"Home","title":"Sparsification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Local/Global parsimonious estimator (LoGo), LoGo.","category":"page"},{"location":"#Fixing-non-positive-definite-matrices","page":"Home","title":"Fixing non-positive definite matrices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nearest correlation matrix, PosdefNearest.","category":"page"},{"location":"#Denoising-methods","page":"Home","title":"Denoising methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fixed, DenoiseFixed.\nSpectral, DenoiseSpectral.\nShrink, DenoiseShrink.","category":"page"},{"location":"#Expected-mean-returns-estimators","page":"Home","title":"Expected mean returns estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple mean, MuSimple.\nJames-Stein (JS), MuJS.\nBayes-Stein (BS), MuBS.\nBodnar-Okhrin-Parolya (BOP), MuBOP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The JS, BS and BOP estimators also use a target for correcting their estimates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grand mean (GM), GM.\nVolatility-weighted grand mean (VW), VW.\nMean square error of sample mean (SE), SE.","category":"page"},{"location":"#Covariance-estimators","page":"Home","title":"Covariance estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full, CovFull.\nSemi, CovSemi.\nMutual information, CorMutualInfo.\nBrownian distance, CovDistance.\nLower tail dependence, CorLTD.\nGerber type 0, CorGerber0.\nGerber type 1, CorGerber1.\nGerber type 2, CorGerber2.\nSmyth-Broby modification of Gerber type 0, CorSB0.\nSmyth-Broby modification of Gerber type 1, CorSB1.\nSmyth-Broby modification with vote counting of Gerber type 0, CorGerberSB0.\nSmyth-Broby modification with vote counting of Gerber type 1, CorGerberSB1.","category":"page"},{"location":"#Correlation-estimators","page":"Home","title":"Correlation estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All covariance estimators can be used for correlation estimation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spearman rank, CorSpearman.\nKendall rank, CorKendall.","category":"page"},{"location":"#Disimilarity/distance-matrix-functions","page":"Home","title":"Disimilarity/distance matrix functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marcos López de Prado, DistMLP.\nMarcos López de Prado distance of distance, DistDistMLP.\nNegative log, DistLog.\nVariation of information, DistVarInfo.","category":"page"},{"location":"#Triangulated-maximally-filtered-graph-similarity-matrix-functions","page":"Home","title":"Triangulated maximally filtered graph similarity matrix functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Exponential decay, DBHTExp.\nSquare distance from maximum, DBHTMaxDist.","category":"page"},{"location":"#Bin-width-estimation-functions","page":"Home","title":"Bin width estimation functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Knuth, requires PyCall and astropy to be installed, Knuth.\nFreedman, requires PyCall and astropy to be installed, Freedman.\nScott, requires PyCall and astropy to be installed, Scott.\nHacine-Gharbi and Ravier, HGR.","category":"page"},{"location":"#Cokurtosis-estimators","page":"Home","title":"Cokurtosis estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full cokurtosis, KurtFull.\nSemi cokurtosis, KurtSemi.","category":"page"},{"location":"#Coskewness-estimators","page":"Home","title":"Coskewness estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full coskewness, SkewFull.\nSemi coskewness, SkewSemi.","category":"page"},{"location":"#Clustering","page":"Home","title":"Clustering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical clustering, HAC.\nDirect Bubble Hierarchy Trees clustering, DBHT.","category":"page"},{"location":"#Determining-number-of-clusters","page":"Home","title":"Determining number of clusters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two different gap statistic, TwoDiff.\nStandardised silhouette scores, StdSilhouette.","category":"page"},{"location":"#Networks","page":"Home","title":"Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Triangular maximally filtered graphs (TMFG), TMFG.\nMinimum spanning tree (MST), MST.","category":"page"},{"location":"#Centrality-measures","page":"Home","title":"Centrality measures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Betweenness, BetweennessCentrality.\nCloseness, ClosenessCentrality.\nDegree, DegreeCentrality.\nEigenvector, EigenvectorCentrality.\nKatz, KatzCentrality.\nPagerank, Pagerank.\nRadiality, RadialityCentrality.\nStress, StressCentrality.","category":"page"},{"location":"#Minimum-spanning-tree-algorithms","page":"Home","title":"Minimum spanning tree algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kruskal, KruskalTree.\nBoruvka, BoruvkaTree.\nPrim, PrimTree.","category":"page"},{"location":"#Worst-case-expected-mean-returns-sets-and-covariance","page":"Home","title":"Worst case expected mean returns sets and covariance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Box sets, Box.\nEllipse, Ellipse.","category":"page"},{"location":"#Bootstrapping-methods","page":"Home","title":"Bootstrapping methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ARCH methods, require PyCall and ARCH to be installed, ArchWC.\nStationary bootstrap, StationaryBS.\nCircular bootstrap, CircularBS.\nMoving bootstrap, MovingBS.\nNormal, NormalWC.\nDelta, DeltaWC.","category":"page"},{"location":"#Elliptical-constraint-error-size-estimation","page":"Home","title":"Elliptical constraint error size estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Normal, KNormalWC.\nGeneral, KGeneralWC","category":"page"},{"location":"#Regression-methods","page":"Home","title":"Regression methods","text":"","category":"section"},{"location":"#Stepwise-methods","page":"Home","title":"Stepwise methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward regression, FReg.\nBackward regression, BReg.","category":"page"},{"location":"#Regression-criteria","page":"Home","title":"Regression criteria","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"p-value threshold, PVal.\nModel quality indicators.\nAkaike's Information Criterion, AIC.\nCorrected Akaike's Information Criterion for small sample sizes, AICC.\nBayesian Information Criterion, BIC.\nR² of a linear model, RSq.\nadjusted R² for a linear model, AdjRSq.","category":"page"},{"location":"#Dimensionality-reduction","page":"Home","title":"Dimensionality reduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Principal component analysis (PCA) based regression, PCAReg.\nPCA target, PCATarget.\nProbabilistic PCA target, PPCATarget.","category":"page"},{"location":"#Black-Litterman-models","page":"Home","title":"Black Litterman models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Black Litterman, BLType.","category":"page"},{"location":"#Black-Litterman-factor-models","page":"Home","title":"Black Litterman factor models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Augmented Black Litterman, ABLType.\nBayesian Black Litterman, BBLType.","category":"page"},{"location":"#Linear-moments-(L-moments)","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Normalised constant relative risk aversion coefficients, CRRA.\nMaximum entropy, MaxEntropy.\nMinimum Sum of Squares, MinSumSq.\nMinimum Square Distance, MinSqDist.","category":"page"},{"location":"#Portfolio-optimisation","page":"Home","title":"Portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of Portfolio.","category":"page"},{"location":"#Traditional,-[Trad](@ref)","page":"Home","title":"Traditional, Trad","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation is the traditional efficient frontier optimisation.","category":"page"},{"location":"#Classes,-[PortClass](@ref)","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Objective-functions","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-measures","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (dVar), dVar.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-2","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Worst-case-mean-variance,-[WC](@ref)","page":"Home","title":"Worst case mean variance, WC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires worst case sets for the covariance and expected returns. The optimisation uses these sets to perform a mean variance optimisation.","category":"page"},{"location":"#Constraints-2","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected worst case standard deviation constraint.\nMinimum expected worst case return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-parity,-[RP](@ref)","page":"Home","title":"Risk parity, RP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset or factor. The optimisation attempts to minimise the difference between the risk budget and risk contribution of the asset or factor in the optimised portfolio.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-2","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nFactor risk contribution, FC.","category":"page"},{"location":"#Constraints-3","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Risk-measures-2","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-2","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (dVar), dVar.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-2","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-2","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-3","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Relaxed-risk-parity-mean-variance,-[RRP](@ref)","page":"Home","title":"Relaxed risk parity mean variance, RRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset. The optimisation attempts to minimise the difference between the risk budget and relaxed formulation of the standard deviation risk measure.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-3","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.","category":"page"},{"location":"#Constraints-4","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Near-Optimal-Centering,-[NOC](@ref)","page":"Home","title":"Near Optimal Centering, NOC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Near optimal centering utilise the weights of an optimised portfolio. It computes a region of near optimality using the bounds of the efficient frontier, the expected risk and return of the optimal portfolio, and a user-provided parameter. It then optimises for a portfolio that best describes the region. It provides more diversification and robustness than Trad and smooths out the weight transitions as the efficient frontier is traversed.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-4","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Constraints-5","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-5","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns-2","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Constraints-6","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.","category":"page"},{"location":"#Risk-measures-3","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-3","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (dVar), dVar.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-3","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-3","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-4","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Hierarchical-portfolio-optimisation","page":"Home","title":"Hierarchical portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of HCPortfolio.","category":"page"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref),-and-hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical risk parity, HRP, and hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref)","page":"Home","title":"Hierarchical risk parity, HRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical risk parity optimisations use the hierarchical clustering of assets to assign risk contributions by iteratively splitting the dendrogram in half and assigning weights to each half according to the relative risk each half represents with respect to the other. It does this until it splits the dendrogram all the way down to single leaves.","category":"page"},{"location":"#Hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical equal risk parity optimisations use the hierarchical clustering relationships between assets to assign risk contributions by splitting the dendrogram into k clusters. It starts with the full dendrogram and progressively cuts it into k-1 levels (since the comparison for each side belongs to the k-th level). At each step, it loops through the clusters and checks to which side of the sub-dendrogram the cluster belongs. It accumulates the risk of that cluster to the risk of the side it belongs to. The weights for the assets on each side of the dendrogram are assigned based on the relative (with respect to the other side) aggregate risk from all clusters belonging to it, these are the inter-cluster weights. It then computes the risk for each cluster, assigning weights to each asset according to the relative risk it represents with respect to other assets, these are the intra-cluster weights. It then elementwise multiplies both weights to get the final asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HERC can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Constraints-7","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum and maximum weights per asset.","category":"page"},{"location":"#Risk-measures-4","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-4","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nVariance, Variance.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (dVar), dVar.\nDownside dispersion.\nSemi Variance, Variance.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-4","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nValue at risk (VaR), VaR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-4","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nDrawdown at for uncompounded cumulative returns risk (DaR), DaR.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\nMaximum drawdown (Calmar ratio) for compounded cumulative returns, MDD_r.\nAverage drawdown for compounded cumulative returns, ADD_r.\nUlcer index for compounded cumulative returns, UCI_r.\nDrawdown at for compounded cumulative returns risk (DaR), DaR_r.\nConditional drawdown at risk for compounded cumulative returns (CDaR), CDaR_r.\nEntropic drawdown at risk for compounded cumulative returns (EDaR), EDaR_r.\nRelativistic drawdown at risk for compounded cumulative returns (RLDaR), RLDaR_r.","category":"page"},{"location":"#Linear-moments-(L-moments)-5","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Nested-clustered-optimisation,-[NCO](@ref)","page":"Home","title":"Nested clustered optimisation, NCO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nested clustered optimisation combines the ideas of hierarchical equal risk parity optimisations and portfolio optimisations. They use the hierarchical clustering relationships between assets and splitting the dendrogram into k clusters. It then treats each cluster as its own isntance of Portfolio which is optimised in the usual way. The weights of each cluster are saved in a matrix, these are the intra-cluster weights. Then each cluster as a whole is treated as a synthetic asset, it statistics are internally computed from the fields in the NCO type. An instance of Portfolio is created from these synthetic assets and then optimised, these are the inter-cluster weights. The inter-cluster and intra-cluster weights are multiplied to give the asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NCO can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Sub-types","page":"Home","title":"Sub-types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NCO can take keyword arguments that define the supported by optimisations of Portfolio. Since there are intra- and inter-cluster optimisations, it can take individual arguments for both. This means it can perform any combination of Portfolio optimisations, except for WC.","category":"page"},{"location":"#NCO-Trad,-NCO-NOC-Trad","page":"Home","title":"NCO-Trad, NCO-NOC-Trad","text":"","category":"section"},{"location":"#Objective-functions-2","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints-8","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLeverage constraints.","category":"page"},{"location":"#NCO-RP,-NCO-RRP,-NCO-NOC-RP,-NCO-NOC-RRP","page":"Home","title":"NCO-RP, NCO-RRP, NCO-NOC-RP, NCO-NOC-RRP","text":"","category":"section"},{"location":"#Constraints-9","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.","category":"page"},{"location":"Portfolio/PortfolioTypes/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#Public","page":"Types","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.HCPortfolio","page":"Types","title":"PortfolioOptimiser.HCPortfolio","text":"mutable struct HCPortfolio{ast, dat, r, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv,\n                           tsskew, tsv, wmi, wma, tco, tdist, tcl, tk, topt, tsolv, tf, tlp,\n                           taopt, talo, tasolv, taf, tamod} <: AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    w_min::wmi\n    w_max::wma\n    cor::tco\n    dist::tdist\n    clusters::tcl\n    k::tk\n    optimal::topt\n    solvers::tsolv\n    fail::tf\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a hierarchical clustering portfolio.\n\nParameters\n\nassets: N×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×N matrix of asset returns.\nmu: N×1 vector of asset expected returns.\ncov: N×N asset covariance matrix.\nkurt: N^2×N^2 cokurtosis matrix.\nskurt: N^2×N^2 semi cokurtosis matrix.\nL_2: (N^2)×((N^2 + N)/2) elimination matrix.\nS_2: ((N^2 + N)/2)×(N^2) summation matrix.\nskew: N×N^2 coskew matrix.\nV: N×N sum of the symmetric negative spectral slices of coskewness.\nsskew: N×N^2 semi coskew matrix.\nSV: N×N sum of the symmetric negative spectral slices of semi coskewness.\nw_min: minimum allowable asset weights.\nif isa vector: N×1 vector of minimum allowable weight per asset.\nif isa scalar: minimum asset weight for all assets.\nw_max: maximum allowable asset weights.\nif isa vector: N×1 vector of maximum allowable weight per asset.\nif isa scalar: maximum asset weight for all assets.\ncor: N×N asset correlation matrix.\ndist: N×N asset distance matrix.\nclusters: Clustering.Hclust of asset clusters.\nk: number of asset clusters.\nif is zero: compute the number of clusters via one of the cluster number methods NumClusterMethod.\nif is not zero: use this value directly.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.HCPortfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.HCPortfolio","text":"HCPortfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n              returns::DataFrame = DataFrame(),\n              ret::Matrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              timestamps::Vector{<:Dates.AbstractTime} = Vector{Date}(undef, 0),\n              assets::AbstractVector = Vector{String}(undef, 0),\n              mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n              cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              V = Matrix{eltype(returns)}(undef, 0, 0),\n              sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              SV = Matrix{eltype(returns)}(undef, 0, 0),\n              w_min::Union{<:Real, <:AbstractVector{<:Real}} = 0.0,\n              w_max::Union{<:Real, <:AbstractVector{<:Real}} = 1.0,\n              cor::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              dist::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n              clusters::Clustering.Hclust = Hclust{Float64}(Matrix{Int64}(undef, 0, 2),\n                                                          Float64[], Int64[],\n                                                          :nothing),\n              k::Integer = 0, optimal::AbstractDict = Dict(),\n              solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n              latest_prices::AbstractVector = Vector{Float64}(undef, 0),\n              alloc_optimal::AbstractDict = Dict(),\n              alloc_leftover::AbstractDict = Dict(),\n              alloc_solvers::AbstractDict = Dict(),\n              alloc_fail::AbstractDict = Dict(),\n              alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for HCPortfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of HCPortfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"mutable struct Portfolio{ast, dat, r, tfa, tfdat, tretf, l, lo, s, us, ul, nal, nau, naus,\n                         mnak, mnaks, rb, to, kte, blbw, ami, bvi, rbv, frbv, nm, amc, bvc,\n                         ler, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv, tsskew, tsv,\n                         tmuf, tcovf, trfm, tmufm, tcovfm, tmubl, tcovbl, tmublf, tcovblf,\n                         tcovl, tcovu, tcovmu, tcovs, tdmu, tkmu, tks, topt, tlim, tfront,\n                         tsolv, tf, tmod, tlp, taopt, talo, tasolv, taf, tamod} <:\n               AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    f_assets::tfa\n    f_timestamps::tfdat\n    f_returns::tretf\n    loadings::l\n    regression_type::lo\n    short::s\n    short_u::us\n    long_u::ul\n    num_assets_l::nal\n    num_assets_u::nau\n    num_assets_u_scale::naus\n    max_num_assets_kurt::mnak\n    max_num_assets_kurt_scale::mnaks\n    rebalance::rb\n    turnover::to\n    tracking_err::kte\n    bl_bench_weights::blbw\n    a_mtx_ineq::ami\n    b_vec_ineq::bvi\n    risk_budget::rbv\n    f_risk_budget::frbv\n    network_adj::nm\n    a_vec_cent::amc\n    b_cent::bvc\n    mu_l::ler\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    f_mu::tmuf\n    f_cov::tcovf\n    fm_returns::trfm\n    fm_mu::tmufm\n    fm_cov::tcovfm\n    bl_mu::tmubl\n    bl_cov::tcovbl\n    blfm_mu::tmublf\n    blfm_cov::tcovblf\n    cov_l::tcovl\n    cov_u::tcovu\n    cov_mu::tcovmu\n    cov_sigma::tcovs\n    d_mu::tdmu\n    k_mu::tkmu\n    k_sigma::tks\n    optimal::topt\n    limits::tlim\n    frontier::tfront\n    solvers::tsolv\n    fail::tf\n    model::tmod\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a traditional portfolio. Na is the number of assets, and Nf is the number of factors. For details on how some of these parameters are computed see asset_statistics!, wc_statistics!, factor_statistics!, black_litterman_statistics!, and black_litterman_factor_statistics!.\n\nParameters\n\nassets: Na×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×Na matrix of asset returns.\nf_assets: Nf×1 vector of factor names.\nf_timestamps: T×1 vector of factor returns timestamps.\nf_returns: T×Nf matrix of asset returns.\nloadings: loadings matrix for working with factor models.\nregression_type: RegressionType used for computing the loadings matrix.\nshort:\nif true: shorting is enabled.\nelse: long-only portfolio.\nshort_u: upper bound for the absolute value of the sum of the negative weights.\nlong_u: upper bound for the sum of the positive weights.\nnum_assets_l: lower bound for the minimum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u: upper bound for the maximum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u_scale: scaling factor for the decision variable used for applying the num_assets_u constraint when optimising the Sharpe objective function.\nmax_num_assets_kurt: maximum number of assets to use the complete kurtosis model.\nif > 0: the approximate model will be used if the number of assets in the portfolio exceeds max_number_assets_kurt.\nmax_num_assets_kurt_scale: multipies Na to find the number of eigenvalues when computing the approximate kurtosis model, must be ∈ [1, Na].\nrebalance: AbstractTR for defining the portfolio rebalancing penalty.\nbeginalign\np_r = sumlimits_i=1^N r_i lvert w_i - b_i rvert\nendalign\nWhere:\np_r is the portfolio rebalancing penalty.\nN is the number of assets.\nr_i is the rebalancing penalty for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nturnover: AbstractTR for defining the asset turnover constraint.\nbeginalign\nlvert w_i - b_i rvert leq t_iquad forall i = 1ldotsN\nendalign\nWhere:\nt_i is the turnover constraint for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nN is the number of assets.\ntracking_err: TrackingErr for defining the tracking error constraint.\nbeginalign\nleftlVert dfracmathbfX bmw - bmbT - 1 rightrVert_2 leq epsilon\nendalign\nWhere:\nlVert cdot rVert_2 is the L2 norm.\nmathbfX is the T times N matrix of asset returns.\nT is the number of returns observations.\nN is the number of assets.\nbmw is the N times 1 vector of asset weights.\nbmb is the T times 1 vector of benchmark returns.\nepsilon is the tracking error.\nbl_bench_weights: benchmark weights for Black-Litterman models BlackLittermanClass.\na_mtx_ineq: C×N matrix of asset weight linear constraints.\nif isempty: the constraint is not set.\nb_vec_ineq: C×1 vector of asset weight linear constraints.\nif isempty: the constraint is not set.\nThe linear weight constraint is defined as.\nbeginalign\nmathbfA bmw geq bmb\nendalign\nWhere:\nmathbfA is the CN matrix of asset weight linear constraints.\nbmb is the C1 vector of asset weight linear constraints.\nC is the number of constraints.\nN is the number of assets.\nrisk_budget: Na×1 vector of asset risk budgets.\nf_risk_budget: Nf×1 vector of factor risk budgets.\nnetwork_adj: AdjacencyConstraint for defining the asset network constraint. This can be defined in two ways, using an exact mixed-integer approach IP or an approximate semi-definite one SDP. See their docs for the constraint definition for each case.\nif NoAdj: the constraint is not set.\na_vec_cent: centrality vector for defining the centrality constraint.\nif isempty: the constraint is not set.\nb_cent: average centrality of the assets the portfolio.\nif isinf: the constraint is not set.\nThe centrality constraint is defined as.\nbeginalign\nbmC cdot bmw = barc\nendalign\nWhere:\nbmw is the Ntimes 1 vector of asset weights.\nbmC is the N times 1 centrality vector of the asset adjacency matrix.\ncdot is the dot product.\nbarc is the desired average centrality measure of the portfolio.\nmu_l: lower bound for the expected return of the portfolio.\nif is Inf: the constraint is not applied.\nmu: Na×1 vector of asset expected returns.\ncov: Na×Na asset covariance matrix.\nkurt: Na^2×Na^2 cokurtosis matrix.\nskurt: Na^2×Na^2 semi cokurtosis matrix.\nL_2: (Na^2)×((Na^2 + Na)/2) elimination matrix.\nS_2: ((Na^2 + Na)/2)×(Na^2) summation matrix.\nskew: Na×Na^2 coskew matrix.\nV: Na×Na sum of the symmetric negative spectral slices of coskewness.\nsskew: Na×Na^2 semi coskew matrix.\nSV: Na×Na sum of the symmetric negative spectral slices of semi coskewness.\nf_mu: Nf×1 vector of factor expected returns.\nf_cov: Nf×Nf factor covariance matrix.\nfm_returns: T×Na factor model adjusted returns matrix.\nfm_mu: Na×1 factor model adjusted asset expected returns.\nfm_cov: Na×Na factor model adjusted asset covariance matrix.\nbl_mu: Na×1 Black Litterman model adjusted asset expected returns.\nbl_cov: Na×Na Black Litterman model adjusted asset covariance matrix.\nblfm_mu: Na×1 Black Litterman factor model adjusted asset expected returns.\nblfm_cov: Na×Na Black Litterman factor model adjusted asset covariance matrix.\ncov_l: Na×Na lower bound for the worst case covariance matrix.\ncov_u: Na×Na upper bound for the worst case covariance matrix.\ncov_mu: Na×Na matrix of the estimation errors of the asset expected returns vector set.\ncov_sigma: Na×Na matrix of the estimation errors of the asset covariance matrix set.\nd_mu: absolute deviation of the worst case upper and lower asset expected returns vectors.\nk_mu: distance parameter of the uncertainty in the asset expected returns vector for the worst case optimisation.\nk_sigma: distance parameter of the uncertainty in the asset covariance matrix for the worst case optimisation.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nlimits: collection capable of storing key value pairs for storing the minimal and maximal risk portfolios.\nfrontier: collection capable of storing key value pairs for containing points in the efficient frontier.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nmodel: JuMP.Model which defines the optimisation model.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"Portfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n            returns::DataFrame = DataFrame(),\n            ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            timestamps::AbstractVector = Vector{Date}(undef, 0),\n            assets::AbstractVector = Vector{String}(undef, 0),\n            f_prices::TimeArray = TimeArray(TimeType[], []),\n            f_returns::DataFrame = DataFrame(),\n            f_ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_timestamps::AbstractVector = Vector{Date}(undef, 0),\n            f_assets::AbstractVector = Vector{String}(undef, 0),\n            loadings::DataFrame = DataFrame(),\n            regression_type::Union{<:RegressionType, Nothing} = nothing,\n            short::Bool = false, short_u::Real = 0.2, long_u::Real = 1.0,\n            num_assets_l::Integer = 0, num_assets_u::Integer = 0,\n            num_assets_u_scale::Real = 100_000.0, max_num_assets_kurt::Integer = 0,\n            max_num_assets_kurt_scale::Integer = 2, rebalance::AbstractTR = NoTR(),\n            turnover::AbstractTR = NoTR(), tracking_err::TrackingErr = NoTracking(),\n            bl_bench_weights::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            a_mtx_ineq::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            b_vec_ineq::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            network_adj::AdjacencyConstraint = NoAdj(),\n            a_vec_cent::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            b_cent::Real = Inf, mu_l::Real = Inf,\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_returns::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            fm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            bl_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            bl_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            blfm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            blfm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_l::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_u::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_mu::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_sigma::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            d_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            k_mu::Real = Inf, k_sigma::Real = Inf, optimal::AbstractDict = Dict(),\n            limits::AbstractDict = Dict(), frontier::AbstractDict = Dict(),\n            solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n            model::JuMP.Model = JuMP.Model(),\n            latest_prices::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            alloc_optimal::AbstractDict = Dict(),\n            alloc_leftover::AbstractDict = Dict(),\n            alloc_solvers::AbstractDict = Dict(), alloc_fail::AbstractDict = Dict(),\n            alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for Portfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\ntimestamps: set timestamps.\nassets: set assets.\nf_prices: (T+1)×Nf TimeArray of factor prices.\nIf provided: will take precedence over f_returns, f_ret, f_timestamps, and f_assets because they will be automatically computed from f_prices.\nf_returns: T×Nf DataFrame of factor returns.\nIf provided: will take precedence over f_ret, f_timestamps, and f_assets because they will be automatically computed from returns.\nf_ret: set the f_returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of Portfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#Private","page":"Types","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.AbstractPortfolio","page":"Types","title":"PortfolioOptimiser.AbstractPortfolio","text":"abstract type AbstractPortfolio end\n\nAbstract type for subtyping portfolios.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#Public","page":"Constraints","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AKelly","page":"Constraints","title":"PortfolioOptimiser.AKelly","text":"@kwdef mutable struct AKelly <: RetType\n    formulation::SDSquaredFormulation = SOCSD()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.EKelly","page":"Constraints","title":"PortfolioOptimiser.EKelly","text":"struct EKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.IP","page":"Constraints","title":"PortfolioOptimiser.IP","text":"@kwdef struct IP{T1 <: AbstractMatrix{<:Real},\n                 T2 <: Union{<:Integer, <:AbstractVector{<:Integer}}, T3 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    k::T2 = 1\n    scale::T3 = 100_000.0\nend\n\nDefines the exact network constraint using mixed-integer programming.\n\nbeginalign\nleft(mathbfA + mathbfIright)bmy leq bmk\nw_i leq b_u y_i quad forall i = 1ldotsN \nw_i geq b_l y_i quad forall i = 1ldotsN\nendalign\n\nWhere:\n\nmathbfA is the N times N adjacency matrix.\nmathbfI is the identity matrix.\n\nSince each row of left(mathbfA + mathbfIright) corresponds to a path, duplicate rows add no new information whilst increasing the problem's size, therefore we only store unique rows.\n\nbmy is an N times 1 vector of binary 01 decision variables, which decide whether or not the asset should be included in the portfolio.\nbmk:\nif is a vector: Mtimes 1 vector defining the maximum number of assets allowed per unique path, where M is the number of unique paths.\nif is a scalar: defines the maximum number of assets allowed for all unique paths.\nw_i is the i-th asset weight.\nb_ub_l are the upper and lower bounds of the sum of the long and sum of the short asset weights, respectively.\nThus the constraint means we will invest in at most bmk assets per corresponding unique path.\n\nThis approach can be appied to any risk measure without work arounds like SDP. However it is more computationally costly to optimise, and may fail when mathbfA is close to the all ones matrix.\n\nParameters\n\nA: adjacency matrix, only stores unique(A + I, dims = 1).\nk:\nif is a vector: maximum number of assets per unique path.\nif A is not empty, checks that the length of k is equal to the size of unique(A + I, dims = 1).\nif is a scalar: maximum number of assets for all unique paths.\nscale: scaling variable for an auxiliary binary decision variable when optimising the Sharpe objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoAdj","page":"Constraints","title":"PortfolioOptimiser.NoAdj","text":"struct NoAdj <: AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoKelly","page":"Constraints","title":"PortfolioOptimiser.NoKelly","text":"struct NoKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTR","page":"Constraints","title":"PortfolioOptimiser.NoTR","text":"struct NoTR <: AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTracking","page":"Constraints","title":"PortfolioOptimiser.NoTracking","text":"struct NoTracking <: TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.SDP","page":"Constraints","title":"PortfolioOptimiser.SDP","text":"@kwdef mutable struct SDP{T1 <: AbstractMatrix{<:Real}, T2 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    penalty::T2 = 0.05\nend\n\nDefines an approximate network constraint using semi-definite programming.\n\nbeginalign\nbeginbmatrix\nmathbfW  bmw\nbmw^intercal  1\nendbmatrix succeq 0\nmathbfW = mathbfW^intercal\nmathbfA odot mathbfW = bm0\nendalign\n\nWhere:\n\nmathbfW is an auxiliary variable that approximates the outer product of asset weights bmw otimes bmw.\nmathbfA is the Ntimes N adjacency matrix. It tells us which assets are connected. The matrix can only take values of 1 or 0. If entry (ij) is equal to 1, assets i and j are connected.\nodot is the Hadamard (element-wise) product.\n\nWhen the variance risk measure SD is being used, whether in the objective function or as one of the risk constraints. Its definition will change when this constraint is active. The new definition is this.\n\nbeginalign\nphi_mathrmvar(bmw) = mathrmTrleft(mathbfSigmamathbfWright)\nendalign\n\nWhere:\n\nmathrmTr(cdot) is the trace operator.\nmathbfSigma is the covariance matrix.\n\nHowever, this will not work if the variance is not being constrained, or if it is not in the objective function. For that we add/subtract the following penalty factor to the objective function.\n\nbeginalign\nundersetbmwmathrmopt quad phi(bmw) pm lambda mathrmTrleft(mathbfXright)\nendalign\n\nWhere:\n\nmathrmopt is mathrmmin when the objective is convex and mathrmmax when it is concave.\npm is + when the objective is convex and - when it is concave.\nlambda is a penalty factor.\n\nThis approach works better than IP when mathbfA is close to the all ones matrix, even though it's an approximation.\n\nParameters\n\nA: N×N adjacency matrix.\npenalty: penalty factor when the variance SD risk measure isn't being used, either in a constraint or in the objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TR","page":"Constraints","title":"PortfolioOptimiser.TR","text":"@kwdef mutable struct TR{T1 <: Union{<:Real, <:AbstractVector{<:Real}},\n                         T2 <: AbstractVector{<:Real}} <: AbstractTR\n    val::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackRet","page":"Constraints","title":"PortfolioOptimiser.TrackRet","text":"@kwdef mutable struct TrackRet{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackWeight","page":"Constraints","title":"PortfolioOptimiser.TrackWeight","text":"@kwdef mutable struct TrackWeight{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Private","page":"Constraints","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AbstractTR","page":"Constraints","title":"PortfolioOptimiser.AbstractTR","text":"abstract type AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AdjacencyConstraint","page":"Constraints","title":"PortfolioOptimiser.AdjacencyConstraint","text":"abstract type AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.RetType","page":"Constraints","title":"PortfolioOptimiser.RetType","text":"abstract type RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackingErr","page":"Constraints","title":"PortfolioOptimiser.TrackingErr","text":"abstract type TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"EditURL = \"../../../examples/8_relaxed_risk_parity_variance_portfolios.jl\"","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/8_relaxed_risk_parity_variance_portfolios/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#Distance-matrices","page":"Distance matrices","title":"Distance matrices","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#Public","page":"Distance matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistCanonical","text":"struct DistCanonical <: DistMethod end\n\nStruct for computing the canonical distance for a given correlation estimator in get_default_dist.\n\nCorrelation estimator Canonical distance\nCorMutualInfo DistVarInfo\nCorLTD DistLog\nCovDistance DistCor\nAny other estimator DistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistCor","text":"struct DistCor <: DistMethod end\n\nDefines the distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCanonical","text":"struct DistDistCanonical <: DistMethod end\n\nStruct for computing the canonical distance for a given correlation estimator in get_default_dist.\n\nCorrelation estimator Canonical distance\nCorMutualInfo DistDistVarInfo\nCorLTD DistDistLog\nCovDistance DistDistCor\nAny other estimator DistDistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistDistLog","text":"@kwdef mutable struct DistDistLog <: DistMethod\n    distance::Distances.UnionMetric\n    args::Tuple\n    kwargs::NamedTuple\nend\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistDistMLP","text":"@kwdef mutable struct DistDistMLP <: DistMethod\n    absolute::Bool = false\n    distance::Distances.UnionMetric = Distances.Euclidean()\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the distance of distances matrix from a correlation matrix [2] in dist.\n\nbeginalign\ntildeD_ij = f_mleft(bmD_i bmD_jright)\nendalign\n\nWhere:\n\nbmD_i: is the i-th column/row of the N×N distance matrix defined in DistMLP.\nf_m: is the pairwise distance function for metric m. We use the Distances.pairwise function which computes the entire matrix at once.\ntildeD_ij: is the (ij)-th entry of the N×N distances of distances matrix.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistDistVarInfo","text":"@kwdef mutable struct DistDistVarInfo <: DistMethod\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance of distances matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistLog","text":"struct DistLog <: DistMethod end\n\nDefines the log-distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistMLP","text":"@kwdef mutable struct DistMLP <: DistMethod\n    absolute::Bool = false\nend\n\nDefines the distance matrix from a correlation matrix [2] in dist.\n\nbeginalign\nD_ij = \n    begincases\n        sqrtdfrac12 left(1 - C_ijright) quad mathrmif absolute = false\n        sqrt1 - lvert C_ij rvert quad mathrmif absolute = true\n    endcases\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix mathbfC.\nC_ij: is the (ij)-th entry of the N×N correlation matrix mathbfD.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistVarInfo","text":"@kwdef mutable struct DistVarInfo <: DistMethod\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Freedman","page":"Distance matrices","title":"PortfolioOptimiser.Freedman","text":"struct Freedman <: AstroBins end\n\nFreedman's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.HGR","page":"Distance matrices","title":"PortfolioOptimiser.HGR","text":"struct HGR <: AbstractBins end\n\nHacine-Gharbi and Ravier's bin width algorithm [3].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Knuth","page":"Distance matrices","title":"PortfolioOptimiser.Knuth","text":"struct Knuth <: AstroBins end\n\nKnuth's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Scott","page":"Distance matrices","title":"PortfolioOptimiser.Scott","text":"struct Scott <: AstroBins end\n\nScott's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.dist-Tuple{PortfolioOptimiser.DistMethod, Any, Any}","page":"Distance matrices","title":"PortfolioOptimiser.dist","text":"dist(de::DistMethod, X, Y)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/DistanceMatrices/#Private","page":"Distance matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AbstractBins","page":"Distance matrices","title":"PortfolioOptimiser.AbstractBins","text":"abstract type AbstractBins end\n\nAbstract type for defining the bin width estimation functions when computing DistVarInfo and CorMutualInfo distance and correlation matrices respectively.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AstroBins","page":"Distance matrices","title":"PortfolioOptimiser.AstroBins","text":"abstract type AstroBins <: AbstractBins end\n\nAbstract type for defining which bin width function to use from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCor","text":"struct DistdistCor <: DistMethod end\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMethod","page":"Distance matrices","title":"PortfolioOptimiser.DistMethod","text":"abstract type DistMethod end\n\nAbstract type for subtyping methods for computing distance matrices from correlation ones.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.get_default_dist-Tuple{PortfolioOptimiser.DistMethod, PortfolioOptimiser.PortfolioOptimiserCovCor}","page":"Distance matrices","title":"PortfolioOptimiser.get_default_dist","text":"get_default_dist(dist_type::DistMethod, cor_type::PortfolioOptimiserCovCor)\n\nInputs\n\nif isa(cor_type, PortCovCor): operates on the internal correlation estimator cor_type.ce.\nelse: directly operates on the correlation estimator cor_type.\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/PortfolioClasses/#Portfolio-classes","page":"Portfolio classes","title":"Portfolio classes","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#Public","page":"Portfolio classes","title":"Public","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BL","page":"Portfolio classes","title":"PortfolioOptimiser.BL","text":"@kwdef mutable struct BL{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BLFM","page":"Portfolio classes","title":"PortfolioOptimiser.BLFM","text":"@kwdef mutable struct BLFM{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.Classic","page":"Portfolio classes","title":"PortfolioOptimiser.Classic","text":"struct Classic <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FC","page":"Portfolio classes","title":"PortfolioOptimiser.FC","text":"@kwdef mutable struct FC <: PortClass\n    flag::Bool = true\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FM","page":"Portfolio classes","title":"PortfolioOptimiser.FM","text":"@kwdef mutable struct FM{T1 <: Integer} <: PortClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#Private","page":"Portfolio classes","title":"Private","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BlackLittermanClass","page":"Portfolio classes","title":"PortfolioOptimiser.BlackLittermanClass","text":"abstract type BlackLittermanClass <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.PortClass","page":"Portfolio classes","title":"PortfolioOptimiser.PortClass","text":"abstract type PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioClustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets!-Tuple{HCPortfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets!","text":"cluster_assets!(port::HCPortfolio; hclust_alg::HClustAlg = HAC(),\n                hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. Save the results in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{HCPortfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::HCPortfolio; hclust_alg::HClustAlg = HAC(),\n               hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::Portfolio; cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_alg: hierarchical clustering algorithm HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\nS: N×N asset correlation matrix.\nD: N×N asset distance matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser._hcluster","page":"Clustering","title":"PortfolioOptimiser._hcluster","text":"_hcluster(ca::HAC, port::HCPortfolio, hclust_opt::HCOpt = HCOpt())\n\nUse Clustering.hclust to hierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: linkage for Clustering.hclust.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser._hcluster-2","page":"Clustering","title":"PortfolioOptimiser._hcluster","text":"_hcluster(ca::DBHT, port::HCPortfolio, hclust_opt::HCOpt = HCOpt())\n\nUse DBHTs to hierarchically cluster the assets in a hierarchical portfolio HCPortfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: [DBHT] options for clustering with DBHTs.\nport: hierarchical clustering portfolio HCPortfolio.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Optimisation/ObjectiveFunctions/#Objective-functions","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#Public","page":"Objective functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MaxRet","page":"Objective functions","title":"PortfolioOptimiser.MaxRet","text":"struct MaxRet <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MinRisk","page":"Objective functions","title":"PortfolioOptimiser.MinRisk","text":"struct MinRisk <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Sharpe","page":"Objective functions","title":"PortfolioOptimiser.Sharpe","text":"@kwdef mutable struct Sharpe{T1 <: Real} <: ObjectiveFunction\n    rf::T1 = 0.0\nend\n\nMaximum risk-adjusted return (Sharpe) ratio objective function.\n\nParameters\n\nrf: risk free rate.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Utility","page":"Objective functions","title":"PortfolioOptimiser.Utility","text":"@kwdef mutable struct Utility{T1 <: Real} <: ObjectiveFunction\n    l::T1 = 2.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#Private","page":"Objective functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.ObjectiveFunction","page":"Objective functions","title":"PortfolioOptimiser.ObjectiveFunction","text":"abstract type ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"EditURL = \"../../../examples/7_worst_case_statistics.jl\"","category":"page"},{"location":"examples/7_worst_case_statistics/#Example-7:-Worst-case-statistics","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This example focuses on the wc_statistics! used in the WC optimisation type of Portfolio.","category":"page"},{"location":"examples/7_worst_case_statistics/#7.1-Downloading-the-data","page":"Example 7: Worst case statistics","title":"7.1 Downloading the data","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables, Random\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/7_worst_case_statistics/#7.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 7: Worst case statistics","title":"7.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/7_worst_case_statistics/#7.3-Effect-of-the-Worst-Case-Mean-Variance-statistics","page":"Example 7: Worst case statistics","title":"7.3 Effect of the Worst Case Mean Variance statistics","text":"","category":"section"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The previous tutorial showed how to perform worst case mean variance optimisations. This one goes into more detail on computing the uncertainty sets needed for this optimisation type.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"The function in charge of doing so is wc_statistics! via the WCType type. Consult the docs for details.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"There are a lot of combinations for this, so we will not be showing an exhaustive list. We will explore a representative subset. Since we used the default values for our previous tutorial we will explore a few of the other options.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll first use the default statistics for computing the optimised worst case mean variance portfolio.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"# Set random seed for reproducible results.\nRandom.seed!(123)\nwc_statistics!(portfolio)","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll use the box set for the expected returns vector and the elliptical set for the covariance matrix. We'll maximise the risk-adjusted return ratio.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"type = WC(; mu = Box(), cov = Ellipse())\nobj = Sharpe(3.5 / 100 / 252)\nw1 = optimise!(portfolio; type = type, obj = obj);\nnothing #hide","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"WCType can produce a wealth of uncertainty sets depending on the user provided parameters. You can experiment by changing the values of wc and computing the statistics again.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"We'll now use a completely different set of parameters for computing the worst case statistics, but we will optimise the same problem.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"wc = WCType(; cov_type = PortCovCor(; ce = CorGerber1(; normalise = true)),\n            mu_type = MuBOP(), box = NormalWC(), ellipse = ArchWC(), k_sigma = KNormalWC(),\n            k_mu = KGeneralWC(), diagonal = false)\nwc_statistics!(portfolio, wc)\nw2 = optimise!(portfolio; type = type, obj = obj)\n\npretty_table(DataFrame(; tickers = w1.tickers, w1 = w1.weights, w2 = w2.weights);\n             formatters = fmt1)","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"When compared to the previous tutorial, the takeaway here is that the type of uncertainty set used has much more of an impact on the results of the optimisation 6.4 Optimising the portfolio than the parameters used to compute the worst case sets. However, more robust statistics will produce more robust uncertainty sets.","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"","category":"page"},{"location":"examples/7_worst_case_statistics/","page":"Example 7: Worst case statistics","title":"Example 7: Worst case statistics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/RiskMeasureStatistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasureStatistics/#Public","page":"Statistics","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasureStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"RiskMeasures/Functions/RiskStatistics.jl\"]","category":"page"},{"location":"RiskMeasures/RiskMeasureStatistics/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Statistics","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                         X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                         assets::AbstractVector = Vector{String}(undef, 0),\n                         F::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                         f_assets::AbstractVector = Vector{String}(undef, 0),\n                         B::DataFrame = DataFrame(),\n                         regression_type::RegressionType = FReg(),\n                         V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                         SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                         delta::Real = 1e-6, kwargs...)\n\nCompute the factor risk contribution for an AbstractRiskMeasure and asset weight vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: Na×1 vector of asset weights.\nX: T×Na matrix of asset returns.\nassets: vector of asset names.\nF: T×Nf matrix of factor returns.\nf_assets: vector of factor names.\nB: loadings matrix.\nregression_type: regression type used for computing the loadings matrix.\nV: Na×Na matrix of sum of negative spectral slices of the coskewness.\nSV: Na×Na matrix of sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nkwargs: catch-all for any missing keyword arguments for calc_risk.\n\nOutputs\n\nrc_f: Nf×1 vector of risk contribution per factor.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasureStatistics/#PortfolioOptimiser.risk_bounds-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector, AbstractVector}","page":"Statistics","title":"PortfolioOptimiser.risk_bounds","text":"risk_bounds(rm::AbstractRiskMeasure, w1::AbstractVector, w2::AbstractVector;\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0), delta::Real = 1e-6,\n            scale::Bool = false, kwargs...)\n\nCompute the risk bounds for an AbstractRiskMeasure and pair of asset weight vectors.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw1: N×1 vector of asset weights for lower bound.\nw2: N×1 vector of asset weights for upper bound.\nX: T×N matrix of asset returns.\nV: N×N matrix of sum of negative spectral slices of the coskewness.\nSV: N×N matrix of sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the Equal risk measure.\nscale:\nif true: divides the kurtosis and semi kurtosis by 2, used in risk_contribution.\nkwargs: catch-all for any missing keyword arguments for calc_risk.\n\nOutputs\n\nr1: lower risk bound.\nr2: upper risk bound.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasureStatistics/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Statistics","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                  X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  delta::Real = 1e-6, marginal::Bool = false, kwargs...)\n\nCompute the asset risk contribution for an AbstractRiskMeasure and asset weight vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: N×1 vector of asset weights.\nX: T×N matrix of asset returns.\nV: N×N matrix of sum of negative spectral slices of the coskewness.\nSV: N×N matrix of sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nmarginal:\nif true: compute the marginal risk contribution.\nelse: compute the risk by contribution by multiplying the marginal risk by the asset weight.\nkwargs: catch-all for any missing keyword arguments for calc_risk.\n\nOutputs\n\nrc: N×1 vector of risk contribution per asset.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasureStatistics/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Statistics","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(rm::AbstractRiskMeasure, w::AbstractVector;\n             mu::AbstractVector = Vector{Float64}(undef, 0),\n             X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n             V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n             SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0), delta::Real = 1e-6,\n             rf::Real = 0.0, kelly::Bool = false)\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure and asset weights vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: N×1 vector of asset weights.\nmu: N×1 vector of expected returns.\nX: T×N matrix of asset returns.\nV: N×N matrix of sum of negative spectral slices of the coskewness.\nSV: N×N matrix of sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasureStatistics/#Private","page":"Statistics","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasureStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"RiskMeasures/Functions/RiskStatistics.jl\"]","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"EditURL = \"../../../examples/1_basic_use.jl\"","category":"page"},{"location":"examples/1_basic_use/#Example-1:-Basic-use","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This example should serve as a minimum working example for using PortfolioOptimiser.jl.","category":"page"},{"location":"examples/1_basic_use/#1.1-Downloading-the-data","page":"Example 1: Basic use","title":"1.1 Downloading the data","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"PortfolioOptimiser does not ship with supporting packages that are not integral to its internal functionality. This means users are responsible for installing packages to load and download data, JuMP-compatible solvers, pretty printing, and the plotting functionality is an extension which requires GraphRecipes and StatsPlots.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Which means we need a few extra packages to be installed. Uncomment the first two lines if these packages are not in your Julia environment.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"PrettyTables\"])\nusing Clarabel, DataFrames, Dates, GraphRecipes, HiGHS, YFinance, PortfolioOptimiser,\n      PrettyTables, Statistics, StatsBase, StatsPlots, TimeSeries\n\n# These are helper functions for formatting tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\nfmt2 = (v, i, j) -> begin\n    if j == 5\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    else\n        return v\n    end\nend;\n\nfmt3 = (v, i, j) -> begin\n    if j ∈ (2, 6, 7)\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    else\n        return v\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We define our list of meme stonks and a generous date range. We will only be keeping the adjusted close price. In practice it doesn't really matter because we're using daily data.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"function stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))","category":"page"},{"location":"examples/1_basic_use/#1.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 1: Basic use","title":"1.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Now that we have our data we can instantiate a portfolio. We also need to give it an optimiser for the continuous optimisation and an MIP optimiser for the discrete allocation of funds, we'll use Clarabel.jl and HiGHS.jl.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The constructor automatically computes the returns, sets the assets, and timestamps if you give it the price data. Users can also provide these directly, the timestamps aren't needed anywhere but plotting so they are not required. This structure contains a lot of data. But we will only show the basics for now.","category":"page"},{"location":"examples/1_basic_use/#1.3-Computing-statistics","page":"Example 1: Basic use","title":"1.3 Computing statistics","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are myriad of statistics and methods for computing said statistics. Users can define their own methods with Julia's multiple dispatch and StatsAPI.jl interface.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We will do a simple Mean-Variance optimisation, using the simplest methods for computing the expected returns vector and covariance matrices. Later tutorials will go more in-depth.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# T is the number of observations, N the number of assets.\nT, N = size(portfolio.returns)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Simple mean, it also accepts weights for computing weighted means. This will compute the weighted mean for lambda = 1/T.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"mu_type = MuSimple(;)\n# mu_type = MuSimple(; w = eweights(1:T, 1/T, scale=true))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"PortCovCor is quite special because it accepts covariance estimators, methods for fixing non positive definite matrices, denoising methods, and a graph-based approach for computing the covariance by identifying related asset groups.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The estimators are all different, and PortfolioOptimiser offers a few of them. They all have their own parameters. They all subtype StatBase.CovarianceEstimator, meaning PortCovCor works with external estimators such as those in CovarianceEstimation.jl, as well as user-defined methods.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This defaults to the full sample covariance estimator. We can provide the estimator with some weights to compute a weighted covariance too. We'll leave other estimators for future tutorials. For the time being, feel free to play around with the weights. There is some nesting involved, but that is due to the fact that we are composing various estimators to get our desired outcome.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"cov_type = PortCovCor(;)\n# cov_type = PortCovCor(;\n#                       ce = CovFull(; ce = StatsBase.SimpleCovariance(; corrected = false),\n#                                    w = eweights(1:T, 1 / T; scale = true)))","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We can then call asset_statistics! which computes all the asset statistics. It will also compute other statistics by default but we can set some flags to stop this from happening.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"asset_statistics!(portfolio; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false);\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/#1.4-Optimising-the-portfolio","page":"Example 1: Basic use","title":"1.4 Optimising the portfolio","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We will only look at a vanilla optimisation in this tutorial.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are quite a few risk measures, some require statistics we have not computed, others don't require any precomputed statistics at all. You can see the risk measure has a few internal parameters, they all do. We'll only show the classic mean variance risk measure, but you can uncomment each of the next few lines in turn and try some of the others.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"rm = SD() # Variance\n# rm = MAD() # Mean absolute deviation\n# rm = SSD() # Semi variance\n# rm = CVaR() # Critical Value at Risk\n# rm = CDaR() # Critical Drawdown at Risk","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are four objective functions we can use they all serve their purpose but for the tutorial, we'll be minimising the risk. Try the other objective functions and change the parameters to see their effects.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"obj = MinRisk()\n# obj = MaxRet() # Only useful for maximising the return while constraining the risk to be under a given value.\n# obj = Utility(; l = 2) # Maximises the utility = return - l * risk\n# obj = Sharpe(; rf = 3.5/100/254) # Maximises the sharpe ratio = (mu - rf)/risk, where mu is the expected return.\n\nw1 = optimise!(portfolio; rm = rm, obj = obj)\npretty_table(w1; formatters = fmt1)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We now have the portfolio for these assets and this period of time that minimises the variance. PortfolioOptimiser also lets you constrain the optimisation such that you have a minimum required return. However this will be explored in a later tutorial.","category":"page"},{"location":"examples/1_basic_use/#1.5-Asset-allocation","page":"Example 1: Basic use","title":"1.5 Asset allocation","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"For now we want to know how many assets we need to buy, this only gives us the mathematically optimal weights. We have a function for this. Given that we used the price data directly, Portfolio will take the last entry in the prices and use that as the current price for each asset. You can of course change this, or directly provide them as a vector to the allocate! function, though the order of the prices must be the same as the original asset order.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"For this example, lets say we have 1000 dollars. Change this value to see how the allocation changes. The larger it becomes, the closer they get to the optimal value.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"investment = 1000;\nnothing #hide","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"There are two methods we can use for allocating. The one we have chosen uses mixed-integer linear programming to discretly allocate assets. This however can only allocate discrete quantities. The second method is a greedy algorithm that allocates based on which asset has the highest difference between its mathematical optimum and current weight, it only tries to allocate based on whether you can afford it. However, it can allocate fractional shares up to an integer multiple of the value in rounding (defaults to 1). Given it is a greedy algorithm, it is not guaranteed to give an optimum solution, but will always find a solution, unlike the LP() method which can fail. Also the higher the investment, the more accurate it gets.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"method = LP()\n# method = Greedy(; rounding=0.5)\n\nw2 = allocate!(portfolio; investment = investment)\npretty_table(w2; formatters = fmt2)","category":"page"},{"location":"examples/1_basic_use/#1.6-Plotting-the-portfolio","page":"Example 1: Basic use","title":"1.6 Plotting the portfolio","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This section is the one most bound to change as the plotting functions are still somewhat preliminary. There are a variety of plots but we'll only show the most basic ones. By default, the plots will take the mathematically optimal portfolio. Lets see what it looks like.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns per asset.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; per_asset = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_bar(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the returns histogram.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_hist(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio range of returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_range(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio drawdown.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_drawdown(portfolio)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This is, however not our actual portfolio, it is the optimal one. To plot the allocated portfolio we need to know the key it is stored under and pass that on to the plotting functions along with a flag. The key is the symbol composed of the allocation method, in this case LP() and the portfolio type, which is something we have not discussed, but defaults to Trad(), as a Symbol.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Side by side optimal portfolio vs allocated portfolio.\npretty_table(hcat(portfolio.optimal[:Trad],\n                  DataFrames.rename!(portfolio.alloc_optimal[:LP_Trad][!, 2:end],\n                                     Dict(:weights => :alloc_weights)),\n                  DataFrame(;\n                            weight_diff = portfolio.optimal[:Trad].weights -\n                                          portfolio.alloc_optimal[:LP_Trad].weights));\n             formatters = fmt3)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio returns per asset.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_returns(portfolio; type = :LP_Trad, allocated = true, per_asset = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_bar(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the returns histogram.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_hist(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the portfolio range of returns.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_range(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot portfolio drawdown.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_drawdown(portfolio; type = :LP_Trad, allocated = true)","category":"page"},{"location":"examples/1_basic_use/#1.7-Efficient-frontier","page":"Example 1: Basic use","title":"1.7 Efficient frontier","text":"","category":"section"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"We have seen how you can optimise a single portfolio, but in reality there are an infinite number of optimal portfolios which exist along what is called the efficient frontier. We can compute and view this frontier, as well as viewing its composition very easily using PortfolioOptimiser.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The idea is to first compute the minimum risk and maximum return portfolios. From these we generate a range of risks and returns. We then loop over all these values. At each step we maximise the expected return whilst constraining the risk to be lower than or equal to current risk value in the range of risks. If an optimisation fails, we instead minimise the risk whilst constraining the expected return to be bigger than or equal to the corresponding value in the range of expected returns. We save the results for each step. We can then use these to plot the efficient frontier and its composition at each point.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Compute 50 points in the efficient frontier.\npoints = 50\nfrontier = efficient_frontier!(portfolio; rm = rm, points = points)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot the efficient frontier.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_frontier(portfolio; rm = rm)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"Plot frontier asset composition.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"plt = plot_frontier_area(portfolio; rm = rm)","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"The efficient frontier is outputted by efficient_frontier!, but also saves it in the portfolio instance. It is a dictionary whose keys are the symbols of the risk measure used to compute the efficient frontier. We've only computed the efficient frontier for the SD, so we can access the efficient frontier data by indexing into the :SD key. The documentation for Portfolio contains more details.","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"As the last demo we will display a heatmap of the portfolio composition of the efficient frontier in SD().","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"# Check if the sharpe ratio is found in the frontier.\nif portfolio.frontier[:SD][:sharpe]\n    risks = portfolio.frontier[:SD][:risks]\n    weights = DataFrames.rename(portfolio.frontier[:SD][:weights],\n                                Symbol.(1:length(risks)) .=>\n                                    Symbol.(round.(risks * 100, digits = 2)))\n    idx = sortperm(portfolio.frontier[:SD][:risks])\n    weights = weights[!, [1; idx .+ 1]]\n    risks = risks[idx]\nelse\n    weights = Matrix(portfolio.frontier[:SD][:weights])\n    risks = portfolio.frontier[:SD][:risks]\nend\n\nplot(Matrix(weights[!, 2:end]); st = :heatmap, clim = (0, 1),\n             yticks = (1:N, portfolio.assets), yflip = true,\n             xticks = (1:3:length(risks), round.(risks * sqrt(252), digits = 2)[1:3:end]),\n             xrotation = 60, xtickfontsize = 10, xlabel = \"Expected Anualised Risk (SD)\",\n             color = cgrad(:Spectral), size = (600, 600), colorbar_title = \"\\nAsset Weight\")","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"","category":"page"},{"location":"examples/1_basic_use/","page":"Example 1: Basic use","title":"Example 1: Basic use","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Miscelaneous","page":"Miscelaneous","title":"Miscelaneous","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Public","page":"Miscelaneous","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Private","page":"Miscelaneous","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_first_rm-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous","title":"PortfolioOptimiser.get_first_rm","text":"get_first_rm(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet the first risk measure, used in efficient_frontier!.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_rm_symbol-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous","title":"PortfolioOptimiser.get_rm_symbol","text":"get_rm_symbol(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet a symbol for the risk measure(s). If multiple measures are given, they are concatenated by underscores.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractDict, Union{Nothing, AbstractMatrix{<:Real}}}","page":"Miscelaneous","title":"PortfolioOptimiser.set_rm_properties!","text":"set_rm_properties!(rm::AbstractRiskMeasure, solvers::AbstractDict,\n                   sigma::Union{Nothing, <:AbstractMatrix{<:Real}})\n\nSet properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, Bool, Bool}","page":"Miscelaneous","title":"PortfolioOptimiser.unset_set_rm_properties!","text":"unset_set_rm_properties!(rm::AbstractRiskMeasure, solver_flag::Bool, sigma_flag::Bool)\n\nUnset properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Network","page":"Network","title":"Network","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/#Public","page":"Network","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.centrality_vector-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.centrality_vector","text":"centrality_vector(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistMethod = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the centrality vector centrality_vector. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nC: N×1 centrality vector.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.cluster_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.cluster_matrix","text":"cluster_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nCompute the centrality vector cluster_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nhclust_alg: method for hierarhically clustering assets HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nC: N×N cluster-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connected_assets-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connected_assets","text":"connected_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                 cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                 dist_type::DistMethod = DistCanonical(),\n                 network_type::NetworkType = MST())\n\nCompute the percentage of the portfolio comprised of connected assets connected_assets via a connection-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nc: percentage of the portfolio comprised of assets connected via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connection_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connection_matrix","text":"connection_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistMethod = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the connection matrix connection_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nnetwork_type: method for computing the asset network NetworkType.\n\nOutputs\n\nC: N×N connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.related_assets-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.related_assets","text":"related_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistMethod = DistCanonical(),\n               hclust_alg::HClustAlg = HAC(), hclust_opt::HCOpt = HCOpt())\n\nCompute the percentage of the portfolio comprised of related assets  related_assets via a cluster-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: method for computing the distance matrix DistMethod.\nhclust_alg: method for hierarhically clustering assets HClustAlg.\nhclust_opt: options for determining the number of clusters HCOpt.\n\nOutputs\n\nc: percentage of the portfolio comprised of related assets via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Private","page":"Network","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"Optimisation/OptimisationSetup/#Setup-functions","page":"Setup functions","title":"Setup functions","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Public","page":"Setup functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"Optimisation/OptimisationSetup/#Private","page":"Setup functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"Contents/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"Contents/","page":"Index","title":"Index","text":"","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#Black-Litterman-models","page":"Black Litterman models","title":"Black Litterman models","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#Public","page":"Black Litterman models","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.ABLType","page":"Black Litterman models","title":"PortfolioOptimiser.ABLType","text":"@kwdef mutable struct ABLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool = true\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::PosdefFix = PosdefNearest()\n    denoise::Denoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Augmented Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nbmPi_a = begincases\n                    deltabeginbmatrix\n                      mathbfSigma\n                      mathbfSigma_F mathbfB^intercal\n                      endbmatrix bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases\nmathbfP_a =  beginbmatrix\n                      mathbfP  mathbf0\n                      mathbf0  mathbfP_F\n                    endbmatrix\nbmQ_a =  beginbmatrix\n                bmQ\n                bmQ_F\n                endbmatrix\nmathbfSigma_a =  beginbmatrix\n                            mathbfSigma  mathbfB mathbfSigma_F\n                            mathbfSigma_F mathbfB^intercal  mathbfSigma_F\n                          endbmatrix\nmathbfOmega_a =  beginbmatrix\n                            mathbfOmega  mathbf0\n                            mathbf0  mathbfOmega_F\n                          endbmatrix\nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\nmathbfM_a = left left(tau  mathbfSigma_a right)^-1 + mathbfP_a^intercal mathbfOmega_a^-1 mathbfP_aright^-1\nbmPi_mathrmABL = mathbfM_a leftleft(tau mathbfSigma_aright)^-1 bmPi_a + mathbfP_a^intercal mathbfOmega_a^-1 mathbfQ_a right\ntau = dfrac1T\nbmmu_mathrmABL = bmPi_mathrmABL + r\nmathbfSigma_mathrmABL = mathbfSigma_a + mathbfM_a\nendalign\n\nWhere:\n\nbmPi_a:\nif error is true: is the Na×1 augmented equilibrium excess returns vector.\nelse: is the Na×1 historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the Na×Na asset covariance matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfP_a: is the (Nva+Nvf)×(Na+Nf) augmented views matrix. The zeros pad the matrix so all columns and rows are of equal length.\nmathbfP: is the Nva×Na asset views matrix.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nbmQ_a: is the (Nva+Nvf)×1 augmented views returns vector.\nbmQ: is the Nva×1 asset views returns vector.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_a: is the (Na+Nf)×(Na+Nf) augmented covariance matrix.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfOmega_a: is the (Nva+Nvf)×(Nva+Nvf) covariance matrix of the errors of the augmented views.\nmathbfOmega: is the Nva×Nva covariance matrix of the errors of the asset views.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nmathbfM_a: is an (Na+Nf)×(Na+Nf) intermediate covariance matrix.\nbmPi_mathbfABL: is the Na×1 equilibrium excess returns vector after being adjusted by the augmented views.\nT: is the number of returns observations.\nbmmu_mathbfABL: is the Na×1 vector of asset expected returns obtained via the Augmented Black-Litterman model.\nmathbfSigma_mathrmABL: is the Na×Na asset covariance matrix obtained via the Augmented Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: method for fixing non positive Augmented Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Augmented Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Augmented Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BBLType","page":"Black Litterman models","title":"PortfolioOptimiser.BBLType","text":"mutable struct BBLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool\n    error::Bool\n    delta::Union{<:Real, Nothing}\n    rf::T1\n    ve::StatsBase.CovarianceEstimator\n    var_w::Union{<:AbstractWeights, Nothing}\n    posdef::PosdefFix\n    denoise::Denoise\n    logo::AbstractLoGo\nend\n\nDefines the parameters for computing the Bayesian Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nmathbfSigma = mathbfB mathbfSigma_F mathbfB^intercal + mathbfSigma_epsilon \nmathbfSigma_epsilon = begincasesmathrmDiagonalleft(mathrmvarleft(mathbfX - mathbfF mathbfB^intercal mathrmdims = 1right)right) quad mathrmif error = true\nmathbf0 quad mathrmif error = false\nendcases\noverlinemathbfSigma_F = left(mathbfSigma_F^-1 + mathbfP_F^intercal mathbfOmega_F^-1 mathbfP_Fright)^-1\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\ntau = dfrac1T\noverlinebmPi_F = overlinemathbfSigma_F left(mathbfSigma_F^-1 bmPi_F + mathbfP_F^intercal mathbfOmega_F^-1 bmQ_Fright)\nbmPi_F = bmmu_F - r\nmathbfSigma_mathrmBF = mathbfSigma^-1 mathbfB left( overlinemathbfSigma_F + mathbfB^intercal mathbfSigma^-1 mathbfB right)^-1\nmathbfSigma_mathrmBLB = left(mathbfSigma^-1 - mathbfSigma_mathrmBF mathbfB^intercal mathbfSigma^-1right)^-1\nbmmu_mathrmBLB = mathbfSigma_mathrmBLB mathbfSigma_mathrmBF overlinemathbfSigma_F overlinebmPi_F + r\nendalign\n\nWhere:\n\nmathbfSigma: is the Na×Na estimated asset covariance matrix computed using the factor model.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfSigma_epsilon: is an Na×Na diagonal matrix constructed from the variances of the errors between the asset and estimated asset returns using the factor model.\nmathbfX: is the T×Na matrix of asset returns.\nmathbfF: is the T×Nf matrix of factor returns.\noverlinemathbfSigma_F: is the Nf×Nf posterior covariance matrix of the factors after adjusting by the factor views.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nT: is the number of returns observations.\noverlinebmPi_F: is the Nf×1 posterior equilibrium excess returns vector of the factors after adjusting by the factor views.\nbmPi_F: is the Nf×1 equilibrium excess returns vector of the factors.\nbmmu_F: is the Nf×1 factor expected returns vector.\nr: is the risk-free rate.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_mathrmBF: is an Na×Nf intermediate covariance matrix,.\nmathbfSigma_mathrmBLB: is the Na×Na posterior asset covariance matrix, aka the asset covariance matrix obtained via the Bayesian Black-Litterman model.\nbmmu_mathrmBLB: is the Na×1 posterior asset expected returns vector, aka the asset returns vector obtained via the Bayesian Black-Litterman model.\n\nParameters\n\nconstant:\nif true: the loadings matrix contains the constant term as its first column.\nelse: the loadings matrix does not contain the constant term.\nerror:\nif true: correct the estimated asset covariance matrix by adding the variances of the errors between the actual returns and factor estimated returns.\n\nnote: Note\nOnly useful when the factor model is based on a regression model.\n\ndelta: risk aversion factor.\nrf: risk free rate.\nve: StatsBase.CovarianceEstimator for computing the errors covariance.\nvar_w: optional weights for computing the errors covariance.\nposdef: method for fixing non positive Bayesian Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Bayesian Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Bayesian Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BLType","page":"Black Litterman models","title":"PortfolioOptimiser.BLType","text":"@kwdef mutable struct BLType{T1 <: Real} <: BlackLitterman\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::PosdefFix = PosdefNearest()\n    denoise::Denoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Black-Litterman model black_litterman. We define N as the number of assets, and Nv the number of asset views.\n\nbeginalign\nbmPi = begincases\n                    delta mathbfSigma bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases                            \nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfM = left left(tau  mathbfSigma right)^-1 + mathbfP^intercal mathbfOmega^-1 mathbfPright^-1\nbmPi_mathrmBL = mathbfM leftleft(tau mathbfSigmaright)^-1 bmPi + mathbfP^intercal mathbfOmega^-1 mathbfQ right\ntau = dfrac1T\nbmmu_mathrmBL = bmPi_mathrmBL + r\nmathbfSigma_mathrmBL = mathbfSigma + mathbfM\nendalign\n\nWhere:\n\nbmPi:\nif error is true: is N×1 the equilibrium excess returns vector.\nelse: is N×1 the historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the N×N asset covariance matrix.\nbmw: is the N×1 vector of benchmark asset weights.\nmathbfP: is the Nv×N asset views matrix.\nbmQ: is the Nv×1 asset views returns vector.\nmathbfOmega: is the Nv×Nv covariance matrix of the errors of the asset views.\nmathbfM: is an N×N intermediate covariance matrix, and M the number of assets.\nbmPi_mathbfBL: is the N×1 equilibrium excess returns after being adjusted by the views.\nT: is the number of returns observations.\nbmmu_mathbfBL: is the N×1 vector of asset expected returns obtained via the Black-Litterman model.\nmathbfSigma_mathrmBL: is the N×N asset covariance matrix obtained via the Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: method for fixing non positive Black-Litterman matrices PosdefFix.\ndenoise method for denoising the Black-Litterman covariance matrix Denoise.\nlogo: method for computing the LoGo Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.black_litterman-Tuple{BLType, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}","page":"Black Litterman models","title":"PortfolioOptimiser.black_litterman","text":"black_litterman(bl::BLType, X::AbstractMatrix, P::AbstractMatrix,\n                         Q::AbstractVector, w::AbstractVector;\n                         cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                         mu_type::MeanEstimator = MuSimple())\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Private","page":"Black Litterman models","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BlackLittermanFactor","page":"Black Litterman models","title":"PortfolioOptimiser.BlackLittermanFactor","text":"abstract type BlackLittermanFactor <: BlackLitterman end\n\nAbstract type for subtyping Black Litterman models.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser._bl_mu_cov_w-NTuple{13, Any}","page":"Black Litterman models","title":"PortfolioOptimiser._bl_mu_cov_w","text":"_mu_cov_w(tau, omega, P, Pi, Q, rf, sigma, delta, T, N, opt, cov_type, cov_flag = true)\n\nInternal function for computing the Black Litterman statistics as defined in black_litterman. See .\n\nInputs\n\ntau: variable of the same name in the Black-Litterman model.\nomega: variable of the same name in the Black-Litterman model.\nP: variable of the same name in the Black-Litterman model.\nPi: variable of the same name in the Black-Litterman model.\nQ: variable of the same name in the Black-Litterman model.\nrf: variable of the same name in the Black-Litterman model.\nsigma: variable of the same name in the Black-Litterman model.\ndelta: variable of the same name in the Black-Litterman model.\nT: variable of the same name in the Black-Litterman model.\nN: variable of the same name in the Black-Litterman model.\nopt: any valid instance of opt for .\ncov_type: any valid value from .\ncov_flag: whether the matrix is a covariance matrix or not.\n\nOutputs\n\nmu: asset expected returns vector obtained via the Black-Litterman model.\ncov_mtx: asset covariance matrix obtained via the Black-Litterman model.\nw: asset weights obtained via the Black-Litterman model.\nPi_: equilibrium excess returns after being adjusted by the views.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/#Public","page":"Statistics","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.asset_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.asset_statistics!","text":"asset_statistics!(port::AbstractPortfolio;\n                  cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cov::Bool = true, mu_type::MeanEstimator = MuSimple(),\n                  set_mu::Bool = true, kurt_type::KurtFull = KurtFull(),\n                  set_kurt::Bool = true, skurt_type::KurtSemi = KurtSemi(),\n                  set_skurt::Bool = true, skew_type::SkewFull = SkewFull(),\n                  set_skew::Bool = true, sskew_type::SkewSemi = SkewSemi(),\n                  set_sskew::Bool = true,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cor::Bool = true,\n                  dist_type::DistMethod = DistCanonical(),\n                  set_dist::Bool = true)\n\nCompute the asset statistics for a portfolio. See the argument types' docs for details. If a statistic requires another to be computed, the funciton will do so from the relevant estimator.\n\nThe set_* variables are flags for deciding whether or not to set the statistic. If a statistic's flag is false the statistic will not be set. Furthermore, if the flag is false and the statistic is not required by another one, it will not be computed.\n\nInputs\n\nport: portfolio AbstractPortfolio.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nset_cov: flag for setting port.cov\nmu_type: expected returns estimator MeanEstimator.\nset_mu: flag for setting port.mu\nkurt_type: cokurtosis matrix estimator KurtFull.\nset_kurt: flag for setting port.kurt.\nskurt_type: cokurtosis matrix estimator KurtSemi.\nset_skurt: flag for setting port.skurt.\nskew_type: coskew estimator SkewFull.\nset_skew: set port.skew and port.V.\nsskew_type: semi coskew estimator SkewSemi.\nset_sskew: set port.skew and port.SV.\n\nOnly relevant for HCPortfolio.\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\nset_cor: flag for setting port.cor.\ndist_type: method for computing the distance matrix DistMethod. asset_statistics! uses get_default_dist to ensure the computed distance is consistent with dist_type and either cor_type.ce or cor_type whichever is applicable.\nset_dist: flag for setting port.dist.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_factor_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_factor_statistics!","text":"black_litterman_factor_statistics!(port::Portfolio;\n                                   w::AbstractVector = port.bl_bench_weights,\n                                   B::Union{DataFrame, Nothing} = port.loadings,\n                                   P::Union{AbstractMatrix, Nothing} = nothing,\n                                   P_f::Union{AbstractMatrix, Nothing} = nothing,\n                                   Q::Union{AbstractVector, Nothing} = nothing,\n                                   Q_f::Union{AbstractVector, Nothing} = nothing,\n                                   factor_type::FactorType = FactorType(),\n                                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   mu_type::MeanEstimator = MuSimple(),\n                                   f_cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   f_mu_type::MeanEstimator = MuSimple(),\n                                   bl_type::BlackLittermanFactor = BBLType())\n\nCompute the Black Litterman factor model statistics. Na is the number of assets, Nva is the number of asset views, Nf is the number of factors, Nvf is the number of factors views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\nB: loadings matrix.\nif isempty(B): computes the loadings matrix using factor_type.\nP: Nva×Na matrix of asset views.\nP_f: Nvf×Nf matrix of factor views.\nQ: Nva×1 vector of asset views.\nQ_f: Nvf×1 vector of factor views.\nfactor_type: factor statistics estimator FactorType.\ncov_type: asset covariance estimator PortfolioOptimiserCovCor.\nmu_type: asset expected returns estimator MeanEstimator.\nf_cov_type: factor covariance estimator PortfolioOptimiserCovCor.\nf_mu_type: factor expected returns estimator MeanEstimator.\nbl_type: Black Litterman factor model estimator BlackLittermanFactor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_statistics!","text":"black_litterman_statistics!(port::Portfolio; P::AbstractMatrix, Q::AbstractVector,\n                            w::AbstractVector = port.bl_bench_weights,\n                            cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                            mu_type::MeanEstimator = MuSimple(),\n                            bl_type::BLType = BLType())\n\nCompute the factor statistics. N is the number of assets, Nv is the number of asset views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nP: Nv×N matrix of asset views.\nQ: Nv×1 vector of asset views.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\nbl_type: Black Litterman model estimator BLType.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.factor_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.factor_statistics!","text":"factor_statistics!(port::Portfolio; factor_type::FactorType = FactorType(),\n                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                   mu_type::MeanEstimator = MuSimple())\n\nCompute the factor statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nfactor_type: factor statistics estimator FactorType.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.wc_statistics!","page":"Statistics","title":"PortfolioOptimiser.wc_statistics!","text":"wc_statistics!(port::Portfolio, wc::WCType = WCType(); set_box::Bool = true,\n                        set_ellipse::Bool = true)\n\nCompute the worst case mean-variance statistics. Only used in WC optimisations. The set_* variables are used to compute and set the relevant statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nwc: worst-case mean-variance statistics estimator WCType.\nset_box:\nif true: compute and set the box uncertainty sets, port.cov_l, port.cov_u, port.d_mu.\nset_ellipse:\nif true: compute and set the elliptical uncertainty sets and parameters, port.cov_mu, port.cov_sigma, port.k_mu, port.k_sigma.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioStatistics/#Private","page":"Statistics","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"EditURL = \"../../../examples/6_worst_case_mv_portfolios.jl\"","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#Example-6:-Worst-case-Mean-Variance","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This example follows from previous ones. If something in the preamble is confusing, it is explained there.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This example focuses on the WC optimisation type of Portfolio.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.1-Downloading-the-data","page":"Example 6: Worst case Mean-Variance","title":"6.1 Downloading the data","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"CovarianceEstimation\", \"SparseArrays\"])\nusing Clarabel, CovarianceEstimation, DataFrames, Dates, GraphRecipes, HiGHS, YFinance,\n      PortfolioOptimiser, Statistics, StatsBase, StatsPlots, TimeSeries, LinearAlgebra,\n      PrettyTables, Random\n\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return if isa(v, Number)\n            \"$(round(v*100, digits=3)) %\"\n        else\n            v\n        end\n    end\nend;\n\nfunction stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets));\nnothing #hide","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.2-Instantiating-an-instance-of-[Portfolio](@ref).","page":"Example 6: Worst case Mean-Variance","title":"6.2 Instantiating an instance of Portfolio.","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"We'll compute basic statistics for this.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"portfolio = Portfolio(; prices = prices,\n                      # Continuous optimiser.\n                      solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       :params => Dict(\"verbose\" => false))),\n                      # MIP optimiser for the discrete allocation.\n                      alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true),\n                                                          :params => Dict(\"log_to_console\" => false))));\n\nasset_statistics!(portfolio)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.3-Worst-case-statistics","page":"Example 6: Worst case Mean-Variance","title":"6.3 Worst case statistics","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"In order to perform a worst case mean variance optimisation we need to compute uncertainty sets for the expected returns vector and covariance matrix. We can do this via wc_statistics!.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"For the purposes of this tutorial we'll use the defaults. We will explore the other options one can sue for computing the uncertainty sets in a subsequent tutorial.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# Set random seed for reproducible results.\nRandom.seed!(123)\nwc_statistics!(portfolio)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/#6.4-Optimising-the-portfolio","page":"Example 6: Worst case Mean-Variance","title":"6.4 Optimising the portfolio","text":"","category":"section"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"Having computed our worst case statistics, we can optimise the portfolio. The WC struct defines which set types to use in the worst case mean variance optimisation. WC defaults to using Box constraints for both the expected returns vector and covariance matrix.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"User-provided risk measures have no effect on this type of optimisation will only perform a mean variance optimisation with uncertainty sets.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This type of optimisation can take any PortfolioOptimiser.ObjectiveFunction.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"# User-provided risk measures have no effect.\nrm = CVaR()\n# Worst case mean-variance optimisation using default set types.\ntype = WC()\n# We'll maximise the risk-adjusted return ratio.\nobj = Sharpe(; rf = 3.5 / 100 / 252)\n\n# Box uncertainty set for the expected returns vector and covariance matrix.\nw1 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and box uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw2 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Box uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Box()\ntype.cov = Ellipse()\nw3 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw4 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\npretty_table(DataFrame(; tickers = w1.tickers, box_box = w1.weights, ellip_box = w2.weights,\n                       box_ellip = w3.weights, ellip_ellip = w4.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"As you can see, the type of constraint used can have a large impact on the results of the optimisation. This is accentuated by the fact that we maximised the risk-adjusted return ratio. We'll now minimise the risk, on which the uncertainty set for the expected returns vector has a smaller impact.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"type = WC()\n# We'll maximise the risk-adjusted return ratio.\nobj = MinRisk()\n\n# Box uncertainty set for the expected returns vector and covariance matrix.\nw5 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and box uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw6 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Box uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Box()\ntype.cov = Ellipse()\nw7 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\n# Ellipse uncertainty set for the expected returns vector and ellipse uncertainty set for the covariance matrix.\ntype.mu = Ellipse()\nw8 = optimise!(portfolio; type = type, rm = rm, obj = obj)\n\npretty_table(DataFrame(; tickers = w5.tickers, box_box = w5.weights, ellip_box = w6.weights,\n                       box_ellip = w7.weights, ellip_ellip = w8.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"It's also posible to disable the worst set constraint for the expected returns vector and covariance matrix independently. We'll disable them both and see that we recover the traditional mean variance optimisation.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"type = WC(; mu = NoWC(), cov = NoWC())\n\nobj = MinRisk()\nw9 = optimise!(portfolio; type = type, obj = obj)\nw10 = optimise!(portfolio; type = Trad(), obj = obj)\n\nobj = Sharpe(; rf = 3.5 / 100 / 252)\nw11 = optimise!(portfolio; type = type, obj = obj)\nw12 = optimise!(portfolio; type = Trad(), obj = obj)\n\npretty_table(DataFrame(; tickers = w9.tickers, nowc_risk = w9.weights,\n                       trad_risk = w10.weights, nowc_sharpe = w11.weights,\n                       trad_sharpe = w12.weights); formatters = fmt1)","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"We don't recover the weights of the sharpe ratio exactly because one of the risk-adjusted return constraints is slightly relaxed with respect to the traditional optimisation.","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"","category":"page"},{"location":"examples/6_worst_case_mv_portfolios/","page":"Example 6: Worst case Mean-Variance","title":"Example 6: Worst case Mean-Variance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ParameterEstimation/PosdefFix/#Fixing-non-positive-definite-matrices","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#Public","page":"Fixing non-positive definite matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.NoPosdef","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.NoPosdef","text":"struct NoPosdef <: PosdefFix end\n\nNon positive definite matrices will not be fixed in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefNearest","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefNearest","text":"@kwdef mutable struct PosdefNearest <: PosdefFix\n    method::NearestCorrelationMatrix.NCMAlgorithm = NearestCorrelationMatrix.Newton(;\n                                                                                    tau = 1e-12)\nend\n\nDefines which method from NearestCorrelationMatrix to use in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.posdef_fix!-Tuple{PortfolioOptimiser.PosdefFix, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.posdef_fix!","text":"posdef_fix!(method::PosdefFix, X::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/PosdefFix/#Private","page":"Fixing non-positive definite matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefFix","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefFix","text":"abstract type PosdefFix end\n\nAbstract type for subtyping methods for fixing non positive definite matrices in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser._posdef_fix!-Tuple{PosdefNearest, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser._posdef_fix!","text":"_posdef_fix!(method::PosdefNearest, X::AbstractMatrix)\n\nOverload this for other posdef fix methods.\n\n\n\n\n\n","category":"method"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"EditURL = \"../../../examples/0_not_financial_advice.jl\"","category":"page"},{"location":"examples/0_not_financial_advice/#Example-0:-Not-financial-advice","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This example goes over a sample workflow using PortfolioOptimiser.jl. I use a similar strategy myself. This is just an example of the things that can be done with the library.","category":"page"},{"location":"examples/0_not_financial_advice/#0.1-Downloading-the-data","page":"Example 0: Not financial advice","title":"0.1 Downloading the data","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"PortfolioOptimiser does not ship with supporting packages that are not integral to its internal functionality. This means users are responsible for installing packages to load and download data, JuMP-compatible solvers, pretty printing, and the plotting functionality is an extension which requires GraphRecipes and StatsPlots.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Which means we need a few extra packages to be installed. Uncomment the first two lines if these packages are not in your Julia environment.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# using Pkg\n# Pkg.add.([\"StatsPlots\", \"GraphRecipes\", \"YFinance\", \"Clarabel\", \"HiGHS\", \"PrettyTables\"])\nusing Clarabel, DataFrames, Dates, GraphRecipes, HiGHS, YFinance, PortfolioOptimiser,\n      PrettyTables, Statistics, StatsBase, StatsPlots, TimeSeries\n\n# These are helper functions for formatting tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j != 5\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We define our list of meme stonks and a generous date range. We will only be keeping the adjusted close price. In practice it doesn't really matter because we're using daily data.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"function stock_price_to_time_array(x)\n    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime\n    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\nassets = [\"AAL\", \"AAPL\", \"AMC\", \"BB\", \"BBY\", \"DELL\", \"DG\", \"DRS\", \"GME\", \"INTC\", \"LULU\",\n          \"MARA\", \"MCI\", \"MSFT\", \"NKLA\", \"NVAX\", \"NVDA\", \"PARA\", \"PLNT\", \"SAVE\", \"SBUX\",\n          \"SIRI\", \"STX\", \"TLRY\", \"TSLA\"]\nDate_0 = \"2019-01-01\"\nDate_1 = \"2023-01-01\"\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))","category":"page"},{"location":"examples/0_not_financial_advice/#0.2-Filter-worst-stocks","page":"Example 0: Not financial advice","title":"0.2 Filter worst stocks","text":"","category":"section"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"If we have hundreds or thousands of stocks, we should probably do some pruning of the worst stocks using a cheap method. For this we'll use the HERC optimisation type. We'll filter the stocks using a few different risk measures. The order matters here, as each risk measure will filter out the worst performing stocks for each iteration.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"First we need our filter functions.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# This tells us the bottom percentile we need to eliminate at each iteration so we have at most `x %` of the original stocks after `n` steps.\npercentile_after_n(x, n) = 1 - exp(log(x) / n)\n\nfunction filter_best(assets, rms, best, cov_type, cor_type)\n    # Copy the assets to a vector that will be shrunk at every iteration.\n    assets_best = copy(assets)\n    # Compute the bottom percentile we need to remove after each iteration.\n    q = percentile_after_n(best, length(rms))\n    # Loop over all risk measures.\n    for rm ∈ rms\n        hp = HCPortfolio(; prices = prices[Symbol.(assets_best)])\n        asset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type,\n                          set_kurt = false, set_skurt = false, set_mu = false,\n                          set_skew = isa(rm, Skew) ? true : false, set_sskew = false)\n        cluster_assets!(hp; hclust_opt = HCOpt(; k_method = StdSilhouette()))\n        w = optimise!(hp; type = HERC(), rm = rm)\n\n        if isempty(w)\n            continue\n        end\n\n        w = w.weights\n\n        # Only take the stocks above the q'th quantile at each step.\n        qidx = w .>= quantile(w, q)\n        assets_best = assets_best[qidx]\n    end\n    return assets_best\nend","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Now we can define the parameters for our filtering procedure.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# Risk measures.\nrms = [SD(), SSD(), CVaR(), CDaR(), Skew()]\n\n# Lets say we want to have 50% of all stocks at the end.\nbest = 0.5\n\n# Lets use denoised and detoned covariance and correlation types so we can get rid of market forces. We're using the normal covariance as it's not very expensive to compute and we've made it more robust by denoising and detoning.\ncovcor_type = PortCovCor(; ce = CovFull(), denoise = DenoiseFixed(; detone = true))\n\n# Filter assets to only have the best ones.\nassets_best = filter_best(assets, rms, best, covcor_type, covcor_type)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We can see that we end up with the best 11 stocks.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"assets_best","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We can now use fancier optimisations and statistics with the smaller stock universe.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"hp = HCPortfolio(; prices = prices[Symbol.(assets_best)],\n                 # Continuous optimiser.\n                 solvers = Dict(:Clarabel1 => Dict(:solver => Clarabel.Optimizer,\n                                                   :check_sol => (allow_local = true,\n                                                                  allow_almost = true),\n                                                   :params => Dict(\"verbose\" => false))),\n                 # MIP optimiser for the discrete allocation.\n                 alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                     :check_sol => (allow_local = true,\n                                                                    allow_almost = true),\n                                                     :params => Dict(\"log_to_console\" => false))))\n\ncovcor_type = PortCovCor(; ce = CorGerber1())\nmu_type = MuBOP()\nasset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type, mu_type = mu_type,\n                  set_kurt = false, set_skurt = false, set_skew = false, set_sskew = false)\ncluster_assets!(hp; hclust_opt = HCOpt(; k_method = TwoDiff()))","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"We'll use the nested clustering optimisation. We will also use the maximum risk adjusted return ratio objective function. We will also allocate the portfolio according to our availabe cash and the latest prices.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"w = optimise!(hp; rm = RLDaR(),\n              type = NCO(;\n                         # Risk adjusted return ratio objective function.\n                         opt_kwargs = (; obj = Sharpe(; rf = 3.5 / 100 / 252))))\n\n# Say we have 3000 dollars at our disposal to allocate the portfolio\nwa = allocate!(hp; type = :NCO, investment = 3000)\n\npretty_table(w; formatters = fmt1)\npretty_table(wa; formatters = fmt2)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"However, we can do one better, we can take the worst performing stocks as well and short them. Since we're starting from so few stocks we'll adjust the best percentage to only take the best 30% after all filters.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"function filter_worst(assets, rms, best, cov_type, cor_type)\n    assets_worst = copy(assets)\n    # Compute the bottom percentile we need to remove after each iteration.\n    q = percentile_after_n(best, length(rms))\n    # Loop over all risk measures.\n    for rm ∈ rms\n        hp = HCPortfolio(; prices = prices[Symbol.(assets_worst)])\n        asset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type,\n                          set_kurt = false, set_skurt = false, set_mu = false,\n                          set_skew = isa(rm, Skew) ? true : false, set_sskew = false)\n        cluster_assets!(hp; hclust_opt = HCOpt(; k_method = StdSilhouette()))\n        w = optimise!(hp; type = HERC(), rm = rm)\n\n        if isempty(w)\n            continue\n        end\n\n        w = w.weights\n\n        # Only take the stocks below the (1-q)'th quantile at each step.\n        qidx = w .<= quantile(w, 1 - q)\n        assets_worst = assets_worst[qidx]\n    end\n    return assets_worst\nend","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"Now we can define the parameters for our filtering procedures.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# Risk measures.\nrms = [SD(), SSD(), CVaR(), CDaR(), Skew()]\n\n# Lets say we want to have 50% of all stocks at the end, 30% of the best, and 20% of the worst.\nbest = 0.3\nworst = 0.2\n\n# Lets use denoised and detoned covariance and correlation types so we can get rid of market forces. We're using the normal covariance as it's not very expensive to compute and we've made it more robust by denoising and detoning.\ncovcor_type = PortCovCor(; ce = CovFull(), denoise = DenoiseFixed(; detone = true))\n\n# Filter assets to only have the best ones.\nassets_best = filter_best(assets, rms, best, covcor_type, covcor_type)\n\n# Filter assets to only have the worst ones.\nassets_worst = filter_worst(assets, rms, worst, covcor_type, covcor_type)\n\n# Lets join the best and worst tickers into a single vector.\nassets_best_worst = union(assets_best, assets_worst)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This time we'll make a market neutral portfolio using the NCO optimisation type.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"hp = HCPortfolio(; prices = prices[Symbol.(assets_best_worst)],\n                 # Continuous optimiser.\n                 solvers = Dict(:Clarabel1 => Dict(:solver => Clarabel.Optimizer,\n                                                   :check_sol => (allow_local = true,\n                                                                  allow_almost = true),\n                                                   :params => Dict(\"verbose\" => false))),\n                 # MIP optimiser for the discrete allocation.\n                 alloc_solvers = Dict(:HiGHS => Dict(:solver => HiGHS.Optimizer,\n                                                     :check_sol => (allow_local = true,\n                                                                    allow_almost = true),\n                                                     :params => Dict(\"log_to_console\" => false))))\n\ncovcor_type = PortCovCor(; ce = CorGerber1())\nmu_type = MuBOP()\nasset_statistics!(hp; cov_type = covcor_type, cor_type = covcor_type, mu_type = mu_type,\n                  set_kurt = false, set_skurt = false, set_skew = false, set_sskew = false)\ncluster_assets!(hp; hclust_opt = hclust_opt = HCOpt(; k_method = TwoDiff()))","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"For this we need to use the max ret objective and set the appropriate bounds on the asset weights.","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"# We need to set w_min and w_max weight constraints of the hierarchical clustering portfolio so the weights can be negative.\nhp.w_min = -1\nhp.w_max = 1\n\n# The short parameters for the portfolios optimised via NCO.\nshort = true\n\n# Absolute value of the sum of the short weights.\nshort_budget = 1\n\n# Sum of all the portfolio weights.\nbudget = 0\n\n# Upper bound for the value of each short weight.\nshort_u = 1\n\n# Upper bound for the value of each long weight.\nlong_u = 1\n\nw = optimise!(hp; rm = RLDaR(),\n              type = NCO(;\n                         # Allow shorting in the sub portfolios, as well as the synthetic portfolio optimised by NCO.\n                         # We also set the the values of `short_u` and `long_u` to be equal to 1.\n                         port_kwargs = (; short = short, budget = budget,\n                                        short_budget = short_budget, long_u = long_u,\n                                        short_u = short_u),\n                         # Max return objective.\n                         opt_kwargs = (; obj = MaxRet())\n                         #\n                         )\n              #\n              )\n\nwa = allocate!(hp; type = :NCO, investment = 3000, short = short, budget = budget,\n               short_budget = short_budget)\n\npretty_table(w; formatters = fmt1)\npretty_table(wa; formatters = fmt2)","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"","category":"page"},{"location":"examples/0_not_financial_advice/","page":"Example 0: Not financial advice","title":"Example 0: Not financial advice","text":"This page was generated using Literate.jl.","category":"page"}]
}
