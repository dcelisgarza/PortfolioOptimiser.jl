var documenterSearchIndex = {"docs":
[{"location":"Optimisation/OptimisationSetup/#Setup-functions","page":"Setup functions","title":"Setup functions","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Public","page":"Setup functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"Optimisation/OptimisationSetup/#Private","page":"Setup functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/","page":"Setup functions","title":"Setup functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationSetup.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationSetup.jl\"]","category":"page"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Miscelaneous","page":"Miscelaneous","title":"Miscelaneous","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Public","page":"Miscelaneous","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Private","page":"Miscelaneous","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/","page":"Miscelaneous","title":"Miscelaneous","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Functions/ParameterEstimationMiscFunctions.jl\"]\n","category":"page"},{"location":"Portfolio/PortfolioTypes/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#Public","page":"Types","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"mutable struct Portfolio{ast, dat, r, tfa, tfdat, tretf, l, lo, s, us, ul, nal, nau, naus,\n                         mnak, mnaks, rb, to, kte, blbw, ami, bvi, rbv, frbv, nm, amc, bvc,\n                         ler, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv, tsskew, tsv,\n                         tmuf, tcovf, trfm, tmufm, tcovfm, tmubl, tcovbl, tmublf, tcovblf,\n                         tcovl, tcovu, tcovmu, tcovs, tdmu, tkmu, tks, topt, tlim, tfront,\n                         tsolv, tf, tmod, tlp, taopt, talo, tasolv, taf, tamod} <:\n               AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    f_assets::tfa\n    f_timestamps::tfdat\n    f_returns::tretf\n    loadings::l\n    regression_type::lo\n    short::s\n    short_lb::us\n    long_ub::ul\n    num_assets_l::nal\n    num_assets_u::nau\n    num_assets_u_scale::naus\n    max_num_assets_kurt::mnak\n    max_num_assets_kurt_scale::mnaks\n    rebalance::rb\n    turnover::to\n    tracking_err::kte\n    bl_bench_weights::blbw\n    a_mtx_ineq::ami\n    b_vec_ineq::bvi\n    risk_budget::rbv\n    f_risk_budget::frbv\n    network_adj::nm\n    a_vec_cent::amc\n    b_cent::bvc\n    mu_l::ler\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    f_mu::tmuf\n    f_cov::tcovf\n    fm_returns::trfm\n    fm_mu::tmufm\n    fm_cov::tcovfm\n    bl_mu::tmubl\n    bl_cov::tcovbl\n    blfm_mu::tmublf\n    blfm_cov::tcovblf\n    cov_l::tcovl\n    cov_u::tcovu\n    cov_mu::tcovmu\n    cov_sigma::tcovs\n    d_mu::tdmu\n    k_mu::tkmu\n    k_sigma::tks\n    optimal::topt\n    limits::tlim\n    frontier::tfront\n    solvers::tsolv\n    fail::tf\n    model::tmod\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a traditional portfolio. Na is the number of assets, and Nf is the number of factors. For details on how some of these parameters are computed see asset_statistics!, wc_statistics!, factor_statistics!, black_litterman_statistics!, and black_litterman_factor_statistics!.\n\nParameters\n\nassets: Na×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×Na matrix of asset returns.\nf_assets: Nf×1 vector of factor names.\nf_timestamps: T×1 vector of factor returns timestamps.\nf_returns: T×Nf matrix of asset returns.\nloadings: loadings matrix for working with factor models.\nregression_type: RegressionType used for computing the loadings matrix.\nshort:\nif true: shorting is enabled.\nelse: long-only portfolio.\nshort_lb: upper bound for the absolute value of the sum of the negative weights.\nlong_ub: upper bound for the sum of the positive weights.\nnum_assets_l: lower bound for the minimum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u: upper bound for the maximum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u_scale: scaling factor for the decision variable used for applying the num_assets_u constraint when optimising the Sharpe objective function.\nmax_num_assets_kurt: maximum number of assets to use the complete kurtosis model.\nif > 0: the approximate model will be used if the number of assets in the portfolio exceeds max_number_assets_kurt.\nmax_num_assets_kurt_scale: multipies Na to find the number of eigenvalues when computing the approximate kurtosis model, must be ∈ [1, Na].\nrebalance: AbstractTR for defining the portfolio rebalancing penalty.\nbeginalign\np_r = sumlimits_i=1^N r_i lvert w_i - b_i rvert\nendalign\nWhere:\np_r is the portfolio rebalancing penalty.\nN is the number of assets.\nr_i is the rebalancing penalty for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nturnover: AbstractTR for defining the asset turnover constraint.\nbeginalign\nlvert w_i - b_i rvert leq t_iquad forall i = 1ldotsN\nendalign\nWhere:\nt_i is the turnover constraint for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nN is the number of assets.\ntracking_err: TrackingErr for defining the tracking error constraint.\nbeginalign\nleftlVert dfracmathbfX bmw - bmbT - 1 rightrVert_2 leq epsilon\nendalign\nWhere:\nlVert cdot rVert_2 is the L2 norm.\nmathbfX is the T times N matrix of asset returns.\nT is the number of returns observations.\nN is the number of assets.\nbmw is the N times 1 vector of asset weights.\nbmb is the T times 1 vector of benchmark returns.\nepsilon is the tracking error.\nbl_bench_weights: benchmark weights for Black-Litterman models BlackLittermanClass.\na_mtx_ineq: C×N matrix of asset weight linear constraints.\nif isempty: the constraint is not set.\nb_vec_ineq: C×1 vector of asset weight linear constraints.\nif isempty: the constraint is not set.\nThe linear weight constraint is defined as.\nbeginalign\nmathbfA bmw geq bmb\nendalign\nWhere:\nmathbfA is the CN matrix of asset weight linear constraints.\nbmb is the C1 vector of asset weight linear constraints.\nC is the number of constraints.\nN is the number of assets.\nrisk_budget: Na×1 vector of asset risk budgets.\nf_risk_budget: Nf×1 vector of factor risk budgets.\nnetwork_adj: AdjacencyConstraint for defining the asset network constraint. This can be defined in two ways, using an exact mixed-integer approach IP or an approximate semi-definite one SDP. See their docs for the constraint definition for each case.\nif NoAdj: the constraint is not set.\na_vec_cent: centrality vector for defining the centrality constraint.\nif isempty: the constraint is not set.\nb_cent: average centrality of the assets the portfolio.\nif isinf: the constraint is not set.\nThe centrality constraint is defined as.\nbeginalign\nbmC cdot bmw = barc\nendalign\nWhere:\nbmw is the Ntimes 1 vector of asset weights.\nbmC is the N times 1 centrality vector of the asset adjacency matrix.\ncdot is the dot product.\nbarc is the desired average centrality measure of the portfolio.\nmu_l: lower bound for the expected return of the portfolio.\nif is Inf: the constraint is not applied.\nmu: Na×1 vector of asset expected returns.\ncov: Na×Na asset covariance matrix.\nkurt: Na^2×Na^2 cokurtosis matrix.\nskurt: Na^2×Na^2 semi cokurtosis matrix.\nL_2: (Na^2)×((Na^2 + Na)/2) elimination matrix.\nS_2: ((Na^2 + Na)/2)×(Na^2) summation matrix.\nskew: Na×Na^2 coskew matrix.\nV: Na×Na sum of the symmetric negative spectral slices of coskewness.\nsskew: Na×Na^2 semi coskew matrix.\nSV: Na×Na sum of the symmetric negative spectral slices of semi coskewness.\nf_mu: Nf×1 vector of factor expected returns.\nf_cov: Nf×Nf factor covariance matrix.\nfm_returns: T×Na factor model adjusted returns matrix.\nfm_mu: Na×1 factor model adjusted asset expected returns.\nfm_cov: Na×Na factor model adjusted asset covariance matrix.\nbl_mu: Na×1 Black Litterman model adjusted asset expected returns.\nbl_cov: Na×Na Black Litterman model adjusted asset covariance matrix.\nblfm_mu: Na×1 Black Litterman factor model adjusted asset expected returns.\nblfm_cov: Na×Na Black Litterman factor model adjusted asset covariance matrix.\ncov_l: Na×Na lower bound for the worst case covariance matrix.\ncov_u: Na×Na upper bound for the worst case covariance matrix.\ncov_mu: Na×Na matrix of the estimation errors of the asset expected returns vector set.\ncov_sigma: Na×Na matrix of the estimation errors of the asset covariance matrix set.\nd_mu: absolute deviation of the worst case upper and lower asset expected returns vectors.\nk_mu: distance parameter of the uncertainty in the asset expected returns vector for the worst case optimisation.\nk_sigma: distance parameter of the uncertainty in the asset covariance matrix for the worst case optimisation.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nlimits: collection capable of storing key value pairs for storing the minimal and maximal risk portfolios.\nfrontier: collection capable of storing key value pairs for containing points in the efficient frontier.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nmodel: JuMP.Model which defines the optimisation model.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"Portfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n            returns::DataFrame = DataFrame(),\n            ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            timestamps::AbstractVector = Vector{Date}(undef, 0),\n            assets::AbstractVector = Vector{String}(undef, 0),\n            f_prices::TimeArray = TimeArray(TimeType[], []),\n            f_returns::DataFrame = DataFrame(),\n            f_ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_timestamps::AbstractVector = Vector{Date}(undef, 0),\n            f_assets::AbstractVector = Vector{String}(undef, 0),\n            loadings::DataFrame = DataFrame(),\n            regression_type::Union{<:RegressionType, Nothing} = nothing,\n            short::Bool = false, short_lb::Real = 0.2, long_ub::Real = 1.0,\n            num_assets_l::Integer = 0, num_assets_u::Integer = 0,\n            num_assets_u_scale::Real = 100_000.0, max_num_assets_kurt::Integer = 0,\n            max_num_assets_kurt_scale::Integer = 2, rebalance::AbstractTR = NoTR(),\n            turnover::AbstractTR = NoTR(), tracking_err::TrackingErr = NoTracking(),\n            bl_bench_weights::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            a_mtx_ineq::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            b_vec_ineq::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            network_adj::AdjacencyConstraint = NoAdj(),\n            a_vec_cent::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            b_cent::Real = Inf, mu_l::Real = Inf,\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_returns::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            fm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            bl_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            bl_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            blfm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            blfm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_l::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_u::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_mu::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_sigma::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            d_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            k_mu::Real = Inf, k_sigma::Real = Inf, optimal::AbstractDict = Dict(),\n            limits::AbstractDict = Dict(), frontier::AbstractDict = Dict(),\n            solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n            model::JuMP.Model = JuMP.Model(),\n            latest_prices::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            alloc_optimal::AbstractDict = Dict(),\n            alloc_leftover::AbstractDict = Dict(),\n            alloc_solvers::AbstractDict = Dict(), alloc_fail::AbstractDict = Dict(),\n            alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for Portfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\ntimestamps: set timestamps.\nassets: set assets.\nf_prices: (T+1)×Nf TimeArray of factor prices.\nIf provided: will take precedence over f_returns, f_ret, f_timestamps, and f_assets because they will be automatically computed from f_prices.\nf_returns: T×Nf DataFrame of factor returns.\nIf provided: will take precedence over f_ret, f_timestamps, and f_assets because they will be automatically computed from returns.\nf_ret: set the f_returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of Portfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#Private","page":"Types","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/","page":"Types","title":"Types","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Types/PortfolioTypes.jl\"]","category":"page"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.AbstractPortfolio","page":"Types","title":"PortfolioOptimiser.AbstractPortfolio","text":"abstract type AbstractPortfolio end\n\nAbstract type for subtyping portfolios.\n\n\n\n\n\n","category":"type"},{"location":"Contents/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"Contents/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Constraints/NetworkConstraints/#Network-constraints","page":"Network constraints","title":"Network constraints","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#Public","page":"Network constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BetweennessCentrality","page":"Network constraints","title":"PortfolioOptimiser.BetweennessCentrality","text":"@kwdef mutable struct BetweennessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BoruvkaTree","page":"Network constraints","title":"PortfolioOptimiser.BoruvkaTree","text":"@kwdef mutable struct BoruvkaTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.ClosenessCentrality","page":"Network constraints","title":"PortfolioOptimiser.ClosenessCentrality","text":"@kwdef mutable struct ClosenessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.DegreeCentrality","page":"Network constraints","title":"PortfolioOptimiser.DegreeCentrality","text":"@kwdef mutable struct DegreeCentrality{T1 <: Integer} <: CentralityType\n    type::T1 = 0\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.EigenvectorCentrality","page":"Network constraints","title":"PortfolioOptimiser.EigenvectorCentrality","text":"struct EigenvectorCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KatzCentrality","page":"Network constraints","title":"PortfolioOptimiser.KatzCentrality","text":"@kwdef mutable struct KatzCentrality{T1 <: Real} <: CentralityType\n    alpha::T1 = 0.3\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KruskalTree","page":"Network constraints","title":"PortfolioOptimiser.KruskalTree","text":"@kwdef mutable struct KruskalTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.MST","page":"Network constraints","title":"PortfolioOptimiser.MST","text":"@kwdef mutable struct MST{T1 <: Integer} <: NetworkType\n    tree::TreeType = KruskalTree()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.Pagerank","page":"Network constraints","title":"PortfolioOptimiser.Pagerank","text":"@kwdef mutable struct Pagerank{T1 <: Real, T2 <: Integer, T3 <: Real} <: CentralityType\n    alpha::T1 = 0.85\n    n::T2 = 100\n    epsilon::T3 = 1e-6\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.PrimTree","page":"Network constraints","title":"PortfolioOptimiser.PrimTree","text":"@kwdef mutable struct PrimTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.RadialityCentrality","page":"Network constraints","title":"PortfolioOptimiser.RadialityCentrality","text":"struct RadialityCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.StressCentrality","page":"Network constraints","title":"PortfolioOptimiser.StressCentrality","text":"@kwdef mutable struct StressCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TMFG","page":"Network constraints","title":"PortfolioOptimiser.TMFG","text":"@kwdef mutable struct TMFG{T1 <: Integer} <: NetworkType\n    similarity::DBHTSimilarity = DBHTMaxDist()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#Private","page":"Network constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/","page":"Network constraints","title":"Network constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Types/NetworkConstraintTypes.jl\",\n\"Constraints/Functions/NetworkConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.CentralityType","page":"Network constraints","title":"PortfolioOptimiser.CentralityType","text":"abstract type CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.NetworkType","page":"Network constraints","title":"PortfolioOptimiser.NetworkType","text":"abstract type NetworkType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TreeType","page":"Network constraints","title":"PortfolioOptimiser.TreeType","text":"abstract type TreeType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#Public","page":"Constraints","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AKelly","page":"Constraints","title":"PortfolioOptimiser.AKelly","text":"@kwdef mutable struct AKelly <: RetType\n    formulation::VarianceFormulation = SOC()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.EKelly","page":"Constraints","title":"PortfolioOptimiser.EKelly","text":"struct EKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.IP","page":"Constraints","title":"PortfolioOptimiser.IP","text":"@kwdef struct IP{T1 <: AbstractMatrix{<:Real},\n                 T2 <: Union{<:Integer, <:AbstractVector{<:Integer}}, T3 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    k::T2 = 1\n    scale::T3 = 100_000.0\nend\n\nDefines the exact network constraint using mixed-integer programming.\n\nbeginalign\nleft(mathbfA + mathbfIright)bmy leq bmk\nw_i leq b_u y_i quad forall i = 1ldotsN \nw_i geq b_l y_i quad forall i = 1ldotsN\nendalign\n\nWhere:\n\nmathbfA is the N times N adjacency matrix.\nmathbfI is the identity matrix.\n\nSince each row of left(mathbfA + mathbfIright) corresponds to a path, duplicate rows add no new information whilst increasing the problem's size, therefore we only store unique rows.\n\nbmy is an N times 1 vector of binary 01 decision variables, which decide whether or not the asset should be included in the portfolio.\nbmk:\nif is a vector: Mtimes 1 vector defining the maximum number of assets allowed per unique path, where M is the number of unique paths.\nif is a scalar: defines the maximum number of assets allowed for all unique paths.\nw_i is the i-th asset weight.\nb_ub_l are the upper and lower bounds of the sum of the long and sum of the short asset weights, respectively.\nThus the constraint means we will invest in at most bmk assets per corresponding unique path.\n\nThis approach can be appied to any risk measure without work arounds like SDP. However it is more computationally costly to optimise, and may fail when mathbfA is close to the all ones matrix.\n\nParameters\n\nA: adjacency matrix, only stores unique(A + I, dims = 1).\nk:\nif is a vector: maximum number of assets per unique path.\nif A is not empty, checks that the length of k is equal to the size of unique(A + I, dims = 1).\nif is a scalar: maximum number of assets for all unique paths.\nscale: scaling variable for an auxiliary binary decision variable when optimising the Sharpe objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoAdj","page":"Constraints","title":"PortfolioOptimiser.NoAdj","text":"struct NoAdj <: AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoKelly","page":"Constraints","title":"PortfolioOptimiser.NoKelly","text":"struct NoKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.SDP","page":"Constraints","title":"PortfolioOptimiser.SDP","text":"@kwdef mutable struct SDP{T1 <: AbstractMatrix{<:Real}, T2 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    penalty::T2 = 0.05\nend\n\nDefines an approximate network constraint using semi-definite programming.\n\nbeginalign\nbeginbmatrix\nmathbfW  bmw\nbmw^intercal  1\nendbmatrix succeq 0\nmathbfW = mathbfW^intercal\nmathbfA odot mathbfW = bm0\nendalign\n\nWhere:\n\nmathbfW is an auxiliary variable that approximates the outer product of asset weights bmw otimes bmw.\nmathbfA is the Ntimes N adjacency matrix. It tells us which assets are connected. The matrix can only take values of 1 or 0. If entry (ij) is equal to 1, assets i and j are connected.\nodot is the Hadamard (element-wise) product.\n\nWhen the variance risk measure SD is being used, whether in the objective function or as one of the risk constraints. Its definition will change when this constraint is active. The new definition is this.\n\nbeginalign\nphi_mathrmvar(bmw) = mathrmTrleft(mathbfSigmamathbfWright)\nendalign\n\nWhere:\n\nmathrmTr(cdot) is the trace operator.\nmathbfSigma is the covariance matrix.\n\nHowever, this will not work if the variance is not being constrained, or if it is not in the objective function. For that we add/subtract the following penalty factor to the objective function.\n\nbeginalign\nundersetbmwmathrmopt quad phi(bmw) pm lambda mathrmTrleft(mathbfXright)\nendalign\n\nWhere:\n\nmathrmopt is mathrmmin when the objective is convex and mathrmmax when it is concave.\npm is + when the objective is convex and - when it is concave.\nlambda is a penalty factor.\n\nThis approach works better than IP when mathbfA is close to the all ones matrix, even though it's an approximation.\n\nParameters\n\nA: N×N adjacency matrix.\npenalty: penalty factor when the variance SD risk measure isn't being used, either in a constraint or in the objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Private","page":"Constraints","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/","page":"Constraints","title":"Constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationConstraintTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationConstraints.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationConstraints.jl\"]","category":"page"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AdjacencyConstraint","page":"Constraints","title":"PortfolioOptimiser.AdjacencyConstraint","text":"abstract type AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.CustomConstraint","page":"Constraints","title":"PortfolioOptimiser.CustomConstraint","text":"abstract type CustomConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoCustomConstraint","page":"Constraints","title":"PortfolioOptimiser.NoCustomConstraint","text":"struct NoCustomConstraint <: CustomConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.RetType","page":"Constraints","title":"PortfolioOptimiser.RetType","text":"abstract type RetType end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Risk-Measures","page":"Risk Measures","title":"Risk Measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"Risk measures are the backbone of portfolio optimisation. They allow for the quantification of risk in different ways. This section describes the various risk measures included in PortfolioOptimiser, explains their properties, formulations and compatibility with the various optimisation types in the library.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Specifying-solvers","page":"Risk Measures","title":"Specifying solvers","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"Some risk measures require solvers to compute the risk measure via calc_risk. When using high level functions that take in an instance of Portfolio as an argument, the solvers will be taken from it. However, it is possible to override them by directly providing the solvers to the risk measure instance.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"The solvers can be specified by any container which implements the AbstractDict interfaces. This dictionary must contain key-value pairs for all solvers one wants to use. The key can be of any type, but the value must be a dictionary with the following key-value pairs.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":":solver: defines the solver to be used. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters/attributes.\n:add_bridges: (optional) value of the add_bridges kwarg of JuMP.set_optimizer, if not provided defaults to true.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"using JuMP, Clarabel\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, model bridge argument, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false),\n                                 # (Optional) Flag for adding JuMP bridges to JuMP.Model()\n                                 # defaults to true (https://jump.dev/JuMP.jl/stable/api/JuMP/#Model).\n                                 :add_bridges => false))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"Users are able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"solvers = Dict(:Clarabel_1 => Dict(:solver => Clarabel.Optimizer,\n                                   :check_sol => (allow_local = true, allow_almost = true),\n                                   :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :Clarabel_2 => Dict(:solver => JuMP.optimizer_with_attributes(Clarabel.Optimizer,\n                                                                             \"max_step_fraction\" => 0.75),\n                                   # Do not add JuMP bridges to JuMP.Model()\n                                   :add_bridges => false))","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser will iterate over the solvers until it finds the first one to successfully solve the problem. If a deterministic ordering is desired (for example when going from relaxed to strict tolerances), use an OrderedDict.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Abstract-types","page":"Risk Measures","title":"Abstract types","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser's risk measures are implemented using Julia's type hierarchy. This makes it easy to add new ones by implementing the relevant types and methods.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser.AbstractRiskMeasure\nRiskMeasure\nHCRiskMeasure\nNoOptRiskMeasure","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.AbstractRiskMeasure","page":"Risk Measures","title":"PortfolioOptimiser.AbstractRiskMeasure","text":"abstract type AbstractRiskMeasure end\n\nSupertype for all risk measaures.\n\nSee also: RiskMeasure, HCRiskMeasure, NoOptRiskMeasure.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RiskMeasure","page":"Risk Measures","title":"PortfolioOptimiser.RiskMeasure","text":"abstract type RiskMeasure <: AbstractRiskMeasure end\n\nSupertype for risk measures compatible with Trad, RB, NOC, HRP, HERC, and NCO optimisation types.\n\nSee also: calc_risk, RMSettings, Trad, RB, NOC, HRP, HERC, NCO, set_rm, set_rm_solvers!, unset_rm_solvers!.\n\nImplementation requirements\n\nTo ensure a risk measure can be used any of the above optimisation types, it must abide by a few rules.\n\nInclude a settings::RMSettings field, RMSettings.\n\nstruct MyRiskMeasure <: RiskMeasure\n    # Fields of MyRiskMeasure\n    settings::RMSettings\nend\n\nImplement your measure's risk calculation method, calc_risk. This will let the library use the risk function everywhere it needs to.\n\nfunction calc_risk(my_risk::MyRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\nA scalar JuMP model implementation of set_rm. If appropriate, a vector equivalent.\n\n# The scalar function.\nfunction PortfolioOptimiser.set_rm(port, rm::MyRiskMeasure, type::Union{Trad, RB, NOC};\n                                   kwargs...)\n    # Get optimisation model.\n    model = port.model\n\n    ###\n    # Variables, constraints, expressions, etc.\n    ###\n\n    # Define the risk expression for MyRiskMeasure\n    @expression(model, MyRiskMeasure_risk, ...)\n\n    # Define the key name for the upper bound.\n    ub_key = \"MyRiskMeasure_risk\"\n\n    # Set the upper bound on MyRiskMeasure_risk. \n    # If isinf(rm.settings.ub), no upper bound will be set.\n    set_rm_risk_upper_bound(type, model, MyRiskMeasure_risk, rm.settings.ub, ub_key)\n\n    # Add the risk to the risk expression.\n    # If rm.settings.flag == true, MyRiskMeasure_risk will be added to the vector of risks.\n    # This means it will form part of the objective function when the objective function \n    # is MinRisk, Utility or Sharpe.\n    # If rm.settings.flag == false, MyRiskMeasure_risk will only be used as a risk \n    # constraint.\n    set_risk_expression(model, MyRiskMeasure_risk, rm.settings.scale, rm.settings.flag)\n\n    return nothing\nend\n\n# Vector equivalent if it's possible to provide multiple instances of MyRiskMeasure.\nfunction PortfolioOptimiser.set_rm(port, rms::AbstractVector{<:MyRiskMeasure},\n                                   type::Union{Trad, RB, NOC}; kwargs...)\n\n    # Get optimisation model.\n    model = port.model\n    count = length(rms)\n\n    ###\n    # Variables, constraints, expressions, that can be initialised beforehand etc.\n    ###\n\n    # Define the risk expression for MyRiskMeasure.\n    # It can also be defined in the iteration using the \n    # `model[key] = @expression(model, ..., ...) `\n    # construct, then reference the `model[key]` expression.\n    # Or use its anonymous version\n    # `key = @expression(model, ..., ...)` \n    # and reference the `key` expression.\n    @expression(model, MyRiskMeasure_risk[1:count], ...)\n\n    for (i, rm) ∈ pairs(rms)\n        ###\n        # Variables, constraints, expressions, that must be set during each iteration.\n        # If you want to register them in the model use:\n        # `model[constraint_key] = @constraint(model, ..., ...)`\n        # `model[expression_key] = @expression(model, ..., ...)`\n        # `model[variable_key] = @variable(model, ..., ...)`\n        # If you want them to be anonymous (i.e. not registered in the model) use:\n        # `constraint_key = @constraint(model, ..., ...)`\n        # `expression_key = @expression(model, ..., ...)`\n        # `variable_key = @variable(model, ..., ...)`\n        # If they were defined outside of the loop like MyRiskMeasure_risk \n        # but need to be modified then use:\n        # `add_to_expression!(MyRiskMeasure_risk[i], ...).`\n        ###\n\n        # Define the key name for the upper bound.\n        ub_key = \"MyRiskMeasure_risk_$(i)\"\n\n        # Set the upper bound on MyRiskMeasure_risk[i]. \n        # If isinf(rm.settings.ub), no upper bound will be set.\n        set_rm_risk_upper_bound(type, model, MyRiskMeasure_risk[i], rm.settings.ub, ub_key)\n\n        # Add the risk to the risk expression.\n        # If rm.settings.flag == true, MyRiskMeasure_risk[i] will be added to the vector of\n        # risks. This means it will form part of the objective function when the objective \n        # function is MinRisk, Utility or Sharpe.\n        # If rm.settings.flag == false, MyRiskMeasure_risk[i] will only be used as a risk \n        # constraint.\n        set_risk_expression(model, MyRiskMeasure_risk[i], rm.settings.scale,\n                            rm.settings.flag)\n    end\n\n    return nothing\nend\n\nIf calculating the risk requires solving an optimisation model it must have a solvers::Union{<:AbstractDict, Nothing} field to store JuMP-compatible solvers, and implement set_rm_solvers! and unset_rm_solvers!.\n\nstruct MyRiskMeasure <: RiskMeasure\n    # Fields of MyRiskMeasure\n    solvers::Union{<:AbstractDict, Nothing}\nend\n\nfunction PortfolioOptimiser.set_rm_solvers!(rm::MyRiskMeasure, solvers)\n    flag = false\n    if isnothing(rm.solvers) || isempty(rm.solvers)\n        rm.solvers = solvers\n        flag = true\n    end\n    return flag\nend\n\nfunction PortfolioOptimiser.unset_rm_solvers!(rm::MyRiskMeasure, flag)\n    if flag\n        rm.solvers = nothing\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRiskMeasure","page":"Risk Measures","title":"PortfolioOptimiser.HCRiskMeasure","text":"abstract type HCRiskMeasure <: AbstractRiskMeasure end\n\nSupertype for risk measures compatible with HRP, HERC, and NCO with any of the previous.\n\nSee also: calc_risk, HCRMSettings, HRP, HERC, NCO, set_rm_solvers!, unset_rm_solvers!.\n\nImplementation requirements\n\nTo ensure a risk measure can be used by the above optimisation types, it must abide by a few rules.\n\nInclude a settings::HCRMSettings field, HCRMSettings.\n\nstruct MyHCRiskMeasure <: HCRiskMeasure\n    # Fields of MyHCRiskMeasure\n    settings::HCRMSettings\nend\n\nImplement your measure's risk calculation method, calc_risk. This will let the library use the risk function everywhere it needs to.\n\nfunction calc_risk(my_risk::MyHCRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\nIf calculating the risk requires solving an optimisation model it must have a solvers::Union{<:AbstractDict, Nothing} field to store JuMP-compatible solvers, and implement set_rm_solvers! and unset_rm_solvers!.\n\nstruct MyHCRiskMeasure <: RiskMeasure\n    # Fields of MyHCRiskMeasure\n    solvers::Union{<:AbstractDict, Nothing}\nend\n\nfunction PortfolioOptimiser.set_rm_solvers!(rm::MyHCRiskMeasure, solvers)\n    flag = false\n    if isnothing(rm.solvers) || isempty(rm.solvers)\n        rm.solvers = solvers\n        flag = true\n    end\n    return flag\nend\n\nfunction PortfolioOptimiser.unset_rm_solvers!(rm::MyHCRiskMeasure, flag)\n    if flag\n        rm.solvers = nothing\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.NoOptRiskMeasure","page":"Risk Measures","title":"PortfolioOptimiser.NoOptRiskMeasure","text":"abstract type NoOptRiskMeasure <: AbstractRiskMeasure end\n\nAbstract type for risk measures that cannot be used in optimisations but can be used as performance measurements via calc_risk. This can be for two reasons:\n\nThey can be negative, therefore unsuitable for HRP, HERC, and NCO with any of the previous.\nThey have no known optimisation formulation, therefore unsuitable for Trad, RB, NOC, and NCO with any of the previous.\n\nSee also: calc_risk, Trad, RB, NOC, HRP, HERC, NCO.\n\nImplementation\n\nImplement your measure's risk calculation method, calc_risk. This will let the library use the risk function everywhere it needs to.\n\nstruct MyNoOptRiskMeasure <: NoOptRiskMeasure\n    # Fields of MyNoOptRiskMeasure\nend\n\nfunction calc_risk(my_risk::MyNoOptRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Settings","page":"Risk Measures","title":"Settings","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser lets users provide multiple risk measures at the same time. They can be added to the risk expression in the optimisation objective, or used to set upper risk bounds. If multiple risk measures are to be used as part of the risk expression in the optimisation objective, it makes sense provide a way to scale each risk contribution in the objective, especially because different risk expressions may have different units, and therefore require appropriate scaling.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"Furthermore, certain risk measures make use of Ordered Weight Array formulations, for which there is an expensive exact formulation, and an approximate, tunable one. We let users decide which one to use, and if they want to use the approximate one they can tune it as they see fit.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"The following structures provide said functionality.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"RMSettings\nHCRMSettings\nOWASettings","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RMSettings","page":"Risk Measures","title":"PortfolioOptimiser.RMSettings","text":"mutable struct RMSettings{T1 <: Real, T2 <: Real}\n\nConfiguration settings for concrete subtypes of RiskMeasure. Having this field makes it possible for a risk measure to be used in any optimisation types that take risk measures as parameters.\n\nSee also: calc_risk, RiskMeasure, Trad, RB, NOC, HRP, HERC, NCO, AbstractScalarisation.\n\nKeyword Parameters\n\nIn Trad, RB, NOC, NCO with any of the previous\n\nflag::Bool = true:\nIf true: it is included in the optimisation's risk vector.\nIf false: it is not included in the optimisation's risk vector, used when you want to constrain the upper bound of a risk measure without having that risk measure appear in the MinRisk, Utility, or Sharpe objective measures.\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\nub::T2 = Inf: upper bound risk constraint.\n\nIn HRP, HERC, NCO with any of the previous\n\nflag::Bool = true: no effect, the risk cannot be bounded in these optimisations.\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\nub::T2 = Inf: no effect, the risk cannot be bounded in these optimisations.\n\nExamples\n\nusing Clarabel\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879]\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = 1:size(ret, 2),\n                 solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                  :check_sol => (allow_local = true,\n                                                                 allow_almost = true),\n                                                  :params => Dict(\"verbose\" => false))))\n\n# Compute statistics.\nasset_statistics!(port)\n\n# Clusterise assets.\ncluster_assets!(port)\n\n# Traditional optimisation.\ntype = Trad(;\n            rm = [\n                  # Append to the risk vector as `sqrt(252) * sd_risk`\n                  SD(; settings = RMSettings(; flag = true, scale = sqrt(252))),\n                  # Append to the risk vector as `0.5 * cvar_risk`\n                  CVaR(; settings = RMSettings(; scale = 0.5, flag = true)),\n                  # Do not add to the risk vector but constrain the maximum\n                  # CDaR to 100\n                  CDaR(; settings = RMSettings(; flag = false, ub = 100))])\nw1 = optimise!(port, type)\nw1\n#=\n5×2 DataFrame\n Row │ tickers  weights     \n     │ Int64    Float64     \n─────┼──────────────────────\n   1 │       1  3.11076e-11\n   2 │       2  0.0165189\n   3 │       3  0.525957\n   4 │       4  0.0220971\n   5 │       5  0.435427\n=#\n\n# Risk vector only contains the risk measures with `flag == true`, \n# multiplied by the scaling factor\nport.model[:risk_vec]\n#=\n2-element Vector{JuMP.AbstractJuMPScalar}:\n 15.874507866387544 sd_risk\n 0.5 var + z_cvar[1] + z_cvar[2] + z_cvar[3] + z_cvar[4] + z_cvar[5] + z_cvar[6] + z_cvar[7] + z_cvar[8] + z_cvar[9] + z_cvar[10]\n=#\n\n# The risk expression is the sum of the entries in the vector because\n# the default scalarisation is the sum of the expressions.\nport.model[:risk]\n#=\n15.874507866387544 sd_risk + 0.5 var + z_cvar[1] + z_cvar[2] + z_cvar[3] + z_cvar[4] + z_cvar[5] + z_cvar[6] + z_cvar[7] + z_cvar[8] + z_cvar[9] + z_cvar[10]\n=#\n\n# Check that the CDaR is indeed constrained to be <= 100.\nport.model[:cdar_risk_ub]\n#=\ndar + 2 z_cdar[1] + 2 z_cdar[2] + 2 z_cdar[3] + 2 z_cdar[4] + 2 z_cdar[5] + 2 z_cdar[6] + 2 z_cdar[7] + 2 z_cdar[8] + 2 z_cdar[9] + 2 z_cdar[10] <= 100\n=#\n\n# Hierarchical equal risk optimisation.\ntype = HERC(;\n            rm = [\n                  # Add to the risk calculation (via `AbstractScalarisation`)\n                  # as `sqrt(252) * sd_risk`.\n                  SD(; settings = RMSettings(; flag = true, scale = sqrt(252))),\n                  # Add to the risk calculation (via `AbstractScalarisation`)\n                  # as `0.5 * cvar_risk`.\n                  CVaR(; settings = RMSettings(; scale = 0.5, flag = true)),\n                  # Add to the risk calculation because `flag` and `ub` have no\n                  # effect in hierarchical optimisations.\n                  CDaR(; settings = RMSettings(; flag = false, ub = 100))])\nw2 = optimise!(port, type)\nw2\n#=\n5×2 DataFrame\n Row │ tickers  weights   \n     │ Int64    Float64   \n─────┼────────────────────\n   1 │       1  0.0548607\n   2 │       2  0.0634407\n   3 │       3  0.695601\n   4 │       4  0.0506031\n   5 │       5  0.135495\n=#\n\n# There is no `JuMP` model for HRP and HERC so we can't see the internals. \n# The effects can be seen by changing coefficients.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.HCRMSettings","page":"Risk Measures","title":"PortfolioOptimiser.HCRMSettings","text":"mutable struct HCRMSettings{T1 <: Real}\n\nConfiguration settings for concrete subtypes of HCRiskMeasure.\n\nSee also: calc_risk, HCRiskMeasure, HRP, HERC, NCO, AbstractScalarisation.\n\nKeyword Parameters\n\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879]\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = 1:size(ret, 2))\n\n# Compute asset statistics.                                                \nasset_statistics!(port)\n\n# Clusterise assets.\ncluster_assets!(port)\n\n# Hierarchical equal risk optimisation.\ntype = HERC(;\n            rm = [\n                  # Add to the risk calculation (via `AbstractScalarisation`)\n                  # as `0.5 * dar_risk`.\n                  DaR(; settings = HCRMSettings(; scale = 0.5)),\n                  # Add to the risk calculation (via `AbstractScalarisation`)\n                  # as `3 * var_risk`.\n                  VaR(; settings = HCRMSettings(; scale = 3))])\nw = optimise!(port, type)\n#=\n5×2 DataFrame\n Row │ tickers  weights   \n     │ Int64    Float64   \n─────┼────────────────────\n   1 │       1  0.035433\n   2 │       2  0.0480019\n   3 │       3  0.795106\n   4 │       4  0.0245889\n   5 │       5  0.0968701\n=#\n\n# There is no `JuMP` model for HRP and HERC so we can't see the internals. \n# The effects can be seen by changing coefficients.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWASettings","page":"Risk Measures","title":"PortfolioOptimiser.OWASettings","text":"mutable struct OWASettings{T1 <: AbstractVector{<:Real}}\n\nDescription\n\nDefines the settings for Ordered Weight Array (OWA) risk measures.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm.\n\nFields\n\napprox::Bool = true: use the p-norm based approximation of the OWA risk measure optimisation.\np::T1 = Float64[2, 3, 4, 10, 50]: vector of the p-norm orders to be used in the approximation.\n\nBehaviour\n\np is only used when approx == true.\n\nExamples\n\n# Default settings\nowa = OWASettings()\n\n# Use full risk measure formulation\nowa = OWASettings(; approx = false)\n\n# Use more p-norms\nowa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128])\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Risk-measures","page":"Risk Measures","title":"Risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These risk measures are compatible with both Portfolio and optimisations. Different risk measures account for different aspects of the returns.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Dispersion-risk-measures","page":"Risk Measures","title":"Dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Full-dispersion-risk-measures","page":"Risk Measures","title":"Full dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure how far the returns deviate from the mean in both the positive and negative directions.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"VarianceFormulation\nQuad\nSOC\nVariance\nSD\nMAD\nKurt\nRG\nCVaRRG\nTGRG\nGMD\nSkew\nBDVariance","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.VarianceFormulation","page":"Risk Measures","title":"PortfolioOptimiser.VarianceFormulation","text":"abstract type VarianceFormulation end\n\nAbstract type for implementing various formulations of the Variance in Trad, RB, NOC, NCO with any of the previous optimisation types.\n\nSee also: Variance, Quad, SOC, Trad, RB, NOC, NCO.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Quad","page":"Risk Measures","title":"PortfolioOptimiser.Quad","text":"struct Quad <: VarianceFormulation end\n\nExplicit quadratic formulation for the Variance as an optimisation model.\n\nbeginalign\nundersetbmwmathrmopt qquad bmw^intercal mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nSee also: VarianceFormulation, SOC, Variance.\n\nBehaviour\n\nProduces a QuadExpr risk expression variance_risk = dot(w, sigma, w).\nNot compatible with NOC optimisations because QuadExpr are not strictly convex.\nNo additional variables or constraints introduced.\nRequires a solver capable of handling quadratic expressions.\nPerformance may degrade for large portfolios.\n\nExamples\n\nusing Clarabel, LinearAlgebra\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879]\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = 1:size(ret, 2),\n                 solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                  :check_sol => (allow_local = true,\n                                                                 allow_almost = true),\n                                                  :params => Dict(\"verbose\" => false))))\n# Compute asset statistics.                                                \nasset_statistics!(port)\n\n# Explicit quadratic expression for the variance.\nw = optimise!(port, Trad(; rm = Variance(; formulation = Quad()), str_names = true))\nw\n#=\n5×2 DataFrame\n Row │ tickers  weights    \n     │ Int64    Float64    \n─────┼─────────────────────\n   1 │       1  3.5113e-10\n   2 │       2  0.0183835\n   3 │       3  0.520498\n   4 │       4  0.0340474\n   5 │       5  0.427071\n=#\n\n# Covariance matrix, sigma.\nport.cov\n#=\n5×5 Matrix{Float64}:\n 1.89335    0.649754   0.129808     0.602482     0.262616\n 0.649754   1.41321   -0.152314     0.785941     0.367755\n 0.129808  -0.152314   0.958713    -0.00842172  -0.855604\n 0.602482   0.785941  -0.00842172   2.11576      0.113369\n 0.262616   0.367755  -0.855604     0.113369     1.32352\n=#\n\n# Check that the variance risk is indeed `dot(w, sigma, w)`.\nport.model[:variance_risk] == dot(port.model[:w], port.cov, port.model[:w]) # true\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SOC","page":"Risk Measures","title":"PortfolioOptimiser.SOC","text":"struct SOC <: VarianceFormulation end\n\nSecond-Order Cone (SOC) formulation for the Variance. Reformulates the quadratic variance expression using a MOI.SecondOrderCone cone constraint.\n\nbeginalign\nundersetbmwmathrmopt qquad sigma^2nonumber\ntextrmst qquad leftlVert mathbfG bmw rightrVert_2 leq sigma\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfG: is a suitable factorisation of the N×N covariance matrix, such as the square root matrix, or the Cholesky factorisation.\nsigma^2: is the portfolio variance.\nlVert cdot rVert_2: is the L-2 norm, which is modelled as a MOI.SecondOrderCone.\n\nSee also: VarianceFormulation, Quad, Variance.\n\nBehaviour\n\nUses a SecondOrderCone constraint.\nDefines a standard deviation variable dev.\nProduces a QuadExpr risk expression sd_risk = dev^2.\nNot compatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\nOften more numerically stable than direct quadratic formulation.\nBetter scaling properties for large portfolios.\nCompatible with specialised conic solvers.\nMay introduce more variables but often leads to better solution times.\nParticularly effective for large-scale problems.\n\nExamples\n\nusing Clarabel\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879]\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = 1:size(ret, 2),\n                 solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                  :check_sol => (allow_local = true,\n                                                                 allow_almost = true),\n                                                  :params => Dict(\"verbose\" => false))))\n# Compute asset statistics.                                                \nasset_statistics!(port)\n\n# Explicit quadratic expression for the variance.\nw = optimise!(port, Trad(; rm = Variance(; formulation = SOC()), str_names = true))\nw\n#=\n5×2 DataFrame\n Row │ tickers  weights    \n     │ Int64    Float64    \n─────┼─────────────────────\n   1 │       1  2.14218e-9\n   2 │       2  0.0183819\n   3 │       3  0.520499\n   4 │       4  0.0340462\n   5 │       5  0.427073\n=#\n\n# Covariance matrix, sigma.\nport.cov\n#=\n5×5 Matrix{Float64}:\n 1.89335    0.649754   0.129808     0.602482     0.262616\n 0.649754   1.41321   -0.152314     0.785941     0.367755\n 0.129808  -0.152314   0.958713    -0.00842172  -0.855604\n 0.602482   0.785941  -0.00842172   2.11576      0.113369\n 0.262616   0.367755  -0.855604     0.113369     1.32352\n =#\n\n# Check that the variance risk exists as an SOC constraint.\nport.model[:variance_risk]\n#=\ndev²\n=#\n\nport.model[:constr_dev_soc]\n#=\nconstr_dev_soc : \n[dev, \n1.3339817521328776 w[1] + 0.23752111354642388 w[2] + 0.08772311968949179 w[3] + 0.1933954630317334 w[4] + 0.11104990914089145 w[5], \n0.23752111354642388 w[1] + 1.1172071395407432 w[2] - 0.05472328163488465 w[3] + 0.2914549020386699 w[4] + 0.14389651700778633 w[5],\n0.08772311968949179 w[1] - 0.05472328163488465 w[2] + 0.8635663605757948 w[3] - 0.00013005161391315675 w[4] - 0.4497512686528594 w[5],\n0.1933954630317334 w[1] + 0.2914549020386699 w[2] - 0.00013005161391315675 w[3] + 1.4117365158022712 w[4] + 0.020326110574790338 w[5],\n0.11104990914089145 w[1] + 0.14389651700778633 w[2] - 0.4497512686528594 w[3] + 0.020326110574790338 w[4] + 1.0429726582846264 w[5]]\nin MathOptInterface.SecondOrderCone(6)\n=#\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Variance","page":"Risk Measures","title":"PortfolioOptimiser.Variance","text":"mutable struct Variance{T1 <: Union{<:AbstractMatrix, Nothing}} <: RiskMeasure\n\nDescription\n\nDefines the Variance risk measure.\n\nbeginalign\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\nendalign\n\nSee also: HCRMSettings, optimise!, calc_risk(::Variance, ::AbstractVector).\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): hierarchical risk measure configuration settings.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: optional covariance matrix.\n\nBehaviour\n\nIf sigma is nothing: uses the covariance matrix cov from the (or [Portfolio] when used in calc_risk) instance.\nIf sigma provided: uses custom covariance matrix.\n\nValidation\n\nWhen setting sigma at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nvariance = Variance()\n\n# Custom settings\nvariance = Variance(; settings = RMSettings(; scale = 3))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SD","page":"Risk Measures","title":"PortfolioOptimiser.SD","text":"mutable struct SD <: RiskMeasure\n\nMeasures and computes the portfolio Standard Deviation (SD).\n\nbeginalign\nmathrmSD(bmw mathbfSigma) = left(bmw^intercal  mathbfSigma  bmwright)^12\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nSee also: RiskMeasure, RMSettings, Variance, PortClass, OptimType, calc_risk, optimise!, set_rm.\n\nKeyword Parameters\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: optional covariance matrix.\nIf nothing: takes its value from the instance Portfolio, the field depends on the PortClass parameter of the OptimType used.\n\nBehaviour\n\nWhen setting sigma at construction or runtime, the matrix must be square (N×N).\n\nIn Trad, RB, NOC, NCO with any of the previous\n\nUses a SecondOrderCone constraint.\nDefines a standard deviation variable sd_risk.\nSets the AffExpr risk expression sd_risk = dev.\nCompatible with NOC (Near Optimal Centering) optimisations because AffExpr are strictly convex.\n\nFunctor\n\n(sd::SD)(w::AbstractVector): computes the standard deviation using the covariance matrix stored in the N×N matrix sigma, and using an N×1 vector of asset weights as the input.\n\nExamples\n\nusing Clarabel\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879]\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = 1:size(ret, 2),\n                 solvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                                  :check_sol => (allow_local = true,\n                                                                 allow_almost = true),\n                                                  :params => Dict(\"verbose\" => false))))\n# Risk measure\nrm = SD()\n\n# Compute asset statistics.                                                \nasset_statistics!(port)\n\n# Explicit quadratic expression for the variance.\nw1 = optimise!(port, Trad(; rm = rm, str_names = true))\nw1\n#=\n5×2 DataFrame\n Row │ tickers  weights     \n     │ Int64    Float64     \n─────┼──────────────────────\n   1 │       1  1.42346e-10\n   2 │       2  0.018383\n   3 │       3  0.520498\n   4 │       4  0.0340474\n   5 │       5  0.427072\n=#\n\n# Compute the standard deviation.\nr1 = calc_risk(port, :Trad; rm = rm) # 0.3612722213729872\n\n# As a functor.\nr1 == SD(; sigma = port.cov)(w1.weights) # true\n\n# Covariance matrix, sigma.\nport.cov\n#=\n5×5 Matrix{Float64}:\n 1.89335    0.649754   0.129808     0.602482     0.262616\n 0.649754   1.41321   -0.152314     0.785941     0.367755\n 0.129808  -0.152314   0.958713    -0.00842172  -0.855604\n 0.602482   0.785941  -0.00842172   2.11576      0.113369\n 0.262616   0.367755  -0.855604     0.113369     1.32352\n=#\n\n# Check that the std risk exists as an SOC constraint.\nport.model[:sd_risk]\n#=\nsd_risk\n=#\n\nport.model[:constr_sd_risk_soc]\n#=\nconstr_sd_risk_soc : \n[sd_risk,\n1.3339817521328776 w[1] + 0.23752111354642388 w[2] + 0.08772311968949179 w[3] + 0.1933954630317334 w[4] + 0.11104990914089145 w[5],\n0.23752111354642388 w[1] + 1.1172071395407432 w[2] - 0.05472328163488465 w[3] + 0.2914549020386699 w[4] + 0.14389651700778633 w[5],\n0.08772311968949179 w[1] - 0.05472328163488465 w[2] + 0.8635663605757948 w[3] - 0.00013005161391315675 w[4] - 0.4497512686528594 w[5],\n0.1933954630317334 w[1] + 0.2914549020386699 w[2] - 0.00013005161391315675 w[3] + 1.4117365158022712 w[4] + 0.020326110574790338 w[5],\n0.11104990914089145 w[1] + 0.14389651700778633 w[2] - 0.4497512686528594 w[3] + 0.020326110574790338 w[4] + 1.0429726582846264 w[5]]\nin MathOptInterface.SecondOrderCone(6)\n=#\n\n# Clusterise assets.\ncluster_assets!(port)\n\n# Hierarchical optimisation, no JuMP model.\nw2 = optimise!(port, HRP(; rm = rm))\nw2\n#=\n5×2 DataFrame\n Row │ tickers  weights  \n     │ Int64    Float64  \n─────┼───────────────────\n   1 │       1  0.199755\n   2 │       2  0.229988\n   3 │       3  0.198033\n   4 │       4  0.133306\n   5 │       5  0.238918\n=#\n\n# Compute the standard deviation.\nr2 = calc_risk(port, :HRP; rm = rm) # 0.6547632732108616\n\n# As a functor.\nr2 == SD(; sigma = port.cov)(w2.weights) # true\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MAD","page":"Risk Measures","title":"PortfolioOptimiser.MAD","text":"mutable struct MAD <: RiskMeasure\n\nMeasures and computes the portfolio Mean Absolute Deviation (MAD). In other words, it is the expected value of the absolute deviation from the expected value of the returns vector. This is a generalisation to accomodate the use of weighted means.\n\nbeginalign\nmathrmMAD(bmX) = mathbbEleft(leftlvert bmX - mathbbE(bmX) rightrvertright)\nendalign\n\nWhere:\n\nbmX: is the T×1 portfolio returns vector.\nlvert cdot rvert: is the absolute value.\nmathbbE(cdot): is the expected value.\n\nSee also: RiskMeasure, RMSettings, calc_risk, optimise!, set_rm.\n\nKeyword Parameters\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nw1::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for computing the expected value of the returns vector.\nw2::Union{<:AbstractWeights, Nothing} = nothing: optional T×1\nmu::Union{<:AbstractVector, Nothing} = nothing: optional N×1 vector of expected asset returns.\n\nBehaviour\n\nPortfolio Optimisation\n\nIf mu is nothing: use the expected returns vector from the Portfolio instance.\n\nOptimisation or in calc_risk(::MAD, ::AbstractVector).\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nmad = MAD()\n\n# Custom configuration\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nmu = rand(10)             # Expected returns\nmad = MAD(; settings = RMSettings(; scale = 2.0), w = w, mu = mu)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Kurt","page":"Risk Measures","title":"PortfolioOptimiser.Kurt","text":"mutable struct Kurt <: RiskMeasure\n\nDescription\n\nSquare Root Kurtosis risk measure implementation for portfolio optimisation.\n\nbeginalign\nmathrmKurt(bmX) = left(dfrac1T sumlimits_t=1^T left( X_t - mathbbE(bmX) right)^4 right)^12\nendalign\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::Kurt, ::AbstractVector), SKurt.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nkt::Union{AbstractMatrix, Nothing} = nothing: optional cokurtosis matrix.\n\nBehaviour\n\nIf kt is nothing: uses the semi cokurtosis matrix skurt from the Portfolio/object.\nIf kt provided: uses custom semi cokurtosis matrix.\n\nValidation\n\nWhen setting kt at construction or runtime, the matrix must be square (N²×N²).\n\nExamples\n\n# Default settings\nkurt = Kurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nkurt = Kurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nkurt = Kurt(; kt = nothing)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RG","page":"Risk Measures","title":"PortfolioOptimiser.RG","text":"mutable struct RG{T1 <: Real} <: RiskMeasure\n\nDescription\n\nDefines the Range risk measure.\n\nMeasures the best and worst returns, leftmathrmWR(bmX) mathrmWR(-bmX)right.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::RG, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nrg = RG()\n\n# Custom settings\nrg = RG(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaRRG","page":"Risk Measures","title":"PortfolioOptimiser.CVaRRG","text":"mutable struct CVaRRG{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nDefines the Conditional Value at Risk Range risk measure.\n\nMeasures the range between the expected loss in the worst alpha % of cases and expected gain in the best beta % of cases, leftmathrmCVaR(bmX alpha) mathrmCVaR(-bmX beta)right.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::CVaRRG, ::AbstractVector), CVaR, RG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level of losses, alpha ∈ (0, 1).\nalpha::T2 = 0.05: significance level of gains, beta ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting beta at construction or runtime, beta ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar = CVaRRG()\n\n# Custom significance level\ncdar = CVaRRG(; settings = RMSettings(; scale = 1.0), #\n              alpha = 0.01, # 1 % significance level losses \n              beta = 0.03)  # 3 % significance level gains\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TGRG","page":"Risk Measures","title":"PortfolioOptimiser.TGRG","text":"mutable struct TGRG{T1 <: Real, T2 <: Real, T3 <: Integer, T4 <: Real, T5 <: Real, T6 <: Integer} <: RiskMeasure\n\nDescription\n\nDefines the Tail Gini Difference Range risk measure.\n\nMeasures the range between the worst alpha % tail gini of cases and best beta % tail gini of cases, leftmathrmTG(bmX alpha) mathrmTG(-bmX beta)right.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::TGRG, ::AbstractVector), TG.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i::T4 = 0.0001: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta::T5 = 0.05: end value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nb_sim::T6 = 100: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\nBehaviour\n\nValidation\n\nWhen setting alpha_i at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting alpha at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting a_sim at construction or runtime, a_sim > 0.\nWhen setting beta_i at construction or runtime, 0 < beta_i < beta < 1.\nWhen setting beta at construction or runtime, 0 < beta_i < beta < 1.\nWhen setting b_sim at construction or runtime, b_sim > 0.\n\nExamples\n\n# Default settings\nrtg = RTG()\n\n# Use full risk measure formulation with custom parameters\nrtg = RTG(; alpha = 0.07, b_sim = 200, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\nrtg = RTG(; settings = RMSettings(; flag = false, ub = 0.1),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.GMD","page":"Risk Measures","title":"PortfolioOptimiser.GMD","text":"struct GMD <: RiskMeasure\n\nDescription\n\nDefines the Gini Mean Difference risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::GMD, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\n\nExamples\n\n# Default settings\ngmd = GMD()\n\n# Use full risk measure formulation\ngmd = GMD(; owa = OWASettings(; approx = false))\n\n# Use more p-norms and custom settings\ngmd = GMD(; settings = RMSettings(; scale = 1.7),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Skew","page":"Risk Measures","title":"PortfolioOptimiser.Skew","text":"struct Skew <: RiskMeasure\n\nDescription\n\nDefine the Quadratic Skewness risk measure.\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw is the vector of asset weights.\nmathbfV is the sum of the symmetric negative spectral slices of the coskewness.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::Skew, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: optional N×N² custom coskewness matrix.\nV::Union{Nothing, <:AbstractMatrix}: optional Na×Na custom sum of the symmetric negative spectral slices of the coskewness.\n\nBehaviour\n\nCoskewness matrix usage\n\nIf skew is nothing:\nWith Portfolio/calc_risk: no effect.\nWith : uses the portfolio coskewness matrix skew to generate the V matrix.\nIf skew provided:\nWith Portfolio/calc_risk: no effect.\nWith : uses the custom coskew matrix to generate the V matrix.\n\nV matrix\n\nIf V is nothing:\nWith Portfolio/calc_risk: uses the portfolio V matrix.\nWith : no effect.\nIf V provided:\nWith Portfolio/calc_risk: uses the custom V matrix.\nWith : no effect.\n\nValidation\n\nWhen setting skew at construction or runtime, the matrix must have dimensions (N×N²).\nWhen setting V at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nskew = Skew()\n\n# Custom settings\nskew = Skew(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.BDVariance","page":"Risk Measures","title":"PortfolioOptimiser.BDVariance","text":"struct BDVariance <: RiskMeasure\n\nDescription\n\nDefine the Brownian Distance Variance risk measure.\n\nMeasures linear and non-linear relationships between variables.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::BDVariance, ::AbstractVector).\n\nbeginalign\nmathrmBDVariance(bmX) = mathrmBDCov(bmX bmX) =  dfrac1T^2 sumlimits_i=1^Tsumlimits_j=1^T A_ij^2\nmathrmBDCov(bmX bmY) = dfrac1T^2 sumlimits_i=1^T sumlimits_j=1^T A_ij B_ij\nA_ij = a_ij - bara_i - bara_j + bara_\nB_ij = b_ij - barb_i - barb_j + barb_\na_ij = lVert X_i - X_j rVert_2 quad forall i j = 1 ldots  T\nb_ij = lVert Y_i - Y_j rVert_2 quad forall i j = 1 ldots  T\nendalign\n\nwhere:\n\nbmX and bmY are random variables, they are equal in this case as they are the portfolio returns.\na_ij and b_ij are entries of a distance matrix where i and j are points in time. Each entry is defined as the Euclidean distance lVert cdot rVert_2 between the value of the random variable at time i and its value at time j.\nbara_icdot and barb_icdot are the i-th row means of their respective matrices.\nbara_cdotj and barb_cdotj are the j-th column means of their respective matrices.\nbara_cdotcdot and barb_cdotcdot are the grand means of their respective matrices.\nA_ij and B_ij are doubly centered distances.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\ndvar = BDVariance()\n\n# Custom settings\ndvar = BDVariance(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Tracking-and-turnover-risk-measures","page":"Risk Measures","title":"Tracking and turnover risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser.AbstractTR\nPortfolioOptimiser.TrackingErr\nTrackRet\nTrackWeight\nNoTracking\nTR\nNoTR","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.AbstractTR","page":"Risk Measures","title":"PortfolioOptimiser.AbstractTR","text":"abstract type AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TrackingErr","page":"Risk Measures","title":"PortfolioOptimiser.TrackingErr","text":"abstract type TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TrackRet","page":"Risk Measures","title":"PortfolioOptimiser.TrackRet","text":"@kwdef mutable struct TrackRet{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TrackWeight","page":"Risk Measures","title":"PortfolioOptimiser.TrackWeight","text":"@kwdef mutable struct TrackWeight{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.NoTracking","page":"Risk Measures","title":"PortfolioOptimiser.NoTracking","text":"struct NoTracking <: TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TR","page":"Risk Measures","title":"PortfolioOptimiser.TR","text":"@kwdef mutable struct TR{T1 <: Union{<:Real, <:AbstractVector{<:Real}},\n                         T2 <: AbstractVector{<:Real}} <: AbstractTR\n    val::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.NoTR","page":"Risk Measures","title":"PortfolioOptimiser.NoTR","text":"struct NoTR <: AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-dispersion-risk-measures","page":"Risk Measures","title":"Downside dispersion risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"SSD\nFLPM\nSLPM\nSKurt\nSSkew","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSD","page":"Risk Measures","title":"PortfolioOptimiser.SSD","text":"mutable struct SSD{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSemi Standard Deviation risk measure implementation.\n\nMeasures the standard deviation equal to or below the target return threshold.\n\nbeginalign\nmathrmSSD(bmX) = left(dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2right)^12\nendalign\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::SSD, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nmu::Union{<:AbstractVector, Nothing} = nothing: optional N×1 vector of expected asset returns.\n\nBehaviour\n\nPortfolio Optimisation\n\nIf mu is nothing: use the expected returns vector from the Portfolio instance.\n\nOptimisation or in calc_risk(::SSD, ::AbstractVector).\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nssd = SSD()\n\n# Custom configuration with specific target\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nmu = rand(10)             # Expected returns\nssd = SSD(; settings = RMSettings(; scale = 2.0), w = w, mu = mu)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.FLPM","page":"Risk Measures","title":"PortfolioOptimiser.FLPM","text":"mutable struct FLPM{T1 <: Real} <: RiskMeasure\n\nDescription\n\nFirst Lower Partial Moment (Omega ratio) risk measure.\n\nMeasures the dispersion equal to or below the target return threshold.\n\nbeginalign\nmathrmFLPM(bmX r) = dfrac1T sumlimits_t=1^Tmaxleft(r - X_t 0right)\nendalign\n\nSee also: RiskMeasure, RMSettings, SLPM, Portfolio, optimise!, set_rm, calc_risk(::FLPM, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\n\nExamples\n\n# Default settings\nflpm = FLPM()\n\n# Custom target return\nflpm = FLPM(; target = 0.01)  # 1 % minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SLPM","page":"Risk Measures","title":"PortfolioOptimiser.SLPM","text":"mutable struct SLPM{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSecond Lower Partial Moment (Sortino ratio) risk measure.\n\nMeasures the dispersion equal to or below the target return threshold.\n\nbeginalign\nmathrmSLPM(bmX r) = left(dfrac1T-1 sumlimits_t=1^Tmaxleft(r - X_t 0right)^2right)^12\nendalign\n\nSee also: RiskMeasure, RMSettings, FLPM, Portfolio, optimise!, set_rm, calc_risk(::SLPM, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\n\nExamples\n\n# Default settings\nslpm = SLPM()\n\n# Custom settings\nslpm = SLPM(; settings = RMSettings(; scale = 2.0), target = 0.005)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SKurt","page":"Risk Measures","title":"PortfolioOptimiser.SKurt","text":"mutable struct SKurt{T1 <: Real} <: RiskMeasure\n\nDescription\n\nSquare Root Semi Kurtosis risk measure implementation for portfolio optimisation.\n\nMeasures the kurtosis equal to or below the target return threshold.\n\nbeginalign\nmathrmSKurt(bmX) = left(dfrac1T sumlimits_t=1^T minleft( X_t - mathbbE(bmX) r right)^4 right)^12\nendalign\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::SKurt, ::AbstractVector), Kurt.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\nkt::Union{AbstractMatrix, Nothing} = nothing: optional cokurtosis matrix.\n\nBehaviour\n\nIf kt is nothing: uses the cokurtosis from matrix skurt from the Portfolio/object.\nIf kt provided: uses custom cokurtosis matrix.\n\nValidation\n\nWhen setting kt at construction or runtime, the matrix must be square (N²×N²).\n\nExamples\n\n# Default settings\nskurt = SKurt()\n\n# Custom configuration with specific cokurtosis matrix\nmy_kt = [1.0 0.2; 0.2 1.0]\nskurt = SKurt(; settings = RMSettings(; scale = 2.0), kt = my_kt)\n\n# Using portfolio's built-in cokurtosis matrix\nskurt = SKurt(; kt = nothing, target = 0.015) # 1.5% minimum return threshold\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SSkew","page":"Risk Measures","title":"PortfolioOptimiser.SSkew","text":"struct SSkew <: RiskMeasure\n\nDescription\n\nDefine the Quadratic Semi Skewness risk measure.\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw is the vector of asset weights.\nmathbfV is the sum of the symmetric negative spectral slices of the semicoskewness.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::SSkew, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: optional N×N² custom semi coskewness matrix.\nV::Union{Nothing, <:AbstractMatrix}: optional Na×Na custom sum of the symmetric negative spectral slices of the semi coskewness.\n\nBehaviour\n\nCoskewness matrix usage\n\nIf skew is nothing:\nWith Portfolio/calc_risk: no effect.\nWith : uses the portfolio semi coskewness matrix sskew to generate the V matrix.\nIf skew provided:\nWith Portfolio/calc_risk: no effect.\nWith : uses the custom semi coskew matrix to generate the V matrix.\n\nV matrix\n\nIf V is nothing:\nWith Portfolio/calc_risk: uses the portfolio SV matrix.\nWith : no effect.\nIf V provided:\nWith Portfolio/calc_risk: uses the custom V matrix.\nWith : no effect.\n\nValidation\n\nWhen setting skew at construction or runtime, the matrix must have dimensions (N×N²).\nWhen setting V at construction or runtime, the matrix must be square (N×N).\n\nExamples\n\n# Default settings\nsskew = SSkew()\n\n# Custom settings\nsskew = SSkew(; settings = RMSettings(; ub = 0.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Worst-case-variance","page":"Risk Measures","title":"Worst case variance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"PortfolioOptimiser.WorstCaseSet\nBox\nEllipse\nNoWC","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.WorstCaseSet","page":"Risk Measures","title":"PortfolioOptimiser.WorstCaseSet","text":"abstract type WorstCaseSet end\n\nAbstract type for subtyping worst case mean variance set types.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Box","page":"Risk Measures","title":"PortfolioOptimiser.Box","text":"struct Box <: WCSetMuSigma end\n\nBox sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Ellipse","page":"Risk Measures","title":"PortfolioOptimiser.Ellipse","text":"struct Ellipse <: WCSetMuSigma end\n\nElliptical sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.NoWC","page":"Risk Measures","title":"PortfolioOptimiser.NoWC","text":"@kwdef mutable struct NoWC <: WorstCaseSet\n    formulation::VarianceFormulation = SOC()\nend\n\nUse no set for worst case mean variance optimisation.\n\nParameters\n\nformulation: quadratic expression formulation of SD risk measure to use VarianceFormulation.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-risk-measures","page":"Risk Measures","title":"Downside risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"WR\nCVaR\nEVaR\nRLVaR\nTG","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.WR","page":"Risk Measures","title":"PortfolioOptimiser.WR","text":"struct WR <: RiskMeasure\n\nDescription\n\nWorst Realization/Return risk measure.\n\nUseful for extremely conservative risk assessment.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmWR(bmX) = -min(bmX)\nendalign\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::WR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nwr = WR()\n\n# Custom settings\nwr = WR(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CVaR","page":"Risk Measures","title":"PortfolioOptimiser.CVaR","text":"mutable struct CVaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nConditional Value at Risk (Expected Shortfall) risk measure.\n\nMeasures expected loss in the worst alpha % of cases.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmCVaR(bmX alpha) = mathrmVaR(bmX alpha) + dfrac1alpha T sumlimits_t=1^T maxleft(-X_t - mathrmVaR(bmX alpha) 0right)\nendalign\n\nWhere:\n\nmathrmVaR(bmX alpha) is the Value at Risk as defined in VaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::CVaR, ::AbstractVector), VaR, EVaR, RLVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncvar = CVaR()\n\n# Custom significance level\ncvar = CVaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EVaR","page":"Risk Measures","title":"PortfolioOptimiser.EVaR","text":"mutable struct EVaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nEntropic Value at Risk risk measure.\n\nIt is the upper bound of the Chernoff inequality for the VaR and CVaR.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmEVaR(bmXalpha) = undersetz  0inf leftmathrmERM(bmX z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(bmX z alpha) is the entropic risk measure as defined in ERM.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::EVaR, ::AbstractVector), VaR, CVaR, RLVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EVaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nevar = EVaR()\n\n# Custom configuration with specific solver\nevar = EVaR(; alpha = 0.025,  # 2.5 % significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLVaR","page":"Risk Measures","title":"PortfolioOptimiser.RLVaR","text":"mutable struct RLVaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Value at Risk risk measure.\n\nIt is a generalisation of the EVaR.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\nlimlimits_kappa to 0 mathrmRLVaR(bmX alpha kappa) approx mathrmEVaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLVaR(bmX alpha kappa) approx mathrmWR(bmX)\n\nbeginalign\nmathrmRLVaR(bmX alpha kappa) = mathrmRRM(bmX alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(bmX alpha kappa) is the Relativistic Risk Measure as defined in RRM.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::RLVaR, ::AbstractVector), VaR, CVaR, EVaR, WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLVaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrlvar = RLVaR()\n\n# Custom configuration\nrlvar = RLVaR(; alpha = 0.07,   # 7 % significance level\n              kappa = 0.2,      # Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.TG","page":"Risk Measures","title":"PortfolioOptimiser.TG","text":"mutable struct TG{T1 <: Real, T2 <: Real, T3 <: Integer} <: RiskMeasure\n\nDescription\n\nDefines the Tail Gini Difference risk measure.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::TG, ::AbstractVector).\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\nBehaviour\n\nValidation\n\nWhen setting alpha_i at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting alpha at construction or runtime, 0 < alpha_i < alpha < 1.\nWhen setting a_sim at construction or runtime, a_sim > 0.\n\nExamples\n\n# Default settings\ntg = TG()\n\n# Use full risk measure formulation with custom parameters\ntg = TG(; alpha = 0.07, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\ntg = TG(; settings = RMSettings(; flag = false, ub = 0.1),\n        owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Drawdown-risk-measures","page":"Risk Measures","title":"Drawdown risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"MDD\nADD\nUCI\nCDaR\nEDaR\nRLDaR","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD","page":"Risk Measures","title":"PortfolioOptimiser.MDD","text":"struct MDD <: RiskMeasure\n\nDescription\n\nMaximum Drawdown (Calmar ratio) risk measure for uncompounded cumulative returns.\n\nMeasures the largest peak-to-trough decline.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmMDD_a(bmX) = maxmathrmDD_a(bmX)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::MDD, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nmdd = MDD()\n\n# Custom settings\nmdd = MDD(; settings = RMSettings(; scale = 2.0))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD","page":"Risk Measures","title":"PortfolioOptimiser.ADD","text":"struct ADD <: RiskMeasure\n\nDescription\n\nAverage Drawdown risk measure for uncompounded cumulative returns.\n\nMeasures the average of all peak-to-trough declines.\nProvides a more balanced view than the maximum drawdown MDD.\n\nbeginalign\nmathrmADD_a(bmX) = dfrac1T sumlimits_j=1^T mathrmDD_a(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::ADD, ::AbstractVector), ADD_r, MDD.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nadd = ADD()\n\n# Custom settings\nadd = ADD(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI","page":"Risk Measures","title":"PortfolioOptimiser.UCI","text":"mutable struct UCI <: RiskMeasure\n\nDescription\n\nUlcer Index risk measure for uncompounded cumulative returns.\n\nPenalizes larger drawdowns more than smaller ones.\n\nbeginalign\nmathrmUCI_a(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_a(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::UCI, ::AbstractVector), UCI_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nuci = UCI()\n\n# Custom settings\nuci = UCI(; settings = RMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR","page":"Risk Measures","title":"PortfolioOptimiser.CDaR","text":"mutable struct CDaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nConditional Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nMeasures the expected peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmCDaR_a(bmX alpha) = mathrmDaR_a(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_a(bmX j) - mathrmDaR_a(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\nmathrmDaR_a(bmX alpha) is the Drawdown at Risk of uncompounded cumulative returns as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::CDaR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar = CDaR()\n\n# Custom significance level\ncdar = CDaR(; settings = RMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR","page":"Risk Measures","title":"PortfolioOptimiser.EDaR","text":"mutable struct EDaR{T1 <: Real} <: RiskMeasure\n\nDescription\n\nEntropic Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nIt is the upper bound of the Chernoff inequality for the DaR and CDaR.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmEDaR_a(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_a(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_a(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of uncompounded cumulative returns as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::EDaR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EDaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nedar = EDaR()\n\n# Custom configuration with specific solver\nedar = EDaR(; alpha = 0.025,  # 2.5 % significance level\n            solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR","page":"Risk Measures","title":"PortfolioOptimiser.RLDaR","text":"mutable struct RLDaR{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Drawdown at Risk risk measure for uncompounded cumulative returns.\n\nIt is a generalisation of the EDaR.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\nlimlimits_kappa to 0 mathrmRLDaR(bmX alpha kappa) approx mathrmEDaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR(bmX alpha kappa) approx mathrmMDD(bmX)\n\nbeginalign\nmathrmRLDaR_a(bmX alpha kappa) = mathrmRRM(mathrmDD_a(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_a(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of uncompounded cumulative returns as defined in DaR.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, set_rm, calc_risk(::RLDaR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLDaR, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05, # 5 % significance level\n              kappa = 0.3,    # 30 % Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Linear-moments-(L-moments)","page":"Risk Measures","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"This is used to measure linear moments of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"OWA","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.OWA","page":"Risk Measures","title":"PortfolioOptimiser.OWA","text":"mutable struct OWA <: RiskMeasure\n\nDescription\n\nDefines the generic Ordered Weight Array risk measure.\n\nUses a vector of ordered weights generated by owa_l_moment or owa_l_moment_crm for arbitrary L-moment optimisations.\n\nSee also: RiskMeasure, RMSettings, OWASettings, Portfolio, optimise!, set_rm, calc_risk(::OWA, ::AbstractVector), owa_l_moment, owa_l_moment_crm.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nowa::OWASettings = OWASettings(): OWA risk measure settings.\nw::Union{<:AbstractWeights, Nothing} = nothing: T×1 ordered weight vector of arbitrary L-moments generated by owa_l_moment or owa_l_moment_crm.\n\nExamples\n\n# Default settings\nw = owa_l_moment_crm(10)\nowa = OWA(; w = w)\n\n# Use full risk measure formulation with custom parameters\nowa = OWA(; w = w, owa = OWASettings(; approx = false))\n\n# Use more p-norms and constrain risk without adding it to the problem's risk expression\nowa = OWA(; w = w, settings = RMSettings(; flag = false, ub = 0.1),\n          owa = OWASettings(; p = Float64[1, 2, 4, 8, 16, 32, 64, 128]))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Hierarchical-risk-measures","page":"Risk Measures","title":"Hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These risk measures are compatible with . Different risk measures account for different aspects of the returns.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Dispersion-hierarchical-risk-measures","page":"Risk Measures","title":"Dispersion hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure the characteristics of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/#Downside-dispersion-hierarchical-risk-measures","page":"Risk Measures","title":"Downside dispersion hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"SVariance","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.SVariance","page":"Risk Measures","title":"PortfolioOptimiser.SVariance","text":"mutable struct SVariance{T1 <: Real} <: RiskMeasure\n\nDescription\n\nDefines the Semi Variance risk measure.\n\nbeginalign\nmathrmSVariance(bmX) = dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) rright)^2\nendalign\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::SVariance, ::AbstractVector).\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\ntarget::T1 = 0.0: minimum return threshold for downside classification.\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for expected return calculation.\n\nBehaviour\n\nIf w is nothing: computes the unweighted mean portfolio return.\n\nExamples\n\n# Default settings\nsvariance = SVariance()\n\n# Custom configuration with specific target\nw = eweights(1:100, 0.3)  # Exponential weights for computing the portfolio mean return\nsvariance = SVariance(; target = 0.02,  # 2 % return target\n                      settings = HCRMSettings(; scale = 2.0), w = w)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Downside-hierarchical-risk-measures","page":"Risk Measures","title":"Downside hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"VaR","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.VaR","page":"Risk Measures","title":"PortfolioOptimiser.VaR","text":"mutable struct VaR{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Value at Risk risk measure.\n\nMeasures lower bound of the losses in the worst alpha % of cases.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmVaR(bmX alpha) = -undersett in (0 T)inf left X_t in mathbbR    F_bmX(X_t)  alpha right\nendalign\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::VaR, ::AbstractVector), CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nvar = VaR()\n\n# Custom significance level\nvar = VaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Drawdown-hierarchical-risk-measures","page":"Risk Measures","title":"Drawdown hierarchical risk measures","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"DaR\nDaR_r\nMDD_r\nADD_r\nUCI_r\nCDaR_r\nEDaR_r\nRLDaR_r","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR","page":"Risk Measures","title":"PortfolioOptimiser.DaR","text":"mutable struct DaR{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for uncompounded cumulative returns risk measure.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmDaR_a(bmX alpha) = undersetj in (0 T)max left mathrmDD_a(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_a(bmX j)right)  1 - alpha right\nmathrmDD_a(bmX j) = undersett in (0 j)maxleft( sumlimits_i=0^t X_i right) - sumlimits_i=0^j X_i\nmathrmDD_a(bmX) = leftj in (0T)    mathrmDD_a(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns.\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j.\nmathrmDaR_a(bmX alpha) the Drawdown at Risk of uncompounded cumulative returns.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::DaR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR()\n\n# Custom significance level\ndar = DaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.DaR_r","page":"Risk Measures","title":"PortfolioOptimiser.DaR_r","text":"mutable struct DaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for compounded cumulative returns risk measure.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmDaR_r(bmX alpha) = undersetj in (0 T)max left mathrmDD_r(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_r(bmX j)right)  1 - alpha right\nmathrmDD_r(bmX j) = undersett in (0 j)maxleft( prodlimits_i=0^t left(1+X_iright) right) - prodlimits_i=0^j left(1+X_iright)\nmathrmDD_r(bmX) = leftj in (0T)    mathrmDD_r(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns.\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::DaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR_r()\n\n# Custom significance level\ndar = DaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.MDD_r","page":"Risk Measures","title":"PortfolioOptimiser.MDD_r","text":"mutable struct MDD_r <: HCRiskMeasure\n\nDescription\n\nMaximum Drawdown (Calmar ratio) risk measure for compounded cumulative returns.\n\nMeasures the largest peak-to-trough decline.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmMDD_r(bmX) = max mathrmDD_r(bmX)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::MDD_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nmdd = MDD_r()\n\n# Custom significance level\nmdd = MDD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.ADD_r","page":"Risk Measures","title":"PortfolioOptimiser.ADD_r","text":"mutable struct ADD_r <: HCRiskMeasure\n\nDescription\n\nAverage Drawdown risk measure for uncompounded cumulative returns.\n\nMeasures the average of all peak-to-trough declines.\nProvides a more balanced view than the maximum drawdown MDD_r.\n\nbeginalign\nmathrmADD_r(bmX) = dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, calc_risk(::ADD_r, ::AbstractVector), ADD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nadd = ADD_r()\n\n# Custom significance level\nadd = ADD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.UCI_r","page":"Risk Measures","title":"PortfolioOptimiser.UCI_r","text":"mutable struct UCI_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nUlcer Index risk measure for compounded cumulative returns.\n\nPenalizes larger drawdowns more than smaller ones.\n\nbeginalign\nmathrmUCI_r(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::UCI_r, ::AbstractVector), UCI.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nuci_r = UCI_r()\n\n# Custom settings\nuci_r = UCI_r(; settings = HCRMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.CDaR_r","page":"Risk Measures","title":"PortfolioOptimiser.CDaR_r","text":"mutable struct CDaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nConditional Drawdown at Risk risk measure for compounded cumulative returns.\n\nMeasures the expected peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmCDaR_r(bmX alpha) = mathrmDaR_r(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_r(bmX j) - mathrmDaR_r(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, calc_risk(::CDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar_r = CDaR_r()\n\n# Custom significance level\ncdar_r = CDaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.EDaR_r","page":"Risk Measures","title":"PortfolioOptimiser.EDaR_r","text":"mutable struct EDaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nEntropic Drawdown at Risk risk measure for compounded cumulative returns.\n\nIt is the upper bound of the Chernoff inequality for the DaR and CDaR.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, Portfolio, optimise!, calc_risk(::EDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing calc_risk(::EDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nedar_r = EDaR_r()\n\n# Custom configuration with specific solver\nedar_r = EDaR_r(; alpha = 0.025,  # 2.5 % significance level\n                solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.RLDaR_r","page":"Risk Measures","title":"PortfolioOptimiser.RLDaR_r","text":"mutable struct RLDaR_r{T1 <: Real} <: RiskMeasure\n\nDescription\n\nRelativistic Drawdown at Risk risk measure for compounded cumulative returns.\n\nIt is a generalisation of the EDaR.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\nlimlimits_kappa to 0 mathrmRLDaR_r(bmX alpha kappa) approx mathrmEDaR_r(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR_r(bmX alpha kappa) approx mathrmMDD_r(bmX)\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, calc_risk(::RLDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR_r, MDD, MDD_r.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{<:AbstractDict, Nothing}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing calc_risk(::RLDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05, # 5 % significance level\n              kappa = 0.3,    # 30 % Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures/#Equal-risk-contribution","page":"Risk Measures","title":"Equal risk contribution","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"This assumes the risk is equally distributed among the variables.","category":"page"},{"location":"RiskMeasures/RiskMeasures/","page":"Risk Measures","title":"Risk Measures","text":"Equal","category":"page"},{"location":"RiskMeasures/RiskMeasures/#PortfolioOptimiser.Equal","page":"Risk Measures","title":"PortfolioOptimiser.Equal","text":"struct Equal <: HCRiskMeasure\n\nDescription\n\nEqual risk measure.\n\nRisk is allocated evenly among a group of assets.\n\nFields\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nequal = Equal()\n\n# Custom configuration\nequal = Equal(; settings = HCRMSettings(; scale = 3))\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#Distance-matrices","page":"Distance matrices","title":"Distance matrices","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#Public","page":"Distance matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistCanonical","text":"struct DistCanonical <: DistType end\n\nStruct for computing the canonical distance for a given correlation estimator in default_dist.\n\nCorrelation estimator Canonical distance\nCovMutualInfo DistVarInfo\nCovLTD DistLog\nCovDistance DistCor\nAny other estimator DistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistCor","text":"struct DistCor <: DistType end\n\nDefines the distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCanonical","text":"struct DistDistCanonical <: DistType end\n\nStruct for computing the canonical distance for a given correlation estimator in default_dist.\n\nCorrelation estimator Canonical distance\nCovMutualInfo DistDistVarInfo\nCovLTD DistDistLog\nCovDistance DistDistCor\nAny other estimator DistDistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCor","text":"struct DistdistCor <: DistType end\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistDistLog","text":"@kwdef mutable struct DistDistLog <: DistType\n    distance::Distances.Metric\n    args::Tuple\n    kwargs::NamedTuple\nend\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistDistMLP","text":"@kwdef mutable struct DistDistMLP <: DistType\n    absolute::Bool = false\n    distance::Distances.Metric = Distances.Euclidean()\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the distance of distances matrix from a correlation matrix [2] in dist.\n\nbeginalign\ntildeD_ij = f_mleft(bmD_i bmD_jright)\nendalign\n\nWhere:\n\nbmD_i: is the i-th column/row of the N×N distance matrix defined in DistMLP.\nf_m: is the pairwise distance function for metric m. We use the Distances.pairwise function which computes the entire matrix at once.\ntildeD_ij: is the (ij)-th entry of the N×N distances of distances matrix.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistDistVarInfo","text":"@kwdef mutable struct DistDistVarInfo <: DistType\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance of distances matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistLog","text":"struct DistLog <: DistType end\n\nDefines the log-distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistMLP","text":"@kwdef mutable struct DistMLP <: DistType\n    absolute::Bool = false\nend\n\nDefines the distance matrix from a correlation matrix [2] in dist.\n\nbeginalign\nD_ij = \n    begincases\n        sqrtdfrac12 left(1 - C_ijright) quad mathrmif absolute = false\n        sqrt1 - lvert C_ij rvert quad mathrmif absolute = true\n    endcases\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix mathbfC.\nC_ij: is the (ij)-th entry of the N×N correlation matrix mathbfD.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistVarInfo","text":"@kwdef mutable struct DistVarInfo <: DistType\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Freedman","page":"Distance matrices","title":"PortfolioOptimiser.Freedman","text":"struct Freedman <: AstroBins end\n\nFreedman's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.GenDistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.GenDistDistMLP","text":"mutable struct GenDistDistMLP{T1} <: DistType\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.GenDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.GenDistMLP","text":"mutable struct GenDistMLP{T1} <: DistType\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.HGR","page":"Distance matrices","title":"PortfolioOptimiser.HGR","text":"struct HGR <: AbstractBins end\n\nHacine-Gharbi and Ravier's bin width algorithm [3].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Knuth","page":"Distance matrices","title":"PortfolioOptimiser.Knuth","text":"struct Knuth <: AstroBins end\n\nKnuth's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Scott","page":"Distance matrices","title":"PortfolioOptimiser.Scott","text":"struct Scott <: AstroBins end\n\nScott's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.dist-Tuple{GenDistMLP, AbstractMatrix, Any}","page":"Distance matrices","title":"PortfolioOptimiser.dist","text":"dist(de::GenDistMLP, X::AbstractMatrix, ::Any)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/DistanceMatrices/#Private","page":"Distance matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/","page":"Distance matrices","title":"Distance matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/DistanceMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DistanceMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AbstractBins","page":"Distance matrices","title":"PortfolioOptimiser.AbstractBins","text":"abstract type AbstractBins end\n\nAbstract type for defining the bin width estimation functions when computing DistVarInfo and CovMutualInfo distance and correlation matrices respectively.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AstroBins","page":"Distance matrices","title":"PortfolioOptimiser.AstroBins","text":"abstract type AstroBins <: AbstractBins end\n\nAbstract type for defining which bin width function to use from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistType","page":"Distance matrices","title":"PortfolioOptimiser.DistType","text":"abstract type DistType end\n\nAbstract type for subtyping types for computing distance matrices from correlation ones.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.default_dist-Tuple{DistCanonical, PortCovCor}","page":"Distance matrices","title":"PortfolioOptimiser.default_dist","text":"default_dist(dist_type::DistCanonical, cor_type::PortCovCor)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/LoGoMatrix/#Detone-matrix","page":"Detone matrix","title":"Detone matrix","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/#Public","page":"Detone matrix","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/","page":"Detone matrix","title":"Detone matrix","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/LoGoMatrixTypes.jl\",\n\"ParameterEstimation/Functions/LoGoMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.LoGo","page":"Detone matrix","title":"PortfolioOptimiser.LoGo","text":"@kwdef mutable struct LoGo <: AbstractLoGo\n    distance::DistType = DistMLP()\n    similarity::DBHTSimilarity = DBHTMaxDist()\nend\n\nCompute the LoGo covariance and correlation matrix estimator.\n\nParameters\n\ndistance: type for computing the distance (disimilarity) matrix from the correlation matrix if the distance matrix is not provided to logo!.\nsimilarity: type for computing the similarity matrix from the correlation and distance matrices. The distance matrix is used to compute sparsity pattern of the inverse of the LoGo covariance and correlation matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.NoLoGo","page":"Detone matrix","title":"PortfolioOptimiser.NoLoGo","text":"struct NoLoGo <: AbstractLoGo end\n\nLeave the matrix as is.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.logo!","page":"Detone matrix","title":"PortfolioOptimiser.logo!","text":"logo!(::NoLoGo, ::AbstractPosdefFix, ::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.logo!-2","page":"Detone matrix","title":"PortfolioOptimiser.logo!","text":"logo!(je::LoGo, posdef::AbstractPosdefFix, X::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/LoGoMatrix/#Private","page":"Detone matrix","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/","page":"Detone matrix","title":"Detone matrix","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/LoGoMatrixTypes.jl\",\n\"ParameterEstimation/Functions/LoGoMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.AbstractLoGo","page":"Detone matrix","title":"PortfolioOptimiser.AbstractLoGo","text":"abstract type AbstractLoGo end\n\nAbstract type for subtyping LoGo covariance and correlation matrix estimators.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskStatistics/#Risk-statistics","page":"Risk statistics","title":"Risk statistics","text":"","category":"section"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"It is possible to compute risk-derived statistics given a RiskMeasure/HCRiskMeasure, a vector of weights, and other relevant data.","category":"page"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"risk_bounds(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector, ::AbstractVector)\nrisk_contribution(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)\nfactor_risk_contribution(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)\nsharpe_ratio(::PortfolioOptimiser.AbstractRiskMeasure, ::AbstractVector)","category":"page"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_bounds-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_bounds","text":"risk_bounds(rm::AbstractRiskMeasure, w1::AbstractVector, w2::AbstractVector;\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0), delta::Real = 1e-6,\n            scale::Bool = false, kwargs...)\n\nDescription\n\nCompute the risk bounds for an AbstractRiskMeasure and pair of asset weight vectors.\n\nSee also: AbstractRiskMeasure, calc_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\nV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the coskewness.\nSV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nscale::Bool = false: flag for scaling the kurtosis and semi kurtosis in risk_contribution.\n\nOutputs\n\nr1::Real: lower risk bound/risk corresponding to w1.\nr2::Real: upper risk bound/risk corresponding to w2.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw1 = [0.7, 0.2, 0.1]\nw2 = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nr1, r2 = risk_bounds(CVaR(), w1, w2; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                  X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  delta::Real = 1e-6, marginal::Bool = false, \n                  kwargs...)\n\nDescription\n\nCompute the asset risk contribution for an AbstractRiskMeasure and asset weight vector.\n\nSee also: AbstractRiskMeasure, risk_bounds, calc_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nmarginal::Bool = false:\nif true: compute the marginal risk contribution.\nelse: compute the risk contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc::AbstractVector: N×1 vector of risk contribution per asset.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nrc = risk_contribution(CVaR(), w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                        X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        assets::AbstractVector = Vector{String}(undef, 0),\n                        F::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        f_assets::AbstractVector = Vector{String}(undef, 0),\n                        B::DataFrame = DataFrame(),\n                        regression_type::RegressionType = FReg(),\n                        delta::Real = 1e-6, kwargs...)\n\nDescription\n\nCompute the factor risk contribution for an AbstractRiskMeasure, assets, and factors.\n\nSee also: AbstractRiskMeasure, risk_bounds, calc_risk, regression, RegressionType.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure AbstractRiskMeasure.\nw::AbstractVector: Na×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Na matrix of asset returns.\nassets::AbstractVector = Vector{String}(undef, 0): Na×1 vector of asset names.\nF::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Nf matrix of factor returns.\nf_assets::AbstractVector = Vector{String}(undef, 0): Nf× vector of factor names.\nB::DataFrame = DataFrame(): optional Na×Nf loadings matrix.\nregression_type::RegressionType = FReg(): regression type used for computing the loadings matrix.\ndelta::Real = 1e-6: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nBehaviour\n\nIf B is empty: computes the loadings matrix, B, via regression using regression_type, F, f_assets, X, assets.\n\nOutputs\n\nrc_f::AbstractVector: Nf×1 vector of risk contribution per factor.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.57 -0.54 -0.15  0.42 -1.78;\n           -0.12 -0.02 -0.04  1.61  0.74;\n            0.09  2.58 -0.40 -0.36 -1.07;\n           -1.33 -1.13  0.35 -0.89 -1.01;\n            0.59 -1.48  0.01 -1.79 -0.18;\n            0.22  0.39 -0.04  0.22  0.64;\n            2.39  0.05 -0.24  0.76 -0.08;\n           -0.22 -0.66  0.51  1.21 -0.36;\n            1.56 -0.39  2.13  0.01  1.77;\n            0.88  0.49 -1.24  1.24  0.71]\n\n# Asset names\nassets = [\"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]\n\n# Sample factor returns matrix\nf_returns = [ 3.00  1.55;\n              0.52 -0.57;\n             -0.27  0.71;\n              0.30  0.00;\n              2.27  1.10;\n              0.23  1.33;\n              0.64  0.00;\n              0.35  1.02;\n             -1.33 -1.60;\n              0.49 -1.66]\n\n# Factor names\nf_assets = [\"F1\", \"F2\"]\n\n# Sample asset weights vector\nw = [0.15, 0.1, 0.3, 0.2, 0.25]\n\n# Risk measure\ncvar_rm = CVaR()\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# the default parameters.\nfc1 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets)\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# a different regression type.\nfc2 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets, regression_type = BReg())\n\n# Provide the loadings matrix directly.\nB = DataFrame(:tickers => assets,\n              :const => [0.019628056331070173, -0.4630372691196401, -0.051116594784858346,\n                         0.6244845397620361, -0.46039779836908995],\n              :F1 => [-0.5382419657683666, 0.0, -0.5447539204822568, 0.0,\n                      -0.4713171689983393],\n              :F2 => [0.0, -0.48659032199680796, 0.44882375725309853, -0.23791307331955935,\n                      0.0])\n\nfc3 = factor_risk_contribution(cvar_rm, w; X = returns, F = f_returns, B = B)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(rm::AbstractRiskMeasure, w::AbstractVector;\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            delta::Real = 1e-6, rf::Real = 0.0, \n            kelly::Bool = false)\n\nDescription\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure and asset weights vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: N×1 vector of asset weights.\nmu: N×1 vector of expected returns.\nX: T×N matrix of asset returns.\nV: N×N matrix of the sum of negative spectral slices of the coskewness.\nSV: N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Black-Litterman-models","page":"Black Litterman models","title":"Black Litterman models","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#Public","page":"Black Litterman models","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.ABLType","page":"Black Litterman models","title":"PortfolioOptimiser.ABLType","text":"@kwdef mutable struct ABLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool = true\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::AbstractPosdefFix = PosdefNearest()\n    denoise::AbstractDenoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Augmented Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nbmPi_a = begincases\n                    deltabeginbmatrix\n                      mathbfSigma\n                      mathbfSigma_F mathbfB^intercal\n                      endbmatrix bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases\nmathbfP_a =  beginbmatrix\n                      mathbfP  mathbf0\n                      mathbf0  mathbfP_F\n                    endbmatrix\nbmQ_a =  beginbmatrix\n                bmQ\n                bmQ_F\n                endbmatrix\nmathbfSigma_a =  beginbmatrix\n                            mathbfSigma  mathbfB mathbfSigma_F\n                            mathbfSigma_F mathbfB^intercal  mathbfSigma_F\n                          endbmatrix\nmathbfOmega_a =  beginbmatrix\n                            mathbfOmega  mathbf0\n                            mathbf0  mathbfOmega_F\n                          endbmatrix\nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\nmathbfM_a = left left(tau  mathbfSigma_a right)^-1 + mathbfP_a^intercal mathbfOmega_a^-1 mathbfP_aright^-1\nbmPi_mathrmABL = mathbfM_a leftleft(tau mathbfSigma_aright)^-1 bmPi_a + mathbfP_a^intercal mathbfOmega_a^-1 mathbfQ_a right\ntau = dfrac1T\nbmmu_mathrmABL = bmPi_mathrmABL + r\nmathbfSigma_mathrmABL = mathbfSigma_a + mathbfM_a\nendalign\n\nWhere:\n\nbmPi_a:\nif error is true: is the Na×1 augmented equilibrium excess returns vector.\nelse: is the Na×1 historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the Na×Na asset covariance matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfP_a: is the (Nva+Nvf)×(Na+Nf) augmented views matrix. The zeros pad the matrix so all columns and rows are of equal length.\nmathbfP: is the Nva×Na asset views matrix.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nbmQ_a: is the (Nva+Nvf)×1 augmented views returns vector.\nbmQ: is the Nva×1 asset views returns vector.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_a: is the (Na+Nf)×(Na+Nf) augmented covariance matrix.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfOmega_a: is the (Nva+Nvf)×(Nva+Nvf) covariance matrix of the errors of the augmented views.\nmathbfOmega: is the Nva×Nva covariance matrix of the errors of the asset views.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nmathbfM_a: is an (Na+Nf)×(Na+Nf) intermediate covariance matrix.\nbmPi_mathbfABL: is the Na×1 equilibrium excess returns vector after being adjusted by the augmented views.\nT: is the number of returns observations.\nbmmu_mathbfABL: is the Na×1 vector of asset expected returns obtained via the Augmented Black-Litterman model.\nmathbfSigma_mathrmABL: is the Na×Na asset covariance matrix obtained via the Augmented Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: type for fixing non positive Augmented Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Augmented Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Augmented Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BBLType","page":"Black Litterman models","title":"PortfolioOptimiser.BBLType","text":"mutable struct BBLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool\n    error::Bool\n    delta::Union{<:Real, Nothing}\n    rf::T1\n    ve::StatsBase.CovarianceEstimator\n    var_w::Union{<:AbstractWeights, Nothing}\n    posdef::AbstractPosdefFix\n    denoise::AbstractDenoise\n    logo::AbstractLoGo\nend\n\nDefines the parameters for computing the Bayesian Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nmathbfSigma = mathbfB mathbfSigma_F mathbfB^intercal + mathbfSigma_epsilon \nmathbfSigma_epsilon = begincasesmathrmDiagonalleft(mathrmvarleft(mathbfX - mathbfF mathbfB^intercal mathrmdims = 1right)right) quad mathrmif error = true\nmathbf0 quad mathrmif error = false\nendcases\noverlinemathbfSigma_F = left(mathbfSigma_F^-1 + mathbfP_F^intercal mathbfOmega_F^-1 mathbfP_Fright)^-1\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\ntau = dfrac1T\noverlinebmPi_F = overlinemathbfSigma_F left(mathbfSigma_F^-1 bmPi_F + mathbfP_F^intercal mathbfOmega_F^-1 bmQ_Fright)\nbmPi_F = bmmu_F - r\nmathbfSigma_mathrmBF = mathbfSigma^-1 mathbfB left( overlinemathbfSigma_F + mathbfB^intercal mathbfSigma^-1 mathbfB right)^-1\nmathbfSigma_mathrmBLB = left(mathbfSigma^-1 - mathbfSigma_mathrmBF mathbfB^intercal mathbfSigma^-1right)^-1\nbmmu_mathrmBLB = mathbfSigma_mathrmBLB mathbfSigma_mathrmBF overlinemathbfSigma_F overlinebmPi_F + r\nendalign\n\nWhere:\n\nmathbfSigma: is the Na×Na estimated asset covariance matrix computed using the factor model.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfSigma_epsilon: is an Na×Na diagonal matrix constructed from the variances of the errors between the asset and estimated asset returns using the factor model.\nmathbfX: is the T×Na matrix of asset returns.\nmathbfF: is the T×Nf matrix of factor returns.\noverlinemathbfSigma_F: is the Nf×Nf posterior covariance matrix of the factors after adjusting by the factor views.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nT: is the number of returns observations.\noverlinebmPi_F: is the Nf×1 posterior equilibrium excess returns vector of the factors after adjusting by the factor views.\nbmPi_F: is the Nf×1 equilibrium excess returns vector of the factors.\nbmmu_F: is the Nf×1 factor expected returns vector.\nr: is the risk-free rate.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_mathrmBF: is an Na×Nf intermediate covariance matrix,.\nmathbfSigma_mathrmBLB: is the Na×Na posterior asset covariance matrix, aka the asset covariance matrix obtained via the Bayesian Black-Litterman model.\nbmmu_mathrmBLB: is the Na×1 posterior asset expected returns vector, aka the asset returns vector obtained via the Bayesian Black-Litterman model.\n\nParameters\n\nconstant:\nif true: the loadings matrix contains the constant term as its first column.\nelse: the loadings matrix does not contain the constant term.\nerror:\nif true: correct the estimated asset covariance matrix by adding the variances of the errors between the actual returns and factor estimated returns.\n\nnote: Note\nOnly useful when the factor model is based on a regression model.\n\ndelta: risk aversion factor.\nrf: risk free rate.\nve: StatsBase.CovarianceEstimator for computing the errors covariance.\nvar_w: optional weights for computing the errors covariance.\nposdef: type for fixing non positive Bayesian Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Bayesian Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Bayesian Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BLType","page":"Black Litterman models","title":"PortfolioOptimiser.BLType","text":"@kwdef mutable struct BLType{T1 <: Real} <: BlackLitterman\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::AbstractPosdefFix = PosdefNearest()\n    denoise::AbstractDenoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Black-Litterman model black_litterman. We define N as the number of assets, and Nv the number of asset views.\n\nbeginalign\nbmPi = begincases\n                    delta mathbfSigma bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases                            \nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfM = left left(tau  mathbfSigma right)^-1 + mathbfP^intercal mathbfOmega^-1 mathbfPright^-1\nbmPi_mathrmBL = mathbfM leftleft(tau mathbfSigmaright)^-1 bmPi + mathbfP^intercal mathbfOmega^-1 mathbfQ right\ntau = dfrac1T\nbmmu_mathrmBL = bmPi_mathrmBL + r\nmathbfSigma_mathrmBL = mathbfSigma + mathbfM\nendalign\n\nWhere:\n\nbmPi:\nif error is true: is N×1 the equilibrium excess returns vector.\nelse: is N×1 the historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the N×N asset covariance matrix.\nbmw: is the N×1 vector of benchmark asset weights.\nmathbfP: is the Nv×N asset views matrix.\nbmQ: is the Nv×1 asset views returns vector.\nmathbfOmega: is the Nv×Nv covariance matrix of the errors of the asset views.\nmathbfM: is an N×N intermediate covariance matrix, and M the number of assets.\nbmPi_mathbfBL: is the N×1 equilibrium excess returns after being adjusted by the views.\nT: is the number of returns observations.\nbmmu_mathbfBL: is the N×1 vector of asset expected returns obtained via the Black-Litterman model.\nmathbfSigma_mathrmBL: is the N×N asset covariance matrix obtained via the Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: type for fixing non positive Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.black_litterman-Tuple{BLType, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}","page":"Black Litterman models","title":"PortfolioOptimiser.black_litterman","text":"black_litterman(bl::BLType, X::AbstractMatrix, P::AbstractMatrix,\n                         Q::AbstractVector, w::AbstractVector;\n                         cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                         mu_type::MeanEstimator = MuSimple())\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Private","page":"Black Litterman models","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/","page":"Black Litterman models","title":"Black Litterman models","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/BlackLittermanTypes.jl\",\n\"ParameterEstimation/Functions/BlackLittermanFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BlackLittermanFactor","page":"Black Litterman models","title":"PortfolioOptimiser.BlackLittermanFactor","text":"abstract type BlackLittermanFactor <: BlackLitterman end\n\nAbstract type for subtyping Black Litterman models.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.bl_mu_cov_w-NTuple{13, Any}","page":"Black Litterman models","title":"PortfolioOptimiser.bl_mu_cov_w","text":"_mu_cov_w(tau, omega, P, Pi, Q, rf, sigma, delta, T, N, opt, cov_type, cov_flag = true)\n\nInternal function for computing the Black Litterman statistics as defined in black_litterman. See .\n\nInputs\n\ntau: variable of the same name in the Black-Litterman model.\nomega: variable of the same name in the Black-Litterman model.\nP: variable of the same name in the Black-Litterman model.\nPi: variable of the same name in the Black-Litterman model.\nQ: variable of the same name in the Black-Litterman model.\nrf: variable of the same name in the Black-Litterman model.\nsigma: variable of the same name in the Black-Litterman model.\ndelta: variable of the same name in the Black-Litterman model.\nT: variable of the same name in the Black-Litterman model.\nN: variable of the same name in the Black-Litterman model.\nopt: any valid instance of opt for .\ncov_type: any valid value from .\ncov_flag: whether the matrix is a covariance matrix or not.\n\nOutputs\n\nmu: asset expected returns vector obtained via the Black-Litterman model.\ncov_mtx: asset covariance matrix obtained via the Black-Litterman model.\nw: asset weights obtained via the Black-Litterman model.\nPi_: equilibrium excess returns after being adjusted by the views.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/#Public","page":"Statistics","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.asset_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.asset_statistics!","text":"asset_statistics!(port::AbstractPortfolio;\n                  cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cov::Bool = true, mu_type::MeanEstimator = MuSimple(),\n                  set_mu::Bool = true, kurt_type::KurtFull = KurtFull(),\n                  set_kurt::Bool = true, skurt_type::KurtSemi = KurtSemi(),\n                  set_skurt::Bool = true, skew_type::SkewFull = SkewFull(),\n                  set_skew::Bool = true, sskew_type::SkewSemi = SkewSemi(),\n                  set_sskew::Bool = true,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cor::Bool = true,\n                  dist_type::DistType = DistCanonical(),\n                  set_dist::Bool = true)\n\nCompute the asset statistics for a portfolio. See the argument types' docs for details. If a statistic requires another to be computed, the funciton will do so from the relevant estimator.\n\nThe set_* variables are flags for deciding whether or not to set the statistic. If a statistic's flag is false the statistic will not be set. Furthermore, if the flag is false and the statistic is not required by another one, it will not be computed.\n\nInputs\n\nport: portfolio AbstractPortfolio.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nset_cov: flag for setting port.cov\nmu_type: expected returns estimator MeanEstimator.\nset_mu: flag for setting port.mu\nkurt_type: cokurtosis matrix estimator KurtFull.\nset_kurt: flag for setting port.kurt.\nskurt_type: cokurtosis matrix estimator KurtSemi.\nset_skurt: flag for setting port.skurt.\nskew_type: coskew estimator SkewFull.\nset_skew: set port.skew and port.V.\nsskew_type: semi coskew estimator SkewSemi.\nset_sskew: set port.skew and port.SV.\n\nOnly relevant for .\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\nset_cor: flag for setting port.cor.\ndist_type: type for computing the distance matrix DistType. asset_statistics! uses default_dist to ensure the computed distance is consistent with dist_type and either cor_type.ce or cor_type whichever is applicable.\nset_dist: flag for setting port.dist.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_factor_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_factor_statistics!","text":"black_litterman_factor_statistics!(port::AbstractPortfolio;\n                                   w::AbstractVector = port.bl_bench_weights,\n                                   B::Union{DataFrame, Nothing} = port.loadings,\n                                   P::Union{AbstractMatrix, Nothing} = nothing,\n                                   P_f::Union{AbstractMatrix, Nothing} = nothing,\n                                   Q::Union{AbstractVector, Nothing} = nothing,\n                                   Q_f::Union{AbstractVector, Nothing} = nothing,\n                                   factor_type::FactorType = FactorType(),\n                                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   mu_type::MeanEstimator = MuSimple(),\n                                   f_cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   f_mu_type::MeanEstimator = MuSimple(),\n                                   bl_type::BlackLittermanFactor = BBLType())\n\nCompute the Black Litterman factor model statistics. Na is the number of assets, Nva is the number of asset views, Nf is the number of factors, Nvf is the number of factors views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\nB: loadings matrix.\nif isempty(B): computes the loadings matrix using factor_type.\nP: Nva×Na matrix of asset views.\nP_f: Nvf×Nf matrix of factor views.\nQ: Nva×1 vector of asset views.\nQ_f: Nvf×1 vector of factor views.\nfactor_type: factor statistics estimator FactorType.\ncov_type: asset covariance estimator PortfolioOptimiserCovCor.\nmu_type: asset expected returns estimator MeanEstimator.\nf_cov_type: factor covariance estimator PortfolioOptimiserCovCor.\nf_mu_type: factor expected returns estimator MeanEstimator.\nbl_type: Black Litterman factor model estimator BlackLittermanFactor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_statistics!","text":"black_litterman_statistics!(port::AbstractPortfolio; P::AbstractMatrix, Q::AbstractVector,\n                            w::AbstractVector = port.bl_bench_weights,\n                            cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                            mu_type::MeanEstimator = MuSimple(),\n                            bl_type::BLType = BLType())\n\nCompute the factor statistics. N is the number of assets, Nv is the number of asset views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nP: Nv×N matrix of asset views.\nQ: Nv×1 vector of asset views.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\nbl_type: Black Litterman model estimator BLType.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.factor_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.factor_statistics!","text":"factor_statistics!(port::AbstractPortfolio; factor_type::FactorType = FactorType(),\n                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                   mu_type::MeanEstimator = MuSimple())\n\nCompute the factor statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nfactor_type: factor statistics estimator FactorType.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.wc_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.wc_statistics!","text":"wc_statistics!(port::Portfolio; wc_type::WCType = WCType(), set_box::Bool = true,\n                        set_ellipse::Bool = true)\n\nCompute the worst case mean-variance statistics. Only used in  optimisations. The set_* variables are used to compute and set the relevant statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nwc: worst-case mean-variance statistics estimator WCType.\nset_box:\nif true: compute and set the box uncertainty sets, port.cov_l, port.cov_u, port.d_mu.\nset_ellipse:\nif true: compute and set the elliptical uncertainty sets and parameters, port.cov_mu, port.cov_sigma, port.k_mu, port.k_sigma.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Private","page":"Statistics","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/","page":"Statistics","title":"Statistics","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioStatistics.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#Portfolio-classes","page":"Portfolio classes","title":"Portfolio classes","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#Public","page":"Portfolio classes","title":"Public","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BL","page":"Portfolio classes","title":"PortfolioOptimiser.BL","text":"@kwdef mutable struct BL{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BLFM","page":"Portfolio classes","title":"PortfolioOptimiser.BLFM","text":"@kwdef mutable struct BLFM{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.Classic","page":"Portfolio classes","title":"PortfolioOptimiser.Classic","text":"struct Classic <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FC","page":"Portfolio classes","title":"PortfolioOptimiser.FC","text":"@kwdef mutable struct FC <: PortClass\n    flag::Bool = true\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FM","page":"Portfolio classes","title":"PortfolioOptimiser.FM","text":"@kwdef mutable struct FM{T1 <: Integer} <: PortClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#Private","page":"Portfolio classes","title":"Private","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/","page":"Portfolio classes","title":"Portfolio classes","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/PortfolioClassTypes.jl\"]","category":"page"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BlackLittermanClass","page":"Portfolio classes","title":"PortfolioOptimiser.BlackLittermanClass","text":"abstract type BlackLittermanClass <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.PortClass","page":"Portfolio classes","title":"PortfolioOptimiser.PortClass","text":"abstract type PortClass end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#Detone-matrix","page":"Detone matrix","title":"Detone matrix","text":"","category":"section"},{"location":"ParameterEstimation/DetoneMatrix/#Public","page":"Detone matrix","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DetoneMatrix/","page":"Detone matrix","title":"Detone matrix","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/DetoneMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DetoneMatrixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/DetoneMatrix/#PortfolioOptimiser.Detone","page":"Detone matrix","title":"PortfolioOptimiser.Detone","text":"mutable struct Detone{T1} <: AbstractDetone\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#PortfolioOptimiser.NoDetone","page":"Detone matrix","title":"PortfolioOptimiser.NoDetone","text":"struct NoDetone <: AbstractDetone end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#Private","page":"Detone matrix","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/DetoneMatrix/","page":"Detone matrix","title":"Detone matrix","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/DetoneMatrixTypes.jl\",\n\"ParameterEstimation/Functions/DetoneMatrixFunctions.jl\"]","category":"page"},{"location":"Portfolio/PortfolioRisk/#Risk","page":"Risk","title":"Risk","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/#Public","page":"Risk","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.calc_risk","page":"Risk","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.factor_risk_contribution","page":"Risk","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                         F::AbstractMatrix = port.f_returns,\n                         type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n                         rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6)\n\nCompute the factor risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nw: Na×1 vector of asset weights.\nX: T×Na matrix of asset returns.\nF: T×Nf matrix of factor returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nOutputs\n\nrc_f: Nf×1 vector of risk contribution per factor.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.number_effective_assets","page":"Risk","title":"PortfolioOptimiser.number_effective_assets","text":"number_effective_assets(port; type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP)\n\nCompute the number of effective assets.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.risk_contribution","page":"Risk","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n                  rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6,\n                  marginal::Bool = false)\n\nCompute the asset risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nmarginal:\nif true: compute the marginal risk contribution.\nelse: compute the risk by contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc: Na×1 vector of risk contribution per asset.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.sharpe_ratio","page":"Risk","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n             mu::AbstractVector = port.mu,\n             type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n             rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6, rf::Real = 0.0,\n             kelly::Bool = false)\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N matrix of asset returns.\nmu: N×1 vector of expected returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#Private","page":"Risk","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/","page":"Risk","title":"Risk","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioRisk.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets!-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets!","text":"cluster_assets!(port::Union{HCPortfolio, Portfolio}; clust_alg::ClustAlg = HAC(),\n                clust_opt::ClustOpt = ClustOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. Save the results in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio .\nclust_alg: hierarchical clustering algorithm ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::Union{HCPortfolio, Portfolio}; clust_alg::ClustAlg = HAC(),\n               clust_opt::ClustOpt = ClustOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio .\nclust_alg: hierarchical clustering algorithm ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioClustering.jl\"]","category":"page"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.clusterise","page":"Clustering","title":"PortfolioOptimiser.clusterise","text":"clusterise(ca::HAC, port::Union{HCPortfolio, Portfolio}, clust_opt::ClustOpt = ClustOpt())\n\nUse Clustering.hclust to hierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: linkage for Clustering.hclust.\nport: hierarchical clustering portfolio .\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.clusterise-2","page":"Clustering","title":"PortfolioOptimiser.clusterise","text":"clusterise(ca::DBHT, port::Union{HCPortfolio, Portfolio}, clust_opt::ClustOpt = ClustOpt())\n\nUse DBHTs to hierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: [DBHT] options for clustering with DBHTs.\nport: hierarchical clustering portfolio .\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Constraints/ViewsConstraints/#Views-constraints","page":"Views constraints","title":"Views constraints","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/#Public","page":"Views constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.asset_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.asset_views","text":"asset_views(views::DataFrame, asset_sets::DataFrame)\n\nCreate the asset views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×9 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nType: (String) specifies the object(s) to which a view applies:\nAsset: specific asset.\nSubset: whole class.\nSet: (String) if Type is Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the view applies.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nReturn: (<:Real) the view's return.\nRelative_Type: (String) specifies to what the view is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative view.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nP: Nv×Na matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nviews = DataFrame(\"Enabled\" => [true, true, true, true, true],\n                  \"Type\" => [\"Asset\", \"Subset\", \"Subset\", \"Asset\", \"Subset\"],\n                  \"Set\" => [\"\", \"Class 2\", \"Class 1\", \"\", \"Class 1\"],\n                  \"Position\" => [\"WFC\", \"Financial\", \"Equity\", \"FB\", \"Fixed Income\"],\n                  \"Sign\" => [\"<=\", \">=\", \">=\", \">=\", \"<=\"],\n                  \"Return\" => [0.3, 0.1, 0.05, 0.03, 0.017],\n                  \"Relative_Type\" => [\"Asset\", \"Subset\", \"Asset\", \"\", \"\"],\n                  \"Relative_Set\" => [\"\", \"Class 1\", \"\", \"\", \"\"],\n                  \"Relative_Position\" => [\"FB\", \"Fixed Income\", \"TLT\", \"\", \"\"])\nP, Q = asset_views(views, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.factor_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.factor_views","text":"factor_views(views::DataFrame, loadings::DataFrame)\n\nCreate the factor views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×4 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nFactor: (String) name of the view's factor.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the view is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nP: Nv×Nf matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nviews = DataFrame(\"Enabled\" => [true, true, true], \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\"],\n                  \"Sign\" => [\"<=\", \"<=\", \">=\"], \"Value\" => [0.9, -1.2, 0.3],\n                  \"Relative_Factor\" => [\"USMV\", \"\", \"\"])\nP, Q = factor_views(views, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#Private","page":"Views constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/","page":"Views constraints","title":"Views constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/ViewsConstraintFunctions.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#Objective-functions","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#Public","page":"Objective functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MaxRet","page":"Objective functions","title":"PortfolioOptimiser.MaxRet","text":"struct MaxRet <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MinRisk","page":"Objective functions","title":"PortfolioOptimiser.MinRisk","text":"struct MinRisk <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Sharpe","page":"Objective functions","title":"PortfolioOptimiser.Sharpe","text":"@kwdef mutable struct Sharpe{T1 <: Real} <: ObjectiveFunction\n    rf::T1 = 0.0\nend\n\nMaximum risk-adjusted return (Sharpe) ratio objective function.\n\nParameters\n\nrf: risk free rate.\nohf::T2 = 1.0 where T2 <: Real: The optimal homogenisation factor.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Utility","page":"Objective functions","title":"PortfolioOptimiser.Utility","text":"@kwdef mutable struct Utility{T1 <: Real} <: ObjectiveFunction\n    l::T1 = 2.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#Private","page":"Objective functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/","page":"Objective functions","title":"Objective functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/ObjectiveFunctionTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationObjectives.jl\"]","category":"page"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.CustomObjective","page":"Objective functions","title":"PortfolioOptimiser.CustomObjective","text":"abstract type CustomObjective end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.NoCustomObjective","page":"Objective functions","title":"PortfolioOptimiser.NoCustomObjective","text":"struct NoCustomObjective <: CustomObjective end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.ObjectiveFunction","page":"Objective functions","title":"PortfolioOptimiser.ObjectiveFunction","text":"abstract type ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationReturns/#Returns","page":"Returns","title":"Returns","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/#Public","page":"Returns","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"Optimisation/OptimisationReturns/#Private","page":"Returns","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/","page":"Returns","title":"Returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationReturns.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#Covariance,-correlation,-cokurtosis-and-coskewness","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#Public","page":"Covariance, correlation, cokurtosis and coskewness","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorKendall","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorKendall","text":"@kwdef mutable struct CorKendall <: CorRank\n    absolute::Bool = false\nend\n\nKendall type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corkendall(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSpearman","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSpearman","text":"@kwdef mutable struct CorSpearman <: CorRank\n    absolute::Bool = false\nend\n\nSpearman type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corspearman(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovDistance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovDistance","text":"mutable struct CovDistance <: PortfolioOptimiserCovCor\n    distance::Distances.Metric\n    dist_args::Tuple\n    dist_kwargs::NamedTuple\n    mean_w1::Union{<:AbstractWeights, Nothing}\n    mean_w2::Union{<:AbstractWeights, Nothing}\n    mean_w3::Union{<:AbstractWeights, Nothing}\nend\n\nDistance covariance and correlation matrix estimator.\n\nParameters\n\ndistance: distance metric from Distances.jl.\ndist_args: args for the Distances.pairwise function of Distances.jl.\ndist_kwargs: kwargs for the Distances.pairwise function of Distances.jl.\nmean_w1: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its rows (dims = 1).\nmean_w2: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its columns (dims = 2).\nmean_w3: optional T×1 vector of weights for computing the mean of the entirety of the pairwise distance matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovFull","text":"@kwdef mutable struct CovFull <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nFull Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber0","text":"@kwdef mutable struct CovGerber0{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber1","text":"@kwdef mutable struct CovGerber1{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber2","text":"@kwdef mutable struct CovGerber2{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 2 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 2 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB0","text":"@kwdef mutable struct CovGerberSB0{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification with vote counting of the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB1","text":"@kwdef mutable struct CovGerberSB1{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification with vote counting of the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB2","text":"mutable struct CovGerberSB2{T1, T2, T3, T4, T5} <: CovSB\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovLTD","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovLTD","text":"mutable struct CovLTD <: PortfolioOptimiserCovCor\n    alpha::Real\n    ve::StatsBase.CovarianceEstimator\n    w::Union{<:AbstractWeights, Nothing}\nend\n\nLower tail dependence correlation and covariance matrix estimator.\n\nParameters\n\nalpha: significance level of the lower tail dependence, alpha ∈ (0, 1).\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovMutualInfo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovMutualInfo","text":"@kwdef mutable struct CovMutualInfo <: PortfolioOptimiserCovCor\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nMutual information correlation matrix estimator.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB0","text":"@kwdef mutable struct CovSB0{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification of the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB1","text":"@kwdef mutable struct CovSB1{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification of the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB2","text":"CovSB2{T1, T2, T3, T4, T5} <: CovSB\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSemi","text":"@kwdef mutable struct CovSemi <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSemi Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtFull","text":"@kwdef mutable struct KurtFull <: KurtEstimator\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nFull cokurtosis estimator.\n\nParameters\n\nposdef: type for fixing non a positive definite cokurtosis matrix AbstractPosdefFix.\ndenoise: type for denoising the cokurtosis matrix AbstractDenoise.\nlogo: type for computing the LoGo cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtSemi","text":"@kwdef mutable struct KurtSemi <: KurtEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nposdef: type for fixing non a positive definite semi cokurtosis matrix AbstractPosdefFix.\ndenoise: type for denoising the semi cokurtosis matrix AbstractDenoise.\nlogo: type for computing the LoGo semi cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortCovCor","text":"@kwdef mutable struct PortCovCor <: PortfolioOptimiserCovCor\n    ce::CovarianceEstimator = CovFull(;)\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nPortfolioOptimiser covariance and correlation estimator.\n\nParameters\n\nce: covariance estimator.\nposdef: type for fixing the portfolio covariance or correlation matrix AbstractPosdefFix.\ndenoise: type for denoising the portfolio covariance or correlation matrix AbstractDenoise.\nlogo: type for computing the LoGo portfolio covariance or correlation matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SimpleVariance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SimpleVariance","text":"@kwdef mutable struct SimpleVariance <: StatsBase.CovarianceEstimator\n    corrected::Bool = true\nend\n\nSimple variance estimator.\n\nParameters\n\ncorrected:\nif true: correct the bias dividing by N-1 instead of N.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewFull","text":"struct SkewFull <: SkewEstimator end\n\nFull cokurtosis estimator.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewSemi","text":"@kwdef mutable struct SkewSemi <: SkewEstimator\n    target::Union{<:Real, AbstractVector{<:Real}} = 0.0\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewFull, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(::SkewFull, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewSemi, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(se::SkewSemi, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#Private","page":"Covariance, correlation, cokurtosis and coskewness","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/CovCorKurtSkewTypes.jl\",\n\"ParameterEstimation/Functions/CovCorKurtSkewFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PosdefFixCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PosdefFixCovCor","text":"const PosdefFixCovCor = Union{<:CovGerber, PortCovCor}\n\nCovariance and correlation estimators that support positive definite fixes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.AbstractCustomMtxProcess","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.AbstractCustomMtxProcess","text":"    abstract type AbstractCustomMtxProcess end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorPearson","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorPearson","text":"abstract type CorPearson <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Pearson type covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorRank","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorRank","text":"abstract type CorRank <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping rank based covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber","text":"abstract type CovGerber <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberBasic","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberBasic","text":"abstract type CovGerberBasic <: CovGerber end\n\nAbstract type for subtyping the original Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB","text":"abstract type CovSB <: CovGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications with vote counting of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB","text":"abstract type CovSB <: CovGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtEstimator","text":"abstract type KurtEstimator end\n\nAbstract type for subtyping cokurtosis estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortfolioOptimiserCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortfolioOptimiserCovCor","text":"abstract type PortfolioOptimiserCovCor <: StatsBase.CovarianceEstimator end\n\nAbstract type for subtyping portfolio covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewEstimator","text":"abstract type SkewEstimator end\n\nAbstract type for subtyping coskew estimators.\n\n\n\n\n\n","category":"type"},{"location":"PlotsExtension/#Plots-extension","page":"Plots Extension","title":"Plots extension","text":"","category":"section"},{"location":"PlotsExtension/#Public","page":"Plots Extension","title":"Public","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = true\nPrivate = false\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#Private","page":"Plots Extension","title":"Private","text":"","category":"section"},{"location":"PlotsExtension/","page":"Plots Extension","title":"Plots Extension","text":"Modules = [Base.get_extension(PortfolioOptimiser, :PortfolioOptimiserPlotsExt)]\nPublic = false\nPrivate = true\nPages = [\"./PortfolioOptimiserPlotsExt.jl\"]","category":"page"},{"location":"PlotsExtension/#PortfolioOptimiser.plot_returns-NTuple{4, Any}","page":"Plots Extension","title":"PortfolioOptimiser.plot_returns","text":"plot_returns(timestamps, assets, returns, weights; per_asset = false, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"M. M. López de Prado. Machine Learning for Asset Managers. Elements in Quantitative Finance (Cambridge University Press, 2020).\n\n\n\nM. L. De Prado. Building diversified portfolios that outperform out of sample. The Journal of Portfolio Management 42, 59–69 (2016).\n\n\n\nA. Hacine-Gharbi, P. Ravier, R. Harba and T. Mohamadi. Low bias histogram-based estimation of mutual information for feature selection. Pattern Recognition Letters 33, 1302–1308 (2012).\n\n\n\nW.-M. Song, T. Di Matteo and T. Aste. Hierarchical information clustering by means of topologically embedded graphs. PloS one 7, e31929 (2012).\n\n\n\nW.-M. Song, T. D. Matteo and T. Aste. Nested hierarchies in planar graphs. Discrete Applied Mathematics 159, 2135–2146 (2011).\n\n\n\nW. Barfuss, G. P. Massara, T. Di Matteo and T. Aste. Parsimonious modeling with information filtering networks. Phys. Rev. E 94, 062306 (2016).\n\n\n\nG. P. Massara, T. Di Matteo and T. Aste. Network Filtering for Big Data: Triangulated Maximally Filtered Graph. Journal of Complex Networks 5, 161–178 (2016), arXiv:https://academic.oup.com/comnet/article-pdf/5/2/161/13794756/cnw015.pdf.\n\n\n\nT. Bodnar, O. Okhrin and N. Parolya. Optimal shrinkage estimator for high-dimensional mean vector. Journal of Multivariate Analysis 170, 63–79 (2019). Special Issue on Functional Data Analysis and Related Topics.\n\n\n\nP. Jorion. Bayes-Stein Estimation for Portfolio Analysis. The Journal of Financial and Quantitative Analysis 21, 279–292 (1986). Accessed on Mar 1, 2024.\n\n\n\nA. Meucci. Risk and asset allocation. Vol. 1 (Springer, 2005).\n\n\n\nY. Feng and D. P. Palomar. A Signal Processing Perspective on Financial Engineering. Foundations and Trends® in Signal Processing 9, 1–231 (2016).\n\n\n\nD. Cajas. Higher Order Moment Portfolio Optimization with L-Moments. Available at SSRN 4393155 (2023).\n\n\n\n","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Risk-measures","page":"Risk measures","title":"Risk measures","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#Public","page":"Risk measures","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#Private","page":"Risk measures","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/","page":"Risk measures","title":"Risk measures","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationRiskMeasure.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationRiskMeasure.jl\"]","category":"page"},{"location":"Optimisation/OptimisationRiskMeasures/#PortfolioOptimiser.set_rm-Tuple{Any, Variance, Union{NOC, RB, Trad}}","page":"Risk measures","title":"PortfolioOptimiser.set_rm","text":"set_rm(port, rm::RiskMeasure, type::Union{Trad, RB, NOC}; kwargs...)\nset_rm(port, rm::AbstractVector{<:RiskMeasure}, type::Union{Trad, RB, NOC}; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/PosdefFix/#Fixing-non-positive-definite-matrices","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#Public","page":"Fixing non-positive definite matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.NoPosdef","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.NoPosdef","text":"struct NoPosdef <: AbstractPosdefFix end\n\nNon positive definite matrices will not be fixed in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefNearest","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefNearest","text":"@kwdef mutable struct PosdefNearest <: AbstractPosdefFix\n    type::NearestCorrelationMatrix.NCMAlgorithm = NearestCorrelationMatrix.Newton(;\n                                                                                    tau = 1e-12)\nend\n\nDefines which type from NearestCorrelationMatrix to use in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.posdef_fix!-Tuple{PosdefNearest, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.posdef_fix!","text":"posdef_fix!(type::PosdefNearest, X::AbstractMatrix)\n\nOverload this for other posdef fix types.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/PosdefFix/#Private","page":"Fixing non-positive definite matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/PosdefFixTypes.jl\",\n\"ParameterEstimation/Functions/PosdefFixFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.AbstractPosdefFix","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.AbstractPosdefFix","text":"abstract type AbstractPosdefFix end\n\nAbstract type for subtyping types for fixing non positive definite matrices in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#Asset-allocation","page":"Asset allocation","title":"Asset allocation","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#Public","page":"Asset allocation","title":"Public","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.LP","page":"Asset allocation","title":"PortfolioOptimiser.LP","text":"struct LP <: AllocationType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.allocate!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Asset allocation","title":"PortfolioOptimiser.allocate!","text":"allocate!(port::AbstractPortfolio;\n                   type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                   type::AllocationType = LP(), latest_prices = port.latest_prices,\n                   investment::Real = 1e6, \n                   string_names::Bool = false)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Private","page":"Asset allocation","title":"Private","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/","page":"Asset allocation","title":"Asset allocation","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/AssetAllocTypes.jl\",\n\"Optimisation/Functions/AssetAllocation.jl\",\n\"Optimisation/Functions/AssetAllocationSetup.jl\",\n\"Optimisation/Functions/AssetAllocationLP.jl\",\n\"Optimisation/Functions/AssetAllocationGreedy.jl\"]","category":"page"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.roundmult-Tuple{Any, Any, Vararg{Any}}","page":"Asset allocation","title":"PortfolioOptimiser.roundmult","text":"roundmult(val, prec [, args...] [; kwargs...])\n\nRound a number to a multiple of prec. Uses the same defaults and has the same args and kwargs of the built-in Base.round.\n\nEquivalent to:\n\nround(div(val, prec) * prec, args...; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Miscelaneous-Functions","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Public","page":"Miscelaneous Functions","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Private","page":"Miscelaneous Functions","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"RiskMeasures/Functions/MiscRiskMeasureFunctions.jl\"]","category":"page"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_first_rm-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_first_rm","text":"get_first_rm(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet the first risk measure, used in efficient_frontier!.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_rm_symbol-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_rm_symbol","text":"get_rm_symbol(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet a symbol for the risk measure(s). If multiple measures are given, they are concatenated by underscores.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractDict, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.set_rm_properties!","text":"set_rm_properties!(rm::AbstractRiskMeasure, solvers::AbstractDict,\n                   sigma::Union{Nothing, <:AbstractMatrix{<:Real}})\n\nSet properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_solvers!-Tuple{Union{EDaR, EDaR_r, EVaR, RLDaR, RLDaR_r, RLVaR}, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.set_rm_solvers!","text":"set_rm_solvers!(rm::RMSolvers, solvers)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_rm_solvers!-Tuple{Union{EDaR, EDaR_r, EVaR, RLDaR, RLDaR_r, RLVaR}, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.unset_rm_solvers!","text":"unset_rm_solvers!(rm::RMSolvers, flag)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, Vararg{Bool, 4}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.unset_set_rm_properties!","text":"unset_set_rm_properties!(rm::AbstractRiskMeasure, solver_flag::Bool, sigma_flag::Bool)\n\nUnset properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Matrix-denoising","page":"Matrix denoising","title":"Matrix denoising","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#Public","page":"Matrix denoising","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseFixed","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseFixed","text":"@kwdef mutable struct DenoiseFixed{T1, T2, T3, T4} <: AbstractDenoise\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the fixed type in denoise! [1, Chapter 2]. This type performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to their average, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: remove the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to remove from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseShrink","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseShrink","text":"@kwdef mutable struct DenoiseShrink{T1, T2, T3, T4, T5} <: AbstractDenoise\n    alpha::Real = 0.0\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the shrink type in denoise! [1, Chapter 2]. This type shrinks the covariance to a target of unequal variance of the matrix reconstructed with the eigenvalues that are below the noise significance value. The degree of shrinkage is parametrised by alpha.\n\nbeginalign\nmathbfC = mathbfC_u + alpha mathbfC_l + (1 - alpha) mathrmDiag(mathbfC)\nmathbfC_u = mathbfE_u mathbflambda_u mathbfE_u^intercal\nmathbfC_l = mathbfE_l mathbflambda_l mathbfE_l^intercal\nendalign\n\nWhere:\n\nmathbfC is the denoised correlation matrix.\nmathbfC_u is the reconstructed correlation matrix out of the eigenvalues that are above the noise significance threshold, and their corresponding eigenvectors.\nmathbfC_l is the reconstructed correlation matrix out of the eigenvalues that are below the noise significance threshold, and their corresponding eigenvectors.\nmathbfE_u are the eigenvectors corresponding to the eigenvalues that are above the noise significance threshold.\nmathbflambda_u is the diagonal matrix of eigenvalues that are above the noise significance threshold.\nmathbfE_l are the eigenvectors corresponding to the eigenvalues that are below the noise significance threshold.\nmathbflambda_l is the diagonal matrix of eigenvalues that are below the noise significance threshold.\n\nParameters\n\nalpha: tuning parameter for how much the matrix should be shrunk, alpha ∈ [0, 1].\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseSpectral","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseSpectral","text":"@kwdef mutable struct DenoiseSpectral{T1, T2, T3, T4} <: AbstractDenoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the spectral type in denoise! [1, Chapter 2]. This type performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to zero, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.NoDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.NoDenoise","text":"struct NoDenoise <: AbstractDenoise end\n\nApply no denoising in denoise!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.denoise!-Tuple{PortfolioOptimiser.AbstractDenoise, PortfolioOptimiser.AbstractPosdefFix, AbstractMatrix, Real}","page":"Matrix denoising","title":"PortfolioOptimiser.denoise!","text":"denoise!(ce::AbstractDenoise, posdef::AbstractPosdefFix, X::AbstractMatrix, q::Real)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Private","page":"Matrix denoising","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/","page":"Matrix denoising","title":"Matrix denoising","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MatrixDenoisingTypes.jl\",\n\"ParameterEstimation/Functions/MatrixDenoisingFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.AbstractDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.AbstractDenoise","text":"abstract type AbstractDenoise end\n\nAbstract type for subtyping denoising types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#Ordered-Weight-Arrays","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#Public","page":"Ordered Weight Arrays","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.CRRA","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.CRRA","text":"@kwdef mutable struct CRRA{T1 <: Real} <: OWATypes\n    g::T1 = 0.5\nend\n\nNormalised Constant Relative Risk Aversion Coefficients.\n\nParameters\n\ng: Risk aversion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MaxEntropy","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MaxEntropy","text":"@kwdef mutable struct MaxEntropy{T1 <: Real, T2 <: AbstractDict} <: OWATypes\n    max_phi::T1 = 0.5\n    solvers::T2 = Dict()\nend\n\nMaximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSqDist","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSqDist","text":"@kwdef mutable struct MinSqDist{T1 <: Real} <: OWAJTypes\n    max_phi::T1 = 0.5\nend\n\nMinimum Square Distance. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSumSq","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSumSq","text":"@kwdef mutable struct MinSumSq{T1 <: Real} <: OWAJTypes\n    max_phi::T1 = 0.5\nend\n\nMinimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_cvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_cvar","text":"owa_cvar(T::Integer; alpha::Real = 0.05)\n\nCalculate the OWA weights corresponding to the Critical Value at Risk (CVaR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_gmd-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_gmd","text":"owa_gmd(T::Integer)\n\nComputes the Gini Mean Difference (GMD) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n[OWA]: Cajas, Dany, OWA Portfolio Optimization: A Disciplined Convex Programming Framework (December 18, 2021). Available at SSRN: https://ssrn.com/abstract=3988927 or http://dx.doi.org/10.2139/ssrn.3988927\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment","text":"owa_l_moment(T::Integer; k::Integer = 2)\n\nCalculates the OWA weights of the k'th linear moment (L-moment) of a returns series [12].\n\nInputs\n\nk: order of the L-moment.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment_crm-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment_crm","text":"owa_l_moment_crm(T::Integer; k::Integer = 2, type::Symbol = :SD, g::Real = 0.5,\n                 max_phi::Real = 0.5, solvers = Dict())\n\nCompute the OWA weights for the convex risk measure considering higher order L-moments [12].\n\nInputs\n\nk: order of the L-moment, k ≥ 2.\ntype: type for computing the weights used to combine L-moments higher than 2, used in OWATypes.\n:CRRA: Normalised Constant Relative Risk Aversion Coefficients.\n:E: Maximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n:SS: Minimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n:SD: Minimum Square Distance. Solver must support MOI.SecondOrderCone.\ng: the risk aversion coefficient.\nmax_phi: maximum weight constraint of the L-moments.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rcvar-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rcvar","text":"owa_rcvar(T::Integer; alpha::Real = 0.05, beta::Real = alpha)\n\nCompute the OWA weights for the CVaR Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rg","text":"owa_rg(T::Integer)\n\nCompute the OWA weights for the Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rtg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rtg","text":"owa_rtg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100,\n        beta_i::Real = alpha_i, beta::Real = alpha, b_sim::Integer = a_sim)\n\nCompute the OWA weights for the Tail Gini Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rwcvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rwcvar","text":"owa_rwcvar(T::Integer, alphas::AbstractVector{<:Real}, weights_a::AbstractVector{<:Real};\n           betas::AbstractVector{<:Real} = alphas,\n           weights_b::AbstractVector{<:Real} = weights_b)\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of the losses for each CVaR model, where N is the number of losses models, each .\nweights_a: N×1 vector of weights of the losses for each CVaR model, where N is the number of losses models.\nbetas: M×1 vector of significance levels of the gains for each CVaR model, where M is the number of gains models, each .\nweights_b: M×1 vector of weights of the gains for each CVaR model, where M is the number of gains models.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_tg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_tg","text":"owa_tg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100)\n\nCompute the OWA weights for the Tail Gini of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wcvar-Tuple{Integer, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wcvar","text":"owa_wcvar(T::Integer, alphas::AbstractVector{<:Real}, weights::AbstractVector{<:Real})\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of each CVaR model, where N is the number of models, each .\nweights: N×1 vector of weights of each CVaR model, where N is the number of models.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wr-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wr","text":"owa_wr(T::Integer)\n\nCompute the OWA weights for the Worst Realisation (WR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#Private","page":"Ordered Weight Arrays","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/OWA/","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/OWATypes.jl\",\n\"ParameterEstimation/Functions/OWAFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.OWATypes","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.OWATypes","text":"abstract type OWATypes end\n\nAbstract type for subtyping Ordered Weight Array (OWA) types for computing the weights used to combine L-moments higher than 2 [12] in owa_l_moment_crm.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.crra_weights-Tuple{AbstractMatrix{<:Real}, Integer, Real}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.crra_weights","text":"crra_weights(weights::AbstractMatrix{<:Real}, k::Integer, g::Real)\n\nInternal function for computing the Normalized Constant Relative Risk Aversion coefficients.\n\nInputs\n\nweights: T×(k-1) matrix where T is the number of observations and k the order of the L-moments to combine, the i'th column contains the weights for the (i+1)'th L-moment.\nk: the maximum order of the L-moments.\ng: the risk aversion coefficient.\n\nOutputs\n\nw: T×1 ordered weight vector of the combined L-moments.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.optimise_JuMP_model-Tuple{Any, Any}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.optimise_JuMP_model","text":"optimise_JuMP_model(model, solvers)\n\nInternal function to optimise an OWA JuMP model.\n\nInputs\n\nmodel: JuMP model.\n\nOutputs\n\nterm_status: JuMP termination status.\nsolvers_tried: Dictionary that contains a dictionary of failed optimisations. Dict(key => Dict(...)), where key is the solver key used for the iteration of solver that failed.\nIf an MOI call fails on a model:\nDict(:jump_error => jump_error): JuMP error code.\nIf the optimiser fails to optimise the model satisfactorily:\nDict(:objective_val => JuMP.objective_value(model), :term_status => term_status, :params => haskey(val, :params) ? val[:params] : missing), where val is the value of the dictionary corresponding to key.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Network","page":"Network","title":"Network","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/#Public","page":"Network","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.centrality_vector-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.centrality_vector","text":"centrality_vector(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistType = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the centrality vector centrality_vector. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nC: N×1 centrality vector.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.cluster_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.cluster_matrix","text":"cluster_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistType = DistCanonical(),\n               clust_alg::ClustAlg = HAC(), clust_opt::ClustOpt = ClustOpt())\n\nCompute the centrality vector cluster_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nclust_alg: type for hierarhically clustering assets ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nC: N×N cluster-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connected_assets","page":"Network","title":"PortfolioOptimiser.connected_assets","text":"connected_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                 cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                 dist_type::DistType = DistCanonical(),\n                 network_type::NetworkType = MST())\n\nCompute the percentage of the portfolio comprised of connected assets connected_assets via a connection-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nc: percentage of the portfolio comprised of assets connected via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connection_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connection_matrix","text":"connection_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistType = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the connection matrix connection_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nC: N×N connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.related_assets","page":"Network","title":"PortfolioOptimiser.related_assets","text":"related_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistType = DistCanonical(),\n               clust_alg::ClustAlg = HAC(), clust_opt::ClustOpt = ClustOpt())\n\nCompute the percentage of the portfolio comprised of related assets  related_assets via a cluster-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nclust_alg: type for hierarhically clustering assets ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nc: percentage of the portfolio comprised of related assets via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioNetwork/#Private","page":"Network","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/","page":"Network","title":"Network","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Portfolio/Functions/PortfolioNetwork.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#Regression","page":"Regression","title":"Regression","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#Public","page":"Regression","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AIC","page":"Regression","title":"PortfolioOptimiser.AIC","text":"struct AIC <: MinValStepwiseRegressionCriteria end\n\nAkaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AICC","page":"Regression","title":"PortfolioOptimiser.AICC","text":"struct AICC <: MinValStepwiseRegressionCriteria end\n\nCorrected Akaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AdjRSq","page":"Regression","title":"PortfolioOptimiser.AdjRSq","text":"struct AdjRSq <: MaxValStepwiseRegressionCriteria end\n\nAdjusted R² for a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BIC","page":"Regression","title":"PortfolioOptimiser.BIC","text":"struct BIC <: MinValStepwiseRegressionCriteria end\n\nBayesian Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BReg","page":"Regression","title":"PortfolioOptimiser.BReg","text":"@kwdef mutable struct BReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nBackward stepwise regression. Starts by assuming all features are significant and uses criterion to remove the worst performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FReg","page":"Regression","title":"PortfolioOptimiser.FReg","text":"@kwdef mutable struct FReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nForward stepwise regression. Starts by assuming no factor is significant and uses criterion to add the best performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FactorType","page":"Regression","title":"PortfolioOptimiser.FactorType","text":"@kwdef mutable struct FactorType\n    error::Bool = true\n    B::Union{Nothing, DataFrame} = nothing\n    type::RegressionType = FReg(;)\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    var_w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCAReg","page":"Regression","title":"PortfolioOptimiser.PCAReg","text":"@kwdef mutable struct PCAReg <: DimensionReductionRegression\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    target::DimensionReductionTarget = PCATarget(;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCATarget","page":"Regression","title":"PortfolioOptimiser.PCATarget","text":"@kwdef mutable struct PCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PPCATarget","page":"Regression","title":"PortfolioOptimiser.PPCATarget","text":"@kwdef mutable struct PPCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PVal","page":"Regression","title":"PortfolioOptimiser.PVal","text":"@kwdef mutable struct PVal{T1 <: Real} <: StepwiseRegressionCriteria\n    threshold::T1 = 0.05\nend\n\nP-value as feature selection criterion.\n\nParameters\n\nthreshold: threshold for classifying significant p-values. Only features whose p-values are lower than threshold are considered significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RSq","page":"Regression","title":"PortfolioOptimiser.RSq","text":"struct RSq <: MaxValStepwiseRegressionCriteria end\n\nR² of a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.loadings_matrix","page":"Regression","title":"PortfolioOptimiser.loadings_matrix","text":"loadings_matrix(x::DataFrame, y::DataFrame, type::RegressionType = FReg())\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.regression-Tuple{PCAReg, DataFrames.DataFrame, DataFrames.DataFrame}","page":"Regression","title":"PortfolioOptimiser.regression","text":"regression(type::PCAReg, x::DataFrame, y::DataFrame)\n\nDescription\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Private","page":"Regression","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Regression/","page":"Regression","title":"Regression","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/RegressionTypes.jl\",\n\"ParameterEstimation/Functions/RegressionFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionRegression","page":"Regression","title":"PortfolioOptimiser.DimensionReductionRegression","text":"abstract type DimensionReductionRegression <: RegressionType end\n\nAbstract type for subtyping dimensionality reduction regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionTarget","page":"Regression","title":"PortfolioOptimiser.DimensionReductionTarget","text":"abstract type DimensionReductionTarget end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MaxValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MaxValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where larger values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MinValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MinValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where smaller values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RegressionType","page":"Regression","title":"PortfolioOptimiser.RegressionType","text":"abstract type RegressionType end\n\nAbstract type for subtyping regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegression","page":"Regression","title":"PortfolioOptimiser.StepwiseRegression","text":"abstract type StepwiseRegression <: RegressionType end\n\nAbstract type for subtyping stepwise regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.StepwiseRegressionCriteria","text":"abstract type StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria for selecting significant features when using StepwiseRegression types.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationGetZ/#Entropic-and-relativistic-moments","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/#Public","page":"Entropic and relativistic moments","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationUtils.jl\"]","category":"page"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z-Tuple{Portfolio, Union{RiskMeasure, AbstractVector}}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z","text":"get_z(port::Portfolio, rm::Union{AbstractVector, <:RiskMeasure})\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z_from_model-Tuple{JuMP.Model, EVaR}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z_from_model","text":"get_z_from_model(model::JuMP.Model, ::Union{EVaR, EDaR, RLVaR, RLDaR})\nget_z_from_model(model::JuMP.Model, ::Union{AbstractVector{<:EVaR}, EDaRAbstractVecto{<: ,} AbstractVector{<:RLVaR}, AbstractVector{<:RLDaR}})\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Private","page":"Entropic and relativistic moments","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationUtils.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#Expected-returns","page":"Expected returns","title":"Expected returns","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#Public","page":"Expected returns","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.GM","page":"Expected returns","title":"PortfolioOptimiser.GM","text":"struct GM <: MeanTarget end\n\nGrand mean target.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MSE","page":"Expected returns","title":"PortfolioOptimiser.MSE","text":"struct MSE <: MeanTarget end\n\nMean square error of sample mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBOP","page":"Expected returns","title":"PortfolioOptimiser.MuBOP","text":"@kwdef mutable struct MuBOP <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBodnar-Okhrin-Parolya [8] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBS","page":"Expected returns","title":"PortfolioOptimiser.MuBS","text":"@kwdef mutable struct MuBS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBayes-Stein [9] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuJS","page":"Expected returns","title":"PortfolioOptimiser.MuJS","text":"@kwdef mutable struct MuJS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nJames-Stein [10, 11] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuSimple","page":"Expected returns","title":"PortfolioOptimiser.MuSimple","text":"@kwdef mutable struct MuSimple <: MeanEstimator\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSimple expected returns vector estimator.\n\nParameters\n\nw: optional T×1 vector of weights for computing the expected returns vector.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.VW","page":"Expected returns","title":"PortfolioOptimiser.VW","text":"struct VW <: MeanTarget end\n\nVolatility-weighted grand mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.target_mean-Tuple{GM, AbstractVector, AbstractMatrix, Any, Integer, Integer}","page":"Expected returns","title":"PortfolioOptimiser.target_mean","text":"target_mean(::GM, mu::AbstractVector, sigma::AbstractMatrix, inv_sigma, T::Integer,\n                     N::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MeanEstimators/#Private","page":"Expected returns","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/","page":"Expected returns","title":"Expected returns","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/MeanEstimatorTypes.jl\",\n\"ParameterEstimation/Functions/MeanEstimatorFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanEstimator","text":"abstract type MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanSigmaEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanSigmaEstimator","text":"abstract type MeanSigmaEstimator <: MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanTarget","page":"Expected returns","title":"PortfolioOptimiser.MeanTarget","text":"abstract type MeanTarget end\n\nAbstract type for subtyping correction targets of expected returns estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuEquil","page":"Expected returns","title":"PortfolioOptimiser.MuEquil","text":"mutable struct MuEquil{T1} <: MeanSigmaEstimator\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Worst-case-mean-variance-sets","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#Public","page":"Worst case mean variance sets","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.ArchWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.ArchWC","text":"@kwdef mutable struct ArchWC{T1 <: Integer, T2 <: Integer, T3 <: Real} <: WorstCaseType\n    bootstrap::WorstCaseArchType = StationaryBS()\n    n_sim::T1 = 3_000\n    block_size::T2 = 3\n    q::T3 = 0.05\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.CircularBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.CircularBS","text":"struct CircularBS <: WorstCaseArchType end\n\nCircular block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.DeltaWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.DeltaWC","text":"@kwdef mutable struct DeltaWC{T1 <: Real, T2 <: Real} <: WorstCaseType\n    dcov::T1 = 0.1\n    dmu::T2 = 0.1\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KGeneralWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KGeneralWC","text":"struct KGeneralWC <: WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KNormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KNormalWC","text":"struct KNormalWC <: WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.MovingBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.MovingBS","text":"struct MovingBS <: WorstCaseArchType end\n\nMoving block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NormalWC","text":"@kwdef mutable struct NormalWC{T1 <: Integer, T2 <: Real} <: WorstCaseType\n    n_sim::T1 = 3_000\n    q::T2 = 0.05\n    rng::AbstractRNG = Random.default_rng()\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.StationaryBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.StationaryBS","text":"struct StationaryBS <: WorstCaseArchType end\n\nStationary bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCType","text":"@kwdef mutable struct WCType\n    cov_type::PortfolioOptimiserCovCor = PortCovCor(;)\n    mu_type::MeanEstimator = MuSimple(;)\n    box::WorstCaseType = NormalWC(;)\n    ellipse::WorstCaseType = NormalWC(;)\n    k_sigma::Union{<:Real, WorstCaseKType} = KNormalWC(;)\n    k_mu::Union{<:Real, WorstCaseKType} = KNormalWC(;)\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    diagonal::Bool = false\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Private","page":"Worst case mean variance sets","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/WorstCaseTypes.jl\",\n\"ParameterEstimation/Functions/WorstCaseFunctions.jl\"]","category":"page"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseArchType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseArchType","text":"abstract type WorstCaseArchType <: WorstCaseType end\n\nAbstract type for subtyping types for computing worst case mean variance for bootstrapping with arch.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseKType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseKType","text":"abstract type WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseType","text":"abstract type WorstCaseType end\n\nAbstract type for subtyping types for computing worst case mean variance sets.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#Optimisation-kinds","page":"Optimisation kinds","title":"Optimisation kinds","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#Public","page":"Optimisation kinds","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRB.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRB.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisation.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationHRP.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationHERC.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationNCO.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationOptimise.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.BasicRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.BasicRRB","text":"struct BasicRRB <: RRBVersion end\n\nBasic relaxed risk budget optimisation version.\n\nSee also: RRBVersion, RRB.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HERC","page":"Optimisation kinds","title":"PortfolioOptimiser.HERC","text":"struct HERC <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HRP","page":"Optimisation kinds","title":"PortfolioOptimiser.HRP","text":"struct HRP <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NCO","page":"Optimisation kinds","title":"PortfolioOptimiser.NCO","text":"mutable struct NCO <: HCOptimType\n    internal::NCOArgs\n    external::NCOArgs\n    finaliser::HCOptWeightFinaliser\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NOC","page":"Optimisation kinds","title":"PortfolioOptimiser.NOC","text":"mutable struct NOC{T1, T2, T3, T4, T5, T6, T7, T8} <: OptimType\n\nNear optimal centering optimisation type. This type of optimisation defines a near-optimal convex region around a point in the efficient frontier, and finds the portfolio which best fits the analytic centre of the region.\n\nSee also: OptimType, RiskMeasure, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nflag::Bool = true:\nbins::T1 = 20.0 where T1 <: Real:\nw_opt::T2 = Vector{Float64}(undef, 0) where T2 <: AbstractVector{<:Real}: Vector of weights of the efficient frontier portfolio.\nw_min::T3 = Vector{Float64}(undef, 0) where T3 <: AbstractVector{<:Real}: Vector of weights of the minimal risk portfolio.\nw_max::T4 = Vector{Float64}(undef, 0) where T4 <: AbstractVector{<:Real}: Vector of weights of the maxumal return portfolio.\nw_opt_ini::T6 = Vector{Float64}(undef, 0) where T6 <: AbstractVector{<:Real}: The initial weights of the efficient frontier portfolio optimisation.\nIrrelevant if the solver does not support them.\nw_min_ini::T6 = Vector{Float64}(undef, 0) where T6 <: AbstractVector{<:Real}: The initial weights of the minimum risk optimisation.\nIrrelevant if the solver does not support them.\nw_max_ini::T7 = Vector{Float64}(undef, 0) where T7 <: AbstractVector{<:Real}: The initial weights of the maximum return optimisation.\nIrrelevant if the solver does not support them.\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nobj::ObjectiveFunction = MinRisk():\nkelly::RetType = NoKelly():\nclass::PortClass = Classic():\nw_ini::T8 = Vector{Float64}(undef, 0) where T8 <: AbstractVector{<:Real}: The initial weights for the optimisation of the near optimal centering portfolio.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RB","page":"Optimisation kinds","title":"PortfolioOptimiser.RB","text":"mutable struct RB{T1} <: OptimType\n\nRisk budget optimisation type. Allows the user to specify a risk budget vector specifying the maximum risk contribution per asset or factor. The asset weights are then optimised to meet the risk budget per asset/factor as optimally as possible.\n\nSee also: OptimType, RiskMeasure, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\nExamples\n\n# Default constructor.\nopt_type = RB()\n\n# Single risk measure.\nopt_type = RB(; rm = SD())\n\n# Multiple risk measures.\nopt_type = RB(; rm = [Variance(), CVaR(; alpha = 0.15)])\n\n# Incorrect use of multiple risk measures of the same type.\n# This will produce a JuMP registration error when optimise! is called.\nopt_type = RB(; rm = [CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures of the same type.\nopt_type = RB(; rm = [[CVaR(), CVaR(; alpha = 0.2)]])\n\n# Incorrect use of multiple risk measures, some of the same type.\n# This will produce a JuMP registration error regarding the CVaR\n# risk measure when optimise! is called.\nopt_type = RB(; rm = [MAD(), CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures, some of the same type.\nopt_type = RB(; rm = [MAD(), [CVaR(), CVaR(; alpha = 0.2)]])\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RRB","text":"mutable struct RRB{T1} <: OptimType\n\nThe relaxed risk budget optimisation only applies to the variance risk measure.\n\nSee also: OptimType, RRBVersion, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nversion::RRBVersion = BasicRRB(): Relaxed risk budget optimisation version.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegPenRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RegPenRRB","text":"mutable struct RegPenRRB{T1} <: RRBVersion\n\nRelaxed risk budget optimisation version with regularisation and penalty.\n\nSee also: RRBVersion, RRB.\n\nKeyword Parameters\n\npenalty::Real = 1.0: The penalty to be used.\n\nExamples\n\n# Default constructor.\nrrb_ver = RegPenRRB()\n\n# Custom penalty.\nrrb_ver = RegPenRRB(; penalty = 0.5)\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RegRRB","text":"struct RegRRB <: RRBVersion end\n\nRelaxed risk budget optimisation version with regularisation.\n\nSee also: RRBVersion, RRB.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarLogSumExp","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarLogSumExp","text":"mutable struct ScalarLogSumExp{T1 <: Real} <: AbstractScalarisation end\n\nScalarises the risk measures as the logsumexp of the weighted risk measures.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = frac1gamma log left( sum_i = 1^N exp(gamma r_i w_i) right)\nendalign\n\nWhere:\n\nr is the scalarised risk.\nr_i is the i-th risk measure.\nw_i is the weight of the i-th risk measure.\ngamma is a parameter that controls the shape of the scalarisation.\n\nKeyword Parameters\n\ngamma::Real = 1.0: gamma > 0. As gamma → 0, the scalarisation approaches ScalarSum. As gamma → Inf, the scalarisation approaches ScalarMax.\n\nExamples\n\n# Default constructor.\nscalariser = ScalarLogSumExp()\n\n# Approximate ScalarSum()\nscalariser = ScalarLogSumExp(; gamma = 1e-6)\n\n# Approximate ScalarMax()\nscalariser = ScalarLogSumExp(; gamma = 1e6)\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarMax","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarMax","text":"struct ScalarMax <: AbstractScalarisation end\n\nScalarises the risk measures by taking the maximum of them.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = max left( bmr odot bmw right)\nendalign\n\nWhere:\n\nr is the scalarised risk.\nbmr is the vector of risk measures.\nbmw is the corresponding vector of risk measure weights.\nodot is the Hadamard (element-wise) multiplication.\n\nExamples\n\nscalariser = ScalarMax()\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarSum","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarSum","text":"struct ScalarSum <: AbstractScalarisation end\n\nScalarises the risk measures as a weighted sum.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = bmr cdot bmw\nendalign\n\nWhere:\n\nr is the scalarised risk.\nbmr is the vector of risk measures.\nbmw is the corresponding vector of risk measure weights\ncdot is the dot product.\n\nExamples\n\nscalariser = ScalarSum()\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.SchurHRP","page":"Optimisation kinds","title":"PortfolioOptimiser.SchurHRP","text":"mutable struct SchurHRP <: HCOptimType\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.Trad","page":"Optimisation kinds","title":"PortfolioOptimiser.Trad","text":"mutable struct Trad{T1} <: OptimType\n\nTraditional optimisation type.\n\nSee also: OptimType, RiskMeasure, ObjectiveFunction, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nobj::ObjectiveFunction = MinRisk(): The objective function to be used.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\nExamples\n\n# Default constructor.\nopt_type = Trad()\n\n# Single risk measure.\nopt_type = Trad(; rm = SD())\n\n# Multiple risk measures.\nopt_type = Trad(; rm = [Variance(), CVaR(; alpha = 0.15)])\n\n# Incorrect use of multiple risk measures of the same type.\n# This will produce a JuMP registration error when optimise! is called.\nopt_type = Trad(; rm = [CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures of the same type.\nopt_type = Trad(; rm = [[CVaR(), CVaR(; alpha = 0.2)]])\n\n# Incorrect use of multiple risk measures, some of the same type.\n# This will produce a JuMP registration error regarding the CVaR\n# risk measure when optimise! is called.\nopt_type = Trad(; rm = [MAD(), CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures, some of the same type.\nopt_type = Trad(; rm = [MAD(), [CVaR(), CVaR(; alpha = 0.2)]])\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.efficient_frontier!","page":"Optimisation kinds","title":"PortfolioOptimiser.efficient_frontier!","text":"efficient_frontier!(port::Portfolio, type::Union{Trad, NOC, NCO} = Trad();\n                             w_min_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             w_max_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             points::Integer = 20, rf::Real = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.optimise!-Tuple{Portfolio, Trad}","page":"Optimisation kinds","title":"PortfolioOptimiser.optimise!","text":"optimise!(port::Portfolio, type::OptimType)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#Private","page":"Optimisation kinds","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/","page":"Optimisation kinds","title":"Optimisation kinds","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Types/OptimisationKindTypes.jl\",\n\"Optimisation/Functions/PortfolioOptimisationTrad.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRB.jl\",\n\"Optimisation/Functions/PortfolioOptimisationRRB.jl\",\n\"Optimisation/Functions/PortfolioOptimisationNOC.jl\",\n\"Optimisation/Functions/PortfolioOptimisationOptimise.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisation.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationHRP.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationHERC.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationNCO.jl\",\n\"Optimisation/Functions/PortfolioHCOptimisationOptimise.jl\"]","category":"page"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractOptimType","text":"abstract type AbstractOptimType end\n\nAbstract type for the different types of optimisations.\n\nSee also: OptimType and HCOptimType.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractScalarisation","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractScalarisation","text":"abstract type AbstractScalarisation end\n\nAbstract type for scalarisation functions used when simultaneously optimising for multiple risk measures.\n\nSee also: ScalarSum, ScalarMax, ScalarLogSumExp.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HCOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.HCOptimType","text":"abstract type HCOptimType <: AbstractOptimType end\n\nAbstract type for hierarchical optimisations.\n\nSee also: AbstractOptimType, OptimType, HRP, SchurHRP, HERC, NCO.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.OptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.OptimType","text":"abstract type OptimType <: AbstractOptimType end\n\nAbstract type for optimisations that are not hierarchical.\n\nSee also: AbstractOptimType, HCOptimType, Trad, RB, RRB, NOC.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRBVersion","page":"Optimisation kinds","title":"PortfolioOptimiser.RRBVersion","text":"abstract type RRBVersion end\n\nAbstract type for the different versions of the relaxed risk budget optimisation.\n\nSee also: RRB, BasicRRB, RegRRB, RegPenRRB.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskValue/#Risk-value","page":"Risk value","title":"Risk value","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"Despite the fact that HCRiskMeasure are only compatible with , it is possible to compute the value of every risk measure for a given returns matrix and vector of weights.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"calc_risk\nPortfolioOptimiser.ERM\nPortfolioOptimiser.RRM","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.calc_risk","page":"Risk value","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(::Equal, w::AbstractVector; delta::Real = 0, kwargs...)\n\nDescription\n\nCompute the risk as the inverse of the length of w.\n\nInputs\n\nPositional\n\nequal::Equal: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\ndelta::Real: is a displacement, used in risk_contribution and factor_risk_contribution.\n\nOutputs\n\nequal::Real: Equal Risk.\n\nExamples\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the equal risk measure\nequal_rm = Equal()\nequal_risk = calc_risk(equal_rm, w)\n\n\n\n\n\ncalc_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.ERM","page":"Risk value","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector, z::Real = 1.0, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = z ln left(dfracM_bmXleft(z^-1right)alpha right)\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nalpha in (01) is the significance parameter.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nz::Real = 1.0: entropic moment, can be obtained from get_z_from_model and get_z after optimising a Portfolio.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic risk measure with default parameters\ner1 = ERM(returns, 2.3, 0.03)\n\n# Calculate with a 2.3 entropic moment and 3 % significance parameter\ner2 = ERM(returns, 2.3, 0.03)\n\n\n\n\n\nERM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nDescription\n\nCompute the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = \n    begincases\n        undersetz t uinf  t + z lnleft(dfrac1alpha Tright)\n        mathrmst  z geq sumlimits_i=1^T u_inonumber\n         (-X_i-t z u_i) in mathcalK_exp  forall  i=1dots T\n    endcases\n= undersetz0infleft z ln left(dfracM_bmXleft(z^-1right)alpha right)right\nendalign\n\nWhere:\n\nM_bmXleft(tright) is the moment generating function of bmX.\nmathcalK_mathrmexp is the exponential cone.\nalpha in (01) is the significance parameter.\n\nSee also: EVaR, calc_risk(::EVaR, ::AbstractVector), EVaR, EDaR, calc_risk(::EDaR, ::AbstractVector), EDaR, EDaR_r, calc_risk(::EDaR_r, ::AbstractVector), EDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for exponential cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EVaR, EDaR, or EDaR_r.\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the entropic risk measure with default parameters\ner1 = ERM(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter\ner2 = ERM(returns, Dict(\"solver\" => my_solver), 0.03)\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.RRM","page":"Risk value","title":"PortfolioOptimiser.RRM","text":"RRM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nDescription\n\nCompute the Relativistic Risk Measure. Used in RLVaR, RLDaR and RLDaR_r.\n\nbeginalign\nmathrmRRM(Xalphakappa) = left\n    beginalign\n        undersetz t psi theta  varepsilon omegatextinf  t + z ln_kappa left(dfrac1alpha Tright) + sumlimits_i=1^T left(psi_i + theta_i  right) nonumber\n        mathrmst  -X  - t + varepsilon + omega leq 0 nonumber\n        z geq 0 \n        left( zleft(dfrac1+kappa2kapparight) psi_ileft(dfrac1+kappakapparight) varepsilon_i right) in mathcalP_3^1(1+kappa) kappa(1+kappa)nonumber\n        left( omega_ileft(dfrac11-kapparight) theta_ileft(dfrac1kapparight) -z left(dfrac12kapparight) right) in mathcalP_3^1-kappa kappanonumber\n        forall  i=1dots T nonumber\n    endalign\nright\nendalign\n\nWhere:\n\nmathcalP_3^alpha 1-alpha is the 3D power cone.\nalpha in (01) is the significance parameter.\nkappa in (01) is the relativistic deformation parameter.\n\nSee also: RLVaR, calc_risk(::RLVaR, ::AbstractVector), RLVaR, RLDaR, calc_risk(::RLDaR, ::AbstractVector), RLDaR, RLDaR_r, calc_risk(::RLDaR_r, ::AbstractVector), RLDaR_r.\n\nInputs\n\nx::AbstractVector: T×1 returns vector.\nsolvers::AbstractDict: JuMP-compatible solvers for 3D power cone problems.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: relativistic deformation parameter, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLVaR, RLDaR, or RLDaR_r.\n\nOutputs\n\nrlr::Real: relativistic risk.\n\nExamples\n\n# Sample returns vector\nreturns = [0.05, -0.03, 0.02, -0.01, 0.04]\n\n# Calculate the relativistic risk with default parameters\nrlr1 = RRM(returns, Dict(\"solver\" => my_solver))\n\n# Calculate with a 3 % significance parameter and 80 % deformation parameter\nrlr2 = RRM(returns, Dict(\"solver\" => my_solver), 0.03, 0.8)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClustOpt","page":"Clustering","title":"PortfolioOptimiser.ClustOpt","text":"@kwdef mutable struct ClustOpt{T1 <: Integer, T2 <: Integer}\n    branchorder::Symbol = :optimal\n    k_type::NumClusterType = TwoDiff()\n    k::T1 = 0\n    max_k::T2 = 0\nend\n\nDefines the options for processing clustering results in an instance of Clustering.Hclust.\n\nParameters\n\nbranchorder: parameter for ordering a dendrogram's branches accepted by Clustering.jl.\nk_type: type subtyping NumClusterType for computing the number of clusters.\nk:\nif iszero(k): use k_type for computing the number of clusters.\nelse: directly provide the number of clusters.\nmax_k: maximum number of clusters, capped to ⌈sqrt(N)⌉.\nif 0: defaults to ⌈sqrt(N)⌉.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClusterNode","page":"Clustering","title":"PortfolioOptimiser.ClusterNode","text":"struct ClusterNode{tid, tl, tr, td, tcnt}\n    id::tid\n    left::tl\n    right::tr\n    height::td\n    level::tcnt\n\n    function ClusterNode(id, left::Union{ClusterNode, Nothing} = nothing,\n                         right::Union{ClusterNode, Nothing} = nothing, height::Real = 0.0,\n                         level::Int = 1)\n        ilevel = isnothing(left) ? level : (left.level + right.level)\n\n        return new{typeof(id), typeof(left), typeof(right), typeof(height), typeof(level)}(id,\n                                                                                         left,\n                                                                                         right,\n                                                                                         height,\n                                                                                         ilevel)\n    end\nend\n\nStructure for definining a cluster node. This is used for turning a clustering result into a tree, is_leaf, pre_order, to_tree.\n\nParameters\n\nid: node ID.\nleft: node to the left.\nright: node to the right.\nheight: node height.\nlevel: node level.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHT","page":"Clustering","title":"PortfolioOptimiser.DBHT","text":"mutable struct DBHT <: ClustAlg\n    distance::DistType\n    similarity::DBHTSimilarity\n    root_type::DBHTRootType\nend\n\nDefines the parameters for computing DBHTs [4].\n\nParameters\n\ndistance: type for computing the distance matrix from correlation ones DistType.\nsimilarity: type for computing the similarity matrix from the correlation and/or distance ones DBHTSimilarity, dbht_similarity.\nroot_type: type for choosing clique roots DBHTRootType.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTExp","page":"Clustering","title":"PortfolioOptimiser.DBHTExp","text":"struct DBHTExp <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise exponential decay of the dissimilarity matrix in dbht_similarity.\n\nbeginalign\nS_ij = exp(-D_ij)\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTMaxDist","page":"Clustering","title":"PortfolioOptimiser.DBHTMaxDist","text":"struct DBHTMaxDist <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise squared distance from the maximum value of the dissimilarity matrix dbht_similarity.\n\nbeginalign\nS_ij = leftlceil (max mathbfD)^2 rightrceil - D_ij ^ 2\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\nmathbfD is the distance matrix.\n\n\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.EqualDBHT","page":"Clustering","title":"PortfolioOptimiser.EqualDBHT","text":"struct EqualDBHT <: DBHTRootType end\n\nCreate a clique's root from its adjacency tree in CliqueRoot.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HAC","page":"Clustering","title":"PortfolioOptimiser.HAC","text":"@kwdef mutable struct HAC <: ClustAlg\n    linkage::Symbol = :ward\nend\n\nUse a hierarchical clustering algorithm from Clustering.jl.\n\nParameters\n\nlinkage: linkage type supported by hclust.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.StdSilhouette","page":"Clustering","title":"PortfolioOptimiser.StdSilhouette","text":"@kwdef mutable struct StdSilhouette <: NumClusterType\n    metric::Union{Distances.SemiMetric, Nothing} = nothing\nend\n\nUse the standardised silhouette score for computing the number of clusters in calc_k_clusters.\n\nParameters\n\nmetric: metric for computing the silhouettes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.TwoDiff","page":"Clustering","title":"PortfolioOptimiser.TwoDiff","text":"struct TwoDiff <: NumClusterType end\n\nUse the two difference gap statistic for computing the number of clusters in calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.UniqueDBHT","page":"Clustering","title":"PortfolioOptimiser.UniqueDBHT","text":"struct UniqueDBHT <: DBHTRootType end\n\nCreate a unique root for a clique in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.calc_k_clusters-Tuple{ClustOpt, AbstractMatrix, Any}","page":"Clustering","title":"PortfolioOptimiser.calc_k_clusters","text":"calc_k_clusters(clust_opt::ClustOpt, dist::AbstractMatrix, clustering)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTExp, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTExp, S, D)\n\nComputes the DBHTExp similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTMaxDist, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTMaxDist, S, D)\n\nComputes the DBHTMaxDist similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.is_leaf-Tuple{ClusterNode}","page":"Clustering","title":"PortfolioOptimiser.is_leaf","text":"is_leaf(a::ClusterNode)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.pre_order","page":"Clustering","title":"PortfolioOptimiser.pre_order","text":"pre_order(a::ClusterNode, func::Function = x -> x.id)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.to_tree-Tuple{Clustering.Hclust}","page":"Clustering","title":"PortfolioOptimiser.to_tree","text":"to_tree(a::Hclust)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTs-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DBHTs","text":"DBHTs(D::AbstractMatrix{<:Real}, S::AbstractMatrix{<:Real}; branchorder::Symbol = :optimal,\n      type::Symbol = :Unique)\n\nPerform Direct Bubble Hierarchical Tree clustering, a deterministic clustering algorithm [4]. This version uses a graph-theoretic filtering technique called Triangulated Maximally Filtered Graph (TMFG).\n\nArguments\n\nD: N×N dissimilarity matrix, e.g. a distance matrix.\nS: N×N non-negative similarity matrix, examples include:\nmathbfS = mathbfC + lvert min mathbfC rvert.\nmathbfS = lceilmax left(mathbfD^odot 2right)rceil - mathbfD^odot 2.\nmathbfS = exp odot (-mathbfD).\nWhere mathbfC is the correlation matrix, mathbfD the dissimilarity matrix D, and odot the Hadamard (elementwise) operator.\nbranchorder: parameter for ordering the final dendrogram's branches accepted by Clustering.jl.\ntype: type for finding the root of a Direct Bubble Hierarchical Clustering Tree in case there is more than one candidate DBHTRootType.\n:Unique: create a unique root.\n:Equal: the root is created from the candidate's adjacency tree.\n\nOutputs\n\nT8: N×1 cluster membership vector.\nRpm: N×N adjacency matrix of the Planar Maximally Filtered Graph (PMFG).\nAdjv: Bubble cluster membership matrix from BubbleCluster8s.\nDpm: N×N shortest path length matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\nZ_hclust: Z matrix in Clustering.Hclust format.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.J_LoGo-Tuple{Any, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.J_LoGo","text":"J_LoGo(sigma, separators, cliques)\n\nCompute the sparse inverse covariance from a clique tree and separators [6].\n\nInputs\n\nsigma: N×N covariance matrix.\nseparators: list of 3-cliques that are not triangular faces.\ncliques: list of all 4-cliques.\n\nOutputs\n\njlogo: J_LoGo covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.PMFG_T2s","page":"Clustering","title":"PortfolioOptimiser.PMFG_T2s","text":"PMFG_T2s(W::AbstractMatrix{<:Real}, nargout::Integer = 3)\n\nConstructs a Triangulated Maximally Filtered Graph (TMFG) starting from a tetrahedron and recursively inserting vertices inside existing triangles (T2 move) in order to approximate a Maximal Planar Graph with the largest total weight, aka Planar Maximally Filtered Graph (PMFG). All weights are non-negative [7].\n\nArguments\n\nW: N×N matrix of non-negative weights.\nnargout: number of output arguments, the same arguments are always returne, this only controls whether some arguments are empty or not.\n\nOutputs\n\nA: adjacency matrix of the PMFG with weights.\ntri: list of triangles (triangular faces).\nclique3: list of 3-cliques taht are not triangular faces, all 3-cliques are given by [tri; clique3].\ncliques: list of all 4-cliques, if nargout <= 3, this will be returned as an empty array.\ncliqueTree: 4-cliques tree structure (adjacency matrix), if nargout <= 4, it is returned as an empty array.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/","page":"Clustering","title":"Clustering","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"ParameterEstimation/Types/ClusteringTypes.jl\",\n\"ParameterEstimation/Functions/ClusteringFunctions.jl\",\n\"ParameterEstimation/Functions/DBHTs.jl\"]","category":"page"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClustAlg","page":"Clustering","title":"PortfolioOptimiser.ClustAlg","text":"abstract type ClustAlg end\n\nAbstract type for subtyping hierarchical clustering types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTRootType","page":"Clustering","title":"PortfolioOptimiser.DBHTRootType","text":"abstract type DBHTRootType end\n\nAbstract type for subtyping types creating roots of cliques in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTSimilarity","page":"Clustering","title":"PortfolioOptimiser.DBHTSimilarity","text":"abstract type DBHTSimilarity end\n\nAbstract type for subtyping types for defining functions for computing similarity matrices from used in DBHT clustering PMFG_T2s [4, 7].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.NumClusterType","page":"Clustering","title":"PortfolioOptimiser.NumClusterType","text":"abstract type NumClusterType end\n\nAbstract type for subtyping types for determining the number of clusters in a Clustering.Hclust when calling calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.AdjCliq-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.AdjCliq","text":"AdjCliq(A::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real},\n        CliqRoot::AbstractVector{<:Real})\n\nFind adjacent clique to the root candidates.\n\nInputs\n\nA: N×N adjacency matrix.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nCliqRoot: Nc×1 vector of root cliques.\n\nOutputs\n\nAdj: Nc×Nc adjacency matrix of the cliques with the root cliques.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleCluster8s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleCluster8s","text":"BubbleCluster8s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                Hb::AbstractMatrix{<:Real}, Mb::AbstractMatrix{<:Real},\n                Mv::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real})\n\nObtains non-discrete and discrete clusterings from the bubble topology of the Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nHb: undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nAdjv: N×Nk cluster membership matrix for vertices for non-discrete clustering via the bubble topology. Adjv[n, k] = 1 indicates cluster membership of vertex n to the k'th non-discrete cluster.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleHierarchy-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleHierarchy","text":"BubbleHierarchy(Pred::AbstractVector{<:Real}, Sb::AbstractVector{<:Real})\n\nBuild the bubble hierarchy.\n\nInputs\n\nPred: Nc×1 vector of predicted hierarchies.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\nOutputs\n\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleMember-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleMember","text":"BubbleMember(Rpm::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n             Mc::AbstractMatrix{<:Real})\n\nAssigns each vertex in the to a specific bubble.\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nMc: Matrix of the bubbles which coincide with the cluster.\n\nOutputs\n\nMvv: Matrix of the vertices belonging to the bubble.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BuildHierarchy-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BuildHierarchy","text":"BuildHierarchy(M::AbstractMatrix{<:Real})\n\nBuilds the predicted hierarchy.\n\nInputs\n\nM: N×Nc matrix of nodes and 3-cliques.\n\nOutputs\n\nPred: Nc×1 vector of predicted hierarchies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqHierarchyTree2s","page":"Clustering","title":"PortfolioOptimiser.CliqHierarchyTree2s","text":"CliqHierarchyTree2s(Apm::AbstractMatrix{<:Real}, type::Symbol = :Unique)\n\nLooks for 3-cliques of a Maximal Planar Graph (MPG), then construct a hierarchy of the cliques with the definition of \"inside\" a clique being a subgraph of smaller size when the entire graph is made disjoint by removing the clique [5].\n\nInputs\n\nApm: N×N adjacency matrix of an MPG.\ntype: type for finding the root of the graph DBHTRootType. Uses Voronoi tesselation between tiling triangles.\nUniqueDBHT(): create a unique root.\nEqualDBHT(): the root is created from the candidate's adjacency tree.\n\nOutputs\n\nH1: Nc×Nc adjacency matrix for 3-clique hierarchical tree where Nc is the number of 3-cliques.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqueRoot-Tuple{UniqueDBHT, Any, Any, Any, Vararg{Any}}","page":"Clustering","title":"PortfolioOptimiser.CliqueRoot","text":"CliqueRoot(::UniqueDBHT, Root, Pred, Nc, args...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DendroConstruct-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Union{Real, AbstractVector{<:Real}}}","page":"Clustering","title":"PortfolioOptimiser.DendroConstruct","text":"DendroConstruct(Zi::AbstractMatrix{<:Real}, LabelVec1::AbstractVector{<:Real},\n                LabelVec2::AbstractVector{<:Real},\n                LinkageDist::Union{<:Real, AbstractVector{<:Real}})\n\nConstruct the linkage matrix by continuially adding rows to the matrix.\n\nInputs\n\nZi: Linkage matrix at iteration i in the same format as the output from Matlab.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: Linkage matrix at iteration i + 1 in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DirectHb-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DirectHb","text":"DirectHb(Rpm::AbstractMatrix{<:Real}, Hb::AbstractMatrix{<:Real},\n         Mb::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n         CliqList::AbstractMatrix{<:Real})\n\nComputes the directions on each separating 3-clique of a Maximal Planar Graph (MPH), hence computes the Directed Bubble Hierarchy Tree (DBHT).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the Planar Maximally Filtered Graph (MPFG).\nHb: Undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nHc: Nb×Nb unweighted directed adjacency matrix of the DBHT. Hc[i, j]=1 indicates a directed edge from bubble i to bubble j.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.FindDisjoint-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.FindDisjoint","text":"FindDisjoint(Adj::AbstractMatrix{<:Real}, Cliq::AbstractVector{<:Real})\n\nFinds disjointed cliques in adjacency matrix.\n\nInputs\n\nAdj: N×N adjacency matrix.\nCliq: 3×1 vector of 3-cliques.\n\nOutputs\n\nT: N×1 vector containing the adjacency number of each node.\nIndxNot: N×1 vector of nodes with no adjacencies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HierarchyConstruct4s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.HierarchyConstruct4s","text":"HierarchyConstruct4s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                     Tc::AbstractVector{<:Real}, Mv::AbstractMatrix{<:Real})\n\nConstructs the intra- and inter-cluster hierarchy by utilizing Bubble Hierarchy structure of a Maximal Planar graph, in this a Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\n\nOutputs\n\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.LinkageFunction-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.LinkageFunction","text":"LinkageFunction(d::AbstractMatrix{<:Real}, labelvec::AbstractVector{<:Real})\n\nLooks for the pair of clusters with the best linkage.\n\nInputs\n\nd: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nlabelvec: label vector for the vertices in the bubble.\n\nOutputs\n\nPairLink: pair of links with the best linkage.\ndvu: value of the best linkage.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.breadth-Tuple{AbstractMatrix{<:Real}, Integer}","page":"Clustering","title":"PortfolioOptimiser.breadth","text":"breadth(CIJ::AbstractMatrix{<:Real}, source::Integer)\n\nBreadth-first search.\n\nInputs\n\nCIJ: binary (directed/undirected) connection matrix.\nsource: source vertex.\n\nOutputs\n\ndistance: distance between source and i'th vertex (0 for source vertex).\nbranch: vertex that precedes i in the breadth-first search tree (-1 for source vertex).\n\nnote: Note\nBreadth-first search tree does not contain all paths (or all shortest paths), but allows the determination of at least one path with minimum distace. The entire graph is explored, starting from source vertex source.    # ColoursOriginal written by: Olaf Sporns, Indiana University, 2002/2007/2008\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.build_link_and_dendro-Tuple{AbstractRange, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.build_link_and_dendro","text":"build_link_and_dendro(rg::AbstractRange, dpm::AbstractMatrix{<:Real},\n                       LabelVec::AbstractVector{<:Real}, LabelVec1::AbstractVector{<:Real},\n                       LabelVec2::AbstractVector{<:Real}, V::AbstractVector{<:Real},\n                       nc::Real, Z::AbstractMatrix{<:Real})\n\nComputes iterates over the vertices to construct the linkage matrix iteration by iteration.\n\nInputs\n\nrg: range of indices of the vertices in a bubble.\ndpm: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nLabelVec: vector labels of all vertices.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: updated linkage matrix in the same format as the output from Matlab.\nnc: updated inverse of the linkage distance.\nLabelVec1: updated LabelVec1 for the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.clique3-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.clique3","text":"clique3(A::AbstractMatrix{<:Real})\n\nComputes the list of 3-cliques.\n\nInputs\n\nA: N×N adjacency matrix of a Maximal Planar Graph (MPG).\n\nOutputs\n\nK3: vector of vectors with the corresponding indices of candidate cliques.\nE: matrix with non-zero indices and entries of candidate cliques.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.distance_wei-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.distance_wei","text":"distance_wei(L::AbstractMatrix{<:Real})\n\nThe distance matrix contains lengths of shortest paths between all node pairs. An entry [u, v] represents the length of the shortest path from node u to node v. The average shortest path length is the characteristic path length of the network. The function uses Dijkstra's algorithm.\n\nInputs\n\nL: Directed/undirected connection-length matrix.\nLengths between disconnected nodes are set to Inf.\nLengths on the main diagonal are set to 0.\n\nnote: Note\nThe input matrix must be a connection-length matrix typically obtained via a mapping from weight to length. For instance, in a weighted correlation network, higher correlations are more naturally interpreted as shorter distances, and the input matrix should therefore be some inverse of the connectivity matrix, i.e. a distance matrix.The number of edges in the shortest weighted path may in general exceed the number of edges in the shortest binary paths (i.e. the shortest weighted paths computed on the binarised connectivity matrix), because the shortest weighted paths have the minimal weighted distance, not necessarily the minimal number of edges.\n\nOutputs\n\nD: distance (shortest weighted path) matrix.\nB: number of edged in the shortest weigthed path matrix.\n\nnote: Note\nBased on a Matlab implementation by:Mika Rubinov, UNSW/U Cambridge, 2007-2012.\nRick Betzel and Andrea Avena, IU, 2012\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.turn_into_Hclust_merges-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.turn_into_Hclust_merges","text":"turn_into_Hclust_merges(Z::AbstractMatrix{<:Real})\n\nTurns a Matlab-style linkage matrix to a useable format for Hclust.\n\nInputs\n\nZ: Matlab-style linkage matrix.\n\nOutputs\n\nZ: Hclust-style linkage matrix.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PortfolioOptimiser","category":"page"},{"location":"#PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser","category":"page"},{"location":"#PortfolioOptimiser.PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser.PortfolioOptimiser","text":"PortfolioOptimiser\n\nCategory Badge\nDocs (Image: Stable) (Image: Dev)\nExamples (Image: Binder)\nCI (Image: Tests) (Image: Documentation) (Image: Aqua)\nCoverage (Image: Codecov) (Image: Coveralls)\n\n\n\n\n\n","category":"module"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser is a library for portfolio optimisation. It offers a broad range of functionality, and is designed with ease of use, composability, extensibility, maintainability in mind. It does so by leveraging Julia's type system, multiple dispatch, and the principle of separation of concerns.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser takes a hands-off approach when it comes to solvers and solver settings. The built-in forumations are mostly conic in nature as these tend to yield more accurate solutions that are easier to solve. This means the choice of solver and its parameters are left to the user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library currently focues purely on optimisation and parameter estimation. There is currently no plan for backtesting, model selection, validation, or returns series generation. These may be implemented in the future as separate packages.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example shows how one can download the data and perform a simple optimisation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PortfolioOptimiser, TimeSeries, DataFrames, Clarabel, HiGHS, YFinance, Dates, JuMP\n\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Tickers of the assets we want to download.\nassets = sort!([\"SOUN\", \"RIVN\", \"GME\", \"AMC\", \"SOFI\", \"ENVX\", \"ANVS\", \"LUNR\", \"EOSE\", \"SMR\",\n                \"NVAX\", \"NKLA\", \"ACHR\", \"RKLB\", \"MARA\"])\n\n# Prices date range.\nDate_0 = \"2024-01-01\"\nDate_1 = \"2025-01-01\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\n\n# Convert vector of ordered dicts into a TimeArray.\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\n\n# Select only the adjusted close prices.\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\n\n# Rename the columns to the asset tickers.\nTimeSeries.rename!(prices, Symbol.(assets))\n\n# Generate the portfolio.\nportfolio = Portfolio(; prices = prices,\n                      # Continuous solvers.\n                      solvers = Dict(\n                                     # Key-value pair for a single solver-solver settings combination. \n                                     :Clarabel => Dict(\n                                                       # :solver must contain the solver instance.\n                                                       :solver => Clarabel.Optimizer,\n                                                       # :check_sol passes kwargs to JuMP.is_solved_and_feasible\n                                                       :check_sol => (allow_local = true,\n                                                                      allow_almost = true),\n                                                       # :params passes solver attributes to the solver.\n                                                       :params => Dict(\"verbose\" => false,\n                                                                       \"max_step_fraction\" => 0.75,\n                                                                       \"tol_gap_abs\" => 1e-9,\n                                                                       \"tol_gap_rel\" => 1e-9))),\n                      # Discrete solvers (for discrete allocation).\n                      alloc_solvers = Dict(\n                                           # Key-value pair for a single solver-solver settings combination. \n                                           :HiGHS => Dict(\n                                                          # :solver can be initialised with solver attributes.\n                                                          :solver => optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                               MOI.Silent() => true),\n                                                          :check_sol => (allow_local = true,\n                                                                         allow_almost = true))))\n\n# Compute the asset statistics.\nasset_statistics!(portfolio)\n\n# Optimise the portfolio using the traditional Markowitz model with a conic formulation.\nw = optimise!(portfolio, Trad())\n\n# Discretely allocate 69420 dollars in shares of the assets.\nwd = allocate!(portfolio; investment = 69420)\n\n# Show discrete allocation with optimal allocation.\nwd.optimal_weights = w.weights\nDataFrames.rename!(wd, :weights => :allocated_weights)\nshow(wd)","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Non-hierarchical optimisation models\nTraditional, Trad.\nRisk Budgeting, RB.\nRelaxed Risk Budgetting (Variance only), RRB.\nNear Optimal Centering, NOC.\nHierarchical optimisation models\nHierarchical Risk Parity, HRP.\nHierarchical Risk Parity Schur Complement (Variance only), SchurHRP.\nHierarchical Equal Risk Parity, HERC.\nNested Clustered Optimisation, NCO.","category":"page"},{"location":"#Expected-returns-estimators","page":"Home","title":"Expected returns estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic (weighted and unweighted), MuSimple.\nEquilibrium, MuEquil.\nShringage with Grand Mean GM, Volatility Weighted VW, and Mean Square Error MSE targets:\nJames-Stein, MuJS.\nBayes-Stein, MuBS.\nBodnar-Okhrin-Parolya, MuBOP.","category":"page"},{"location":"#Covariance-estimators","page":"Home","title":"Covariance estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These utilise StatsBase's API to define covariance estimators. Which means PortfolioOptimiser is compatible with CovarianceEstimation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser, PortCovCor.\nFull, CovFull.\nSemi, CovSemi.\nMutual Information, CovMutualInfo.\nDistance, CovDistance.\nLower Tail Dependence, CovLTD.\nGerber, CovGerber0, CovGerber1, CovGerber2.\nSmyth-Broby, CovSB0, CovSB1, CovSB2.\nSmyth-Broby-Gerber, CovGerberSB0, CovGerberSB1, CovGerberSB2.","category":"page"},{"location":"#Correlation-estimators","page":"Home","title":"Correlation estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These utilise StatsBase's API to define covariance estimators. Which means PortfolioOptimiser is compatible with CovarianceEstimation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All covariance estimators.\nSpearman, CorSpearman.\nKendall, CorKendall.","category":"page"},{"location":"#Distance-estimators","page":"Home","title":"Distance estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide distance and distance of distances estimators. Distance estimators have the prefix Dist, distance of distances have the prefix DistDist.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Canonical, DistCanonical, DistDistCanonical.\nMarcos López de Prado, DistMLP, DistDistMLP.\nGeneralised Marcos López de Prado, GenDistMLP, GenDistDistMLP.\nLog, DistLog, DistDistLog.\nDistance correlation, DistCor, DistDistCor.\nVariation of information, DistVarInfo, DistDistVarInfo.","category":"page"},{"location":"#Cokurtosis-estimators","page":"Home","title":"Cokurtosis estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full, KurtFull.\nSemi, KurtSemi.","category":"page"},{"location":"#Coskewness-estimators","page":"Home","title":"Coskewness estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full, SkewFull.\nSemi, SkewSemi.","category":"page"},{"location":"#Square-matrix-post-processing","page":"Home","title":"Square matrix post-processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fixing non-positive definite matrices, NoPosdef, PosdefNearest.\nMatrix denoising, NoDenoise, DenoiseFixed, DenoiseSpectral, DenoiseShrink.\nMatrix detoning, NoDetone, Detone.\nLocal-global sparsification of the matrix inverse, NoLoGo, LoGo.","category":"page"},{"location":"#Prior-estimators","page":"Home","title":"Prior estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Empirical, asset_statistics!.\nWorst-case uncertainty sets, wc_statistics!.\nFactor models, factor_statistics!.\nBlack-Litterman, black_litterman_statistics!.\nBlack-Litterman factor models, black_litterman_factor_statistics!.","category":"page"},{"location":"#Regression-models","page":"Home","title":"Regression models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward and Backward Regression, FReg, BReg, with criteria.\np-value threshold, PVal.\nAkaike's Information Criterion, AIC.\nCorrected Akaike's Information Criterion for small sample sizes, AICC.\nBayesian Information Criterion, BIC.\nR² of a linear model, RSq.\nadjusted R² for a linear model, AdjRSq.\nPrincipal Component-Based Regression, PCAReg, with targets.\nPCA target, PCATarget.\nProbabilistic PCA target, PPCATarget.","category":"page"},{"location":"#Worst-case-uncertainty-set-estimators","page":"Home","title":"Worst-case uncertainty set estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These are only for the covariance and expected returns.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Box and Elliptical sets, Box, Ellipse.\nAutoregressive Conditional Heteroskedasticity models, ArchWC, with bootstraps.\nStationary, StationaryBS.\nCircular, CircularBS.\nMoving, MovingBS.\nNormal, NormalWC.\nBox sets only.\nDelta, DeltaWC.\nElliptical set constraint error size estimation.\nNormal, KNormalWC.\nGeneral, KGeneralWC","category":"page"},{"location":"#Clustering","page":"Home","title":"Clustering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Bubble Hierarchy Trees, DBHT.\nHierarchical clustering, HAC.\nOptimal number of clusters.\nTwo-difference gap statistic, TwoDiff.\nStandardised silhouette scores, StdSilhouette.","category":"page"},{"location":"#Networks","page":"Home","title":"Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Triangular maximally filtered graphs (TMFG), TMFG.\nMinimum spanning trees (MST), MST.\nKruskal, KruskalTree.\nBoruvka, BoruvkaTree.\nPrim, PrimTree.\nCentrality measures.\nBetweenness, BetweennessCentrality.\nCloseness, ClosenessCentrality.\nDegree, DegreeCentrality.\nEigenvector, EigenvectorCentrality.\nKatz, KatzCentrality.\nPagerank, Pagerank.\nRadiality, RadialityCentrality.\nStress, StressCentrality.","category":"page"},{"location":"","page":"Home","title":"Home","text":"UP TO HERE","category":"page"},{"location":"#Black-Litterman-models","page":"Home","title":"Black Litterman models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Black Litterman, BLType.","category":"page"},{"location":"#Black-Litterman-factor-models","page":"Home","title":"Black Litterman factor models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Augmented Black Litterman, ABLType.\nBayesian Black Litterman, BBLType.","category":"page"},{"location":"#Linear-moments-(L-moments)","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Normalised constant relative risk aversion coefficients, CRRA.\nMaximum entropy, MaxEntropy.\nMinimum Sum of Squares, MinSumSq.\nMinimum Square Distance, MinSqDist.","category":"page"},{"location":"#Portfolio-optimisation","page":"Home","title":"Portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of Portfolio.","category":"page"},{"location":"#Traditional,-[Trad](@ref)","page":"Home","title":"Traditional, Trad","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation is the traditional efficient frontier optimisation.","category":"page"},{"location":"#Classes,-[PortClass](@ref)","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Objective-functions","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-measures","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-2","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Worst-case-mean-variance","page":"Home","title":"Worst case mean variance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires worst case sets for the covariance and expected returns. The optimisation uses these sets to perform a mean variance optimisation.","category":"page"},{"location":"#Constraints-2","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected worst case standard deviation constraint.\nMinimum expected worst case return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-parity,-[RB](@ref)","page":"Home","title":"Risk parity, RB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset or factor. The optimisation attempts to minimise the difference between the risk budget and risk contribution of the asset or factor in the optimised portfolio.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-2","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nFactor risk contribution, FC.","category":"page"},{"location":"#Constraints-3","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Risk-measures-2","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-2","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-2","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-2","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-3","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Relaxed-risk-parity-mean-variance,-[RRB](@ref)","page":"Home","title":"Relaxed risk parity mean variance, RRB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset. The optimisation attempts to minimise the difference between the risk budget and relaxed formulation of the standard deviation risk measure.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-3","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.","category":"page"},{"location":"#Constraints-4","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Near-Optimal-Centering,-[NOC](@ref)","page":"Home","title":"Near Optimal Centering, NOC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Near optimal centering utilise the weights of an optimised portfolio. It computes a region of near optimality using the bounds of the efficient frontier, the expected risk and return of the optimal portfolio, and a user-provided parameter. It then optimises for a portfolio that best describes the region. It provides more diversification and robustness than Trad and smooths out the weight transitions as the efficient frontier is traversed.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-4","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Constraints-5","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-5","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns-2","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Constraints-6","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.","category":"page"},{"location":"#Risk-measures-3","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-3","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-3","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-3","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-4","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Hierarchical-portfolio-optimisation","page":"Home","title":"Hierarchical portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of .","category":"page"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref),-and-hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical risk parity, HRP, and hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref)","page":"Home","title":"Hierarchical risk parity, HRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical risk parity optimisations use the hierarchical clustering of assets to assign risk contributions by iteratively splitting the dendrogram in half and assigning weights to each half according to the relative risk each half represents with respect to the other. It does this until it splits the dendrogram all the way down to single leaves.","category":"page"},{"location":"#Hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical equal risk parity optimisations use the hierarchical clustering relationships between assets to assign risk contributions by splitting the dendrogram into k clusters. It starts with the full dendrogram and progressively cuts it into k-1 levels (since the comparison for each side belongs to the k-th level). At each step, it loops through the clusters and checks to which side of the sub-dendrogram the cluster belongs. It accumulates the risk of that cluster to the risk of the side it belongs to. The weights for the assets on each side of the dendrogram are assigned based on the relative (with respect to the other side) aggregate risk from all clusters belonging to it, these are the inter-cluster weights. It then computes the risk for each cluster, assigning weights to each asset according to the relative risk it represents with respect to other assets, these are the intra-cluster weights. It then elementwise multiplies both weights to get the final asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HERC can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Constraints-7","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum and maximum weights per asset.","category":"page"},{"location":"#Risk-measures-4","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-4","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nVariance, Variance.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, Skew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi Variance, Variance.\nSemi standard deviation, SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSecond lower partial moment (Sortino ratio), SLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, SSkew.","category":"page"},{"location":"#Downside-4","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nValue at risk (VaR), VaR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-4","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nDrawdown at for uncompounded cumulative returns risk (DaR), DaR.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\nMaximum drawdown (Calmar ratio) for compounded cumulative returns, MDD_r.\nAverage drawdown for compounded cumulative returns, ADD_r.\nUlcer index for compounded cumulative returns, UCI_r.\nDrawdown at for compounded cumulative returns risk (DaR), DaR_r.\nConditional drawdown at risk for compounded cumulative returns (CDaR), CDaR_r.\nEntropic drawdown at risk for compounded cumulative returns (EDaR), EDaR_r.\nRelativistic drawdown at risk for compounded cumulative returns (RLDaR), RLDaR_r.","category":"page"},{"location":"#Linear-moments-(L-moments)-5","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Equal-Risk-Contribution","page":"Home","title":"Equal Risk Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equal risk contribution, Equal.","category":"page"},{"location":"#Nested-clustered-optimisation,-[NCO](@ref)","page":"Home","title":"Nested clustered optimisation, NCO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nested clustered optimisation combines the ideas of hierarchical equal risk parity optimisations and portfolio optimisations. They use the hierarchical clustering relationships between assets and splitting the dendrogram into k clusters. It then treats each cluster as its own isntance of Portfolio which is optimised in the usual way. The weights of each cluster are saved in a matrix, these are the intra-cluster weights. Then each cluster as a whole is treated as a synthetic asset, it statistics are internally computed from the fields in the NCO type. An instance of Portfolio is created from these synthetic assets and then optimised, these are the inter-cluster weights. The inter-cluster and intra-cluster weights are multiplied to give the asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NCO can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Sub-types","page":"Home","title":"Sub-types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NCO can take keyword arguments that define the supported by optimisations of Portfolio. Since there are intra- and inter-cluster optimisations, it can take individual arguments for both. This means it can perform any combination of Portfolio optimisations.","category":"page"},{"location":"#NCO-Trad,-NCO-NOC-Trad","page":"Home","title":"NCO-Trad, NCO-NOC-Trad","text":"","category":"section"},{"location":"#Objective-functions-2","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints-8","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLeverage constraints.","category":"page"},{"location":"#NCO-RB,-NCO-RRB,-NCO-NOC-RB,-NCO-NOC-RRB","page":"Home","title":"NCO-RB, NCO-RRB, NCO-NOC-RB, NCO-NOC-RRB","text":"","category":"section"},{"location":"#Constraints-9","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.","category":"page"},{"location":"Constraints/WeightConstraints/#Weight-constraints","page":"Weight constraints","title":"Weight constraints","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#Public","page":"Weight constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.asset_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.asset_constraints","text":"asset_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the linear constraint matrix A and vector B:\n\nmathbfA bmw geq bmB.\n\nInputs\n\nconstraints: Nc×10 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nSubset: whole class.\nAll Assets: all assets.\nAll Subsets: all asset classes.\nEach Asset in Subset: specific assets in a class.\nSet: (String) if Type is Subset, All Subsets or Each Asset in Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nRelative_Type: (String) specifies to what the constraint is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative constraint.\nFactor: (<:Real) the factor of the relative constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nA: Nc×Na matrix of constraints where  and .\nB: Nc×1 vector of constraints where .\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\", \"FCN\",\n                                   \"TKO\", \"ZOO\", \"ZVO\", \"ZX\", \"ZZA\", \"ZZB\", \"ZZC\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\", \"Equity\", \"Equity\",\n                                     \"Equity\", \"Fixed Income\", \"Fixed Income\", \"Equity\",\n                                     \"Fixed Income\", \"Equity\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\", \"Financial\",\n                                     \"Entertainment\", \"Treasury\", \"Financial\", \"Financial\",\n                                     \"Entertainment\", \"Technology\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true, true, true, true,\n                                      true, true, true, true, true, true],\n                        \"Type\" => [\"Subset\", \"All Subsets\", \"Asset\", \"Asset\", \"Subset\",\n                                   \"All Assets\", \"Each Asset in Subset\", \"Asset\",\n                                   \"All Assets\", \"All Assets\", \"Subset\", \"All Subsets\",\n                                   \"All Subsets\", \"Each Asset in Subset\",\n                                   \"Each Asset in Subset\"],\n                        \"Set\" => [\"Class 1\", \"Class 1\", \"\", \"\", \"Class 2\", \"\", \"Class 1\",\n                                  \"Class 1\", \"Class 2\", \"\", \"Class 1\", \"Class 2\", \"Class 2\",\n                                  \"Class 2\", \"Class 1\"],\n                        \"Position\" => [\"Equity\", \"Fixed Income\", \"BAC\", \"WFC\", \"Financial\",\n                                       \"\", \"Equity\", \"FCN\", \"TKO\", \"ZOO\", \"Fixed Income\",\n                                       \"Treasury\", \"Entertainment\", \"Treasury\", \"Equity\"],\n                        \"Sign\" => [\"<=\", \"<=\", \"<=\", \"<=\", \">=\", \">=\", \">=\", \"<=\", \">=\",\n                                   \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\"],\n                        \"Weight\" => [0.6, 0.5, 0.1, \"\", \"\", 0.02, \"\", \"\", \"\", \"\", \"\", \"\",\n                                     \"\", 0.27, \"\"],\n                        \"Relative_Type\" => [\"\", \"\", \"\", \"Asset\", \"Subset\", \"\", \"Asset\",\n                                            \"Subset\", \"Asset\", \"Subset\", \"Asset\", \"Asset\",\n                                            \"Subset\", \"\", \"Subset\"],\n                        \"Relative_Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"\", \"\", \"Class 1\", \"\",\n                                           \"Class 2\", \"\", \"Class 2\", \"Class 2\", \"\",\n                                           \"Class 2\"],\n                        \"Relative_Position\" => [\"\", \"\", \"\", \"FB\", \"Fixed Income\", \"\", \"TLT\",\n                                                \"Equity\", \"NTFX\", \"Financial\", \"WFC\", \"ZOO\",\n                                                \"Entertainment\", \"\", \"Entertainment\"],\n                        \"Factor\" => [\"\", \"\", \"\", 1.2, 0.5, \"\", 0.4, 0.7, 0.21, 0.11, 0.13,\n                                     -0.17, 0.23, \"\", -0.31])\nA, B = asset_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.factor_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.factor_constraints","text":"factor_constraints(constraints::DataFrame, loadings::DataFrame)\n\nCreate the factor constraints matrix C and vector D:\n\nmathbfC bmw geq bmD.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nFactor: (String) name of the constraint's factor.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the constraint is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nC: Nc×Nf matrix of constraints where  and .\nD: Nc×1 vector of constraints where .\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true],\n                        \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\", \"const\"],\n                        \"Sign\" => [\"<=\", \"<=\", \">=\", \">=\"],\n                        \"Value\" => [0.9, -1.2, 0.3, -0.1],\n                        \"Relative_Factor\" => [\"USMV\", \"\", \"\", \"SIZE\"])\nC, D = factor_constraints(constraints, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.hrp_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.hrp_constraints","text":"hrp_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the upper and lower bounds constraints for hierarchical risk parity portfolios.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nAll Assets: all assets.\nEach Asset in Subset: specific assets in a class.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nw_min: Na×1 vector of the lower bounds for asset weights.\nw_max: Na×1 vector of the upper bounds for asset weights.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true],\n                        \"Type\" => [\"Asset\", \"Asset\", \"All Assets\", \"All Assets\",\n                                   \"Each Asset in Subset\", \"Each Asset in Subset\"],\n                        \"Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"Class 2\"],\n                        \"Position\" => [\"BAC\", \"FB\", \"\", \"\", \"Fixed Income\", \"Financial\"],\n                        \"Sign\" => [\">=\", \"<=\", \"<=\", \">=\", \"<=\", \"<=\"],\n                        \"Weight\" => [0.02, 0.085, 0.09, 0.01, 0.07, 0.06])\nw_min, w_max = hrp_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.rb_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.rb_constraints","text":"rb_constraints(asset_sets::DataFrame; type::Symbol = :Asset,\n               class_col::Union{String, Symbol, Nothing} = nothing)\n\nConstructs risk contribution constraint vector for the risk parity optimisation (:RB and :RRB types of PortTypes).\n\nInputs\n\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets. They are only used if type == :Subset.\nclass_col: index of set of classes from asset_sets to use in when type == :Subset.\n\nOutputs\n\nrw: risk contribution constraint vector.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\n\nrw_a = rb_constraints(asset_sets, :Asset)\nrw_c = rb_constraints(asset_sets, :Subset, \"Class 2\")\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.turnover_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.turnover_constraints","text":"turnover_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\n\"Asset\"\n\"All Assets\"\n\"Each Asset in Subset\"\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#Private","page":"Weight constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/WeightConstraints/","page":"Weight constraints","title":"Weight constraints","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Constraints/Functions/WeightConstraintFunctions.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Finalisation-functions","page":"Finalisation functions","title":"Finalisation functions","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Public","page":"Finalisation functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = true\nPrivate = false\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"},{"location":"Optimisation/OptimisationFinalisation/#Private","page":"Finalisation functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/","page":"Finalisation functions","title":"Finalisation functions","text":"Modules = [PortfolioOptimiser]\nPublic = false\nPrivate = true\nPages = [\"Optimisation/Functions/PortfolioOptimisationFinalisation.jl\",\n\"Optimisation/Functions/HCPortfolioOptimisationFinalisation.jl\"]","category":"page"}]
}
