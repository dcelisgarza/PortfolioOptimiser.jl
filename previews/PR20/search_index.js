var documenterSearchIndex = {"docs":
[{"location":"Constraint_functions/#Constraint-Functions","page":"Constraint Functions","title":"Constraint Functions","text":"","category":"section"},{"location":"Constraint_functions/","page":"Constraint Functions","title":"Constraint Functions","text":"rp_constraints","category":"page"},{"location":"Constraint_functions/#PortfolioOptimiser.rp_constraints","page":"Constraint Functions","title":"PortfolioOptimiser.rp_constraints","text":"\n\n\n\n","category":"function"},{"location":"Asset_statistics/#Asset-Statistics","page":"Asset Statistics","title":"Asset Statistics","text":"","category":"section"},{"location":"Asset_statistics/","page":"Asset Statistics","title":"Asset Statistics","text":"asset_statistics!\nwc_statistics!\nfactor_statistics!\nblack_litterman_statistics!\nblack_litterman_factor_satistics!\nmean_vec\nmu_estimator\ncovar_mtx","category":"page"},{"location":"Asset_statistics/#PortfolioOptimiser.asset_statistics!","page":"Asset Statistics","title":"PortfolioOptimiser.asset_statistics!","text":"asset_statistics!(\n    portfolio::AbstractPortfolio;\n    target_ret::AbstractFloat = 0.0,\n    mean_func::Function = mean,\n    cov_func::Function = cov,\n    cor_func::Function = cor,\n    std_func = std,\n    dist_func::Function = x -> sqrt.(clamp!((1 .- x) / 2, 0, 1)),\n    codep_type::Symbol = isa(portfolio, HCPortfolio) ? portfolio.codep_type : :Pearson,\n    custom_mu = nothing,\n    custom_cov = nothing,\n    custom_kurt = nothing,\n    custom_skurt = nothing,\n    mean_args::Tuple = (),\n    cov_args::Tuple = (),\n    cor_args::Tuple = (),\n    dist_args::Tuple = (),\n    std_args::Tuple = (),\n    calc_kurt = true,\n    mean_kwargs = (; dims = 1),\n    cov_kwargs::NamedTuple = (;),\n    cor_kwargs::NamedTuple = (;),\n    dist_kwargs::NamedTuple = (;),\n    std_kwargs::NamedTuple = (;),\n    uplo = :L,\n)\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.wc_statistics!","page":"Asset Statistics","title":"PortfolioOptimiser.wc_statistics!","text":"wc_statistics!(\n    portfolio;\n    box = :Stationary,\n    ellipse = :Stationary,\n    calc_box = true,\n    calc_ellipse = true,\n    q = 0.05,\n    n_sim = 3_000,\n    window = 3,\n    dmu = 0.1,\n    dcov = 0.1,\n    n_samples = 10_000,\n    seed = nothing,\n    rng = Random.default_rng(),\n    fix_cov_args::Tuple = (),\n    fix_cov_kwargs::NamedTuple = (;),\n)\n\nWorst case optimisation statistics.\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.factor_statistics!","page":"Asset Statistics","title":"PortfolioOptimiser.factor_statistics!","text":"factor_statistics!(\n    portfolio::AbstractPortfolio;\n    # cov_mtx\n    alpha::Real = 0.0,\n    cov_args::Tuple = (),\n    cov_est::CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true),\n    cov_func::Function = cov,\n    cov_kwargs::NamedTuple = (;),\n    cov_type::Symbol = :Full,\n    cov_weights::Union{AbstractWeights, Nothing} = nothing,\n    custom_cov::Union{AbstractMatrix, Nothing} = nothing,\n    denoise::Bool = false,\n    detone::Bool = false,\n    gs_threshold::Real = portfolio.gs_threshold,\n    jlogo::Bool = false,\n    kernel = ASH.Kernels.gaussian,\n    m::Integer = 10,\n    method::Symbol = :Fixed,\n    mkt_comp::Integer = 0,\n    n::Integer = 1000,\n    opt_args = (),\n    opt_kwargs = (;),\n    posdef_args::Tuple = (),\n    posdef_fix::Symbol = :Nearest,\n    posdef_func::Function = x -> x,\n    posdef_kwargs::NamedTuple = (;),\n    std_args::Tuple = (),\n    std_func::Function = std,\n    std_kwargs::NamedTuple = (;),\n    target_ret::Union{Real, AbstractVector{<:Real}} = 0.0,\n    # mean_vec\n    custom_mu::Union{AbstractVector, Nothing} = nothing,\n    mean_args::Tuple = (),\n    mean_func::Function = mean,\n    mean_kwargs::NamedTuple = (;),\n    mkt_ret::Union{AbstractVector, Nothing} = nothing,\n    mu_target::Symbol = :GM,\n    mu_type::Symbol = :Default,\n    mu_weights::Union{AbstractWeights, Nothing} = nothing,\n    rf = 0.0,\n    # Loadings matrix\n    B::Union{DataFrame, Nothing} = nothing,\n    criterion::Union{Symbol, Function} = :pval,\n    error::Bool = true,\n    pca_kwargs::NamedTuple = (;),\n    pca_std_kwargs::NamedTuple = (;),\n    pca_std_type = ZScoreTransform,\n    reg_type::Symbol = :FReg,\n    threshold::Real = 0.05,\n    var_func::Function = var,\n    var_args::Tuple = (),\n    var_kwargs::NamedTuple = (;),\n)\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.black_litterman_statistics!","page":"Asset Statistics","title":"PortfolioOptimiser.black_litterman_statistics!","text":"black_litterman_statistics!(\n    portfolio::AbstractPortfolio,\n    P::AbstractMatrix,\n    Q::AbstractVector,\n    w::AbstractVector = Vector{Float64}(undef, 0);\n    # cov_mtx\n    cov_args::Tuple = (),\n    cov_est::CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true),\n    cov_func::Function = cov,\n    cov_kwargs::NamedTuple = (;),\n    cov_type::Symbol = :Full,\n    cov_weights::Union{AbstractWeights, Nothing} = nothing,\n    custom_cov::Union{AbstractMatrix, Nothing} = nothing,\n    gs_threshold::Real = portfolio.gs_threshold,\n    jlogo::Bool = false,\n    posdef_args::Tuple = (),\n    posdef_fix::Symbol = :Nearest,\n    posdef_func::Function = x -> x,\n    posdef_kwargs::NamedTuple = (;),\n    std_args::Tuple = (),\n    std_func::Function = std,\n    std_kwargs::NamedTuple = (;),\n    target_ret::Union{Real, AbstractVector{<:Real}} = 0.0,\n    # mean_vec\n    custom_mu::Union{AbstractVector, Nothing} = nothing,\n    mean_args::Tuple = (),\n    mean_func::Function = mean,\n    mean_kwargs::NamedTuple = (;),\n    mkt_ret::Union{AbstractVector, Nothing} = nothing,\n    mu_target::Symbol = :GM,\n    mu_type::Symbol = :Default,\n    mu_weights::Union{AbstractWeights, Nothing} = nothing,\n    # Black Litterman\n    delta::Union{Real, Nothing} = nothing,\n    eq::Bool = true,\n    rf::Real = 0.0,\n)\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.black_litterman_factor_satistics!","page":"Asset Statistics","title":"PortfolioOptimiser.black_litterman_factor_satistics!","text":"black_litterman_factor_satistics!(\n    portfolio::AbstractPortfolio,\n    w::AbstractVector = Vector{Float64}(undef, 0);\n    # cov_mtx\n    cov_args::Tuple = (),\n    cov_est::CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true),\n    cov_func::Function = cov,\n    cov_kwargs::NamedTuple = (;),\n    cov_type::Symbol = :Full,\n    cov_weights::Union{AbstractWeights, Nothing} = nothing,\n    custom_cov::Union{AbstractMatrix, Nothing} = nothing,\n    gs_threshold::Real = portfolio.gs_threshold,\n    jlogo::Bool = false,\n    posdef_args::Tuple = (),\n    posdef_fix::Symbol = :Nearest,\n    posdef_func::Function = x -> x,\n    posdef_kwargs::NamedTuple = (;),\n    std_args::Tuple = (),\n    std_func::Function = std,\n    std_kwargs::NamedTuple = (;),\n    target_ret::Union{Real, AbstractVector{<:Real}} = 0.0,\n    # mean_vec\n    custom_mu::Union{AbstractVector, Nothing} = nothing,\n    mean_args::Tuple = (),\n    mean_func::Function = mean,\n    mean_kwargs::NamedTuple = (;),\n    mkt_ret::Union{AbstractVector, Nothing} = nothing,\n    mu_target::Symbol = :GM,\n    mu_type::Symbol = :Default,\n    mu_weights::Union{AbstractWeights, Nothing} = nothing,\n    # Black Litterman\n    B::Union{DataFrame, Nothing} = nothing,\n    P::Union{AbstractMatrix, Nothing} = nothing,\n    P_f::Union{AbstractMatrix, Nothing} = nothing,\n    Q::Union{AbstractVector, Nothing} = nothing,\n    Q_f::Union{AbstractVector, Nothing} = nothing,\n    bl_type::Symbol = :B,\n    delta::Real = 1.0,\n    diagonal::Bool = true,\n    eq::Bool = true,\n    rf::Real = 0.0,\n    var_args::Tuple = (),\n    var_func::Function = var,\n    var_kwargs::NamedTuple = (;),\n    # Loadings matrix\n    criterion::Union{Symbol, Function} = :pval,\n    pca_kwargs::NamedTuple = (;),\n    pca_std_kwargs::NamedTuple = (;),\n    pca_std_type = ZScoreTransform,\n    reg_type::Symbol = :FReg,\n    threshold::Real = 0.05,\n)\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.mean_vec","page":"Asset Statistics","title":"PortfolioOptimiser.mean_vec","text":"mean_vec(\n    returns::AbstractMatrix;\n    custom_mu::Union{AbstractVector, Nothing} = nothing,\n    mean_args::Tuple = (),\n    mean_func::Function = mean,\n    mean_kwargs::NamedTuple = (;),\n    mu_target::Symbol = :GM,\n    mu_type::Symbol = :Default,\n    mu_weights::Union{AbstractWeights, Nothing} = nothing,\n    rf::Real = 0.0,\n    sigma::Union{AbstractMatrix, Nothing} = nothing,\n)\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.mu_estimator","page":"Asset Statistics","title":"PortfolioOptimiser.mu_estimator","text":"mu_estimator\n\n\n\n\n\n","category":"function"},{"location":"Asset_statistics/#PortfolioOptimiser.covar_mtx","page":"Asset Statistics","title":"PortfolioOptimiser.covar_mtx","text":"covar_mtx\n\n\n\n\n\n","category":"function"},{"location":"DBHT/#Direct-Bubble-Hierarchical-Tree-Clustering","page":"DBHT","title":"Direct Bubble Hierarchical Tree Clustering","text":"","category":"section"},{"location":"DBHT/","page":"DBHT","title":"DBHT","text":"DBHTs","category":"page"},{"location":"DBHT/#PortfolioOptimiser.DBHTs","page":"DBHT","title":"PortfolioOptimiser.DBHTs","text":"DBHTs(D, S; branchorder = :optimal, method = :Unique)\n\n\n\n\n\n","category":"function"},{"location":"Definitions/#Constant-Definitions","page":"Definitions","title":"Constant Definitions","text":"","category":"section"},{"location":"Definitions/","page":"Definitions","title":"Definitions","text":"Many functions only accept specific methods and/or require certain arguments to be within appropriate bounds. These constants ensure such requirements are met.","category":"page"},{"location":"Definitions/","page":"Definitions","title":"Definitions","text":"RiskMeasures\nKellyRet\nTrackingErrKinds\nObjFuncs\nValidTermination\nPortClasses\nPortTypes\nRRPVersions\nUncertaintyTypes\nEllipseTypes\nBoxTypes\nKindBootstrap\nBLFMType\nRPConstraintTypes\nDBHTRootMethods\nOWAMethods\nBinTypes\nHRRiskMeasures\nHCPortTypes\nCodepTypes\nLinkageTypes\nBranchOrderTypes\nHRObjFuncs\nMuTypes\nMuTargets\nCovTypes\nPosdefFixes\nRegCriteria\nFSType\nBLHist","category":"page"},{"location":"Definitions/#PortfolioOptimiser.RiskMeasures","page":"Definitions","title":"PortfolioOptimiser.RiskMeasures","text":"RiskMeasures = (\n    :SD,\n    :MAD,\n    :SSD,\n    :FLPM,\n    :SLPM,\n    :WR,\n    :CVaR,\n    :EVaR,\n    :RVaR,\n    :MDD,\n    :ADD,\n    :CDaR,\n    :UCI,\n    :EDaR,\n    :RDaR,\n    :Kurt,\n    :SKurt,\n    :GMD,\n    :RG,\n    :RCVaR,\n    :TG,\n    :RTG,\n    :OWA,\n)\n\nAvailable risk measures for :Trad and :RP type (see PortTypes) of Portfolio.\n\n:SD = standard deviation (SD).\n:MAD = max absolute deviation (MAD).\n:SSD = semi standard deviation (SSD).\n:FLPM = first lower partial moment (omega ratio) (FLPM).\n:SLPM = second lower partial moment (sortino ratio) (SLPM).\n:WR = worst realisation (WR).\n:CVaR = conditional value at risk (CVaR).\n:EVaR = entropic value at risk (EVaR).\n:RVaR = relativistic value at risk (RVaR).\n:MDD = maximum drawdown of uncompounded cumulative returns (MDD_abs).\n:ADD = average drawdown of uncompounded cumulative returns (ADD_abs).\n:CDaR = conditional drawdown at risk of uncompounded cumulative returns (CDaR_abs).\n:UCI = ulcer index of uncompounded cumulative returns (UCI_abs).\n:EDaR = entropic drawdown at risk of uncompounded cumulative returns (EDaR_abs).\n:RDaR = relativistic drawdown at risk of uncompounded cumulative returns (RDaR_abs).\n:Kurt = square root kurtosis (Kurt).\n:SKurt = square root semi-kurtosis (SKurt).\n:GMD = gini mean difference (GMD).\n:RG = range of returns (RG).\n:RCVaR = range of conditional value at risk (RCVaR).\n:TG = tail gini (TG).\n:RTG = range of tail gini (RTG).\n:OWA = ordered weight array (generic OWA weights) (OWA).\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.KellyRet","page":"Definitions","title":"PortfolioOptimiser.KellyRet","text":"KellyRet = (:None, :Approx, :Exact)\n\nAvailable types of Kelly returns for Portfolio.\n\n:None: arithmetic mean return, R(bmw) = bmmu cdot bmw.\n:Approx: first moment approximation of the logarithmic returns, R(bmw) = bmmu cdot bmw - dfrac12 bmw^intercal mathbfSigma bmw.\n:Exact: exact logarithmic returns, R(bmw) = dfrac1Tsumlimits_t=1^Tlnleft(1 + bmx_t cdot bmwright).\n\nWhere:\n\nmathbfSigma is the covariance matrix of the asset returns. \nbmx_t is the vector of asset returns at timestep t. \nbmmu is the vector of expected returns for each asset. \nand bmw is the asset weights vector.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.TrackingErrKinds","page":"Definitions","title":"PortfolioOptimiser.TrackingErrKinds","text":"TrackingErrKinds = (:Weights, :Returns)\n\nAvailable kinds of tracking errors for Portfolio.\n\n:Weights: provide a vector of asset weights which is used to compute the vector of benchmark returns,\nbmb = mathbfX bmw,\n\nwhere bmb is the benchmark returns vector, mathbfX the (T times N) asset returns matrix, and bmw the asset weights vector.\n\n:Returns: directly provide the vector of benchmark returns.\n\nThe benchmark is then used as a reference to optimise a portfolio that tracks it up to a given error.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.ObjFuncs","page":"Definitions","title":"PortfolioOptimiser.ObjFuncs","text":"ObjFuncs = (:Min_Risk, :Utility, :Sharpe, :Max_Ret)\n\nObjective functions available for use in :Trad and :WC optimisations of Portfolio (see PortTypes).\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.ValidTermination","page":"Definitions","title":"PortfolioOptimiser.ValidTermination","text":"ValidTermination = (\n    MOI.OPTIMAL,\n    MOI.ALMOST_OPTIMAL,\n    MOI.LOCALLY_SOLVED,\n    MOI.ALMOST_LOCALLY_SOLVED,\n    MOI.SOLUTION_LIMIT,\n    MOI.OBJECTIVE_LIMIT,\n)\n\nValid JuMP termination codes after optimising an instance of Portfolio. If the termination code is different to these, then the failures are logged in the .fail field of HCPortfolio and Portfolio.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.PortClasses","page":"Definitions","title":"PortfolioOptimiser.PortClasses","text":"PortClasses = (:Classic, :FM, :BL, :BLFM)\n\nAvailable choicees of summary parameters bmmu and bmSigma Portfolio.\n\n:Classic: when optimising with this option, bmmu and bmSigma take their values from historical estimates computed by asset_statistics!.\n:FM: when optimising with this option, bmmu and bmSigma take their values from the factor model computed by factor_statistics!.\n:BL: when optimising with this option, bmmu and bmSigma take their values from the Black-Litterman model computed by black_litterman_statistics!.\n:BLFM: when optimising with this option, bmmu and bmSigma take their values from the factor Black-Litterman model computed by black_litterman_factor_satistics!. This model has two versions defined in BLFMType.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.PortTypes","page":"Definitions","title":"PortfolioOptimiser.PortTypes","text":"PortTypes = (:Trad, :RP, :RRP, :WC)\n\nAvailable optimisation types for Portfolio.\n\n:Trad – Traditional Optimisations\n\nAvailable objective functions for :Trad optimisations. We can chose any of the objective functions in ObjFuncs and risk measures in RiskMeasures.\n\n:Min_Risk: minimum risk portfolio,\n\nbeginalign*\nundersetbmwmin qquad phi_j(bmw) \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad phi_i(bmw) leq c_i  forall  phi_i in leftPhiright \nqquad R(bmw) geq overlinemu\nendalign*\n\n:Utility: maximum utility portfolio,\n\nbeginalign*\nundersetbmwmax qquad R(bmw) - lambda phi_j(bmw) \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad phi_i(bmw) leq c_i  forall  phi_i in leftPhiright \nqquad R(bmw) geq overlinemu\nendalign*\n\n:Sharpe: maximum risk-adjusted return ratio portfolio,\n\nbeginalign*\nundersetbmwmax qquad dfracR(bmw) - rphi_j(bmw) \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad phi_i(bmw) leq c_i  forall  phi_i in leftPhiright \nqquad R(bmw) geq overlinemu\nendalign*\n\n:Max_Ret: maximum return portfolio,\n\nbeginalign*\nundersetbmwmax qquad R(bmw) \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad phi_i(bmw) leq c_i  forall  phi_i in leftPhiright \nqquad R(bmw) geq overlinemu\nendalign*\n\nWhere:\n\nbmw are the asset weights.\nphi_i is risk measure i from the set of available risk measures leftPhiright (see RiskMeasures).\nmathbfA bmw geq mathbfB is a set of linear constraints.\nc_i is the maximum acceptable value for risk measure phi_i of the optimised portfolio.\nR(bmw) is the return function from KellyRet.\noverlinemu is the minimum acceptable return of the optimised portfolio.\nlambda is the risk aversion coefficient.\nand r is the risk-free rate.\n\n:RP – Risk Parity Optimisations\n\nOptimises portfolios based on a vector of risk contributions per asset. We can chose any of the risk measures in RiskMeasures.\n\nbeginalign*\nundersetbmwmin qquad phi(bmw) \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad bmb cdot ln(bmw) geq c \nqquad R(bmw) geq overlinemu\nqquad bmw geq bm0\nendalign*\n\nWhere:\n\nbmw are the asset weights.\nphi a risk measure from the set of available risk measures (see RiskMeasures).\nmathbfA bmw geq mathbfB is a set of linear constraints.\nbmb is the vector of maximum allowable risk contribution per asset to the optimised portfolio.\nc is an auxiliary variable.\nR(bmw) is the return function from KellyRet.\nand overlinemu is the minimum acceptable return of the optimised portfolio.\n\n:RRP – Relaxed Risk Parity Optimisations\n\nOptimises portfolios based on a vector of risk contributions per asset. Defines its own risk measure using the portfolio returns covariance.\n\nbeginalign*\nundersetbmwmin qquad psi - gamma \nmathrmst qquad mathbfA bmw geq mathbfB \nqquad bmw^intercal  mathbfSigma bmw leq (psi^2 - rho^2)\nqquad lambda bmw^intercal  mathbfTheta bmw leq rho^2\nqquad bmzeta = mathbfSigma bmw\nqquad w_i zeta_i geq gamma^2 b_i qquad forall  i = 1 ldots N\nqquad R(bmw) geq overlinemu\nqquad sumlimits_i=1^N w_i = 1\nqquad bmw geq bm0\nqquad psi gamma rho geq 0\nendalign*\n\nWhere:\n\nbmw are the asset weights.\npsi is the average risk of the portfolio.\ngamma is the lower bound of the risk contribution for each asset.\nmathbfA bmw geq mathbfB is a set of linear constraints.\nmathbfSigma is the portfolio covariance.\nrho is a regularisation variable.\nmathbfTheta = mathrmdiagleft(mathbfSigmaright) .\nlambda is a penalty parameter for rho, taken from the available choices in RRPVersions.\nbmzeta is the vector of marginal risk for each asset.\nb_i is the maximum allowable risk contribution for asset i.\nN is the number of assets.\nR(bmw) is the return function from KellyRet.\nand overlinemu is the minimum acceptable return of the optimised portfolio.\n\n:WC – Worst Case Mean Variance Optimisations\n\nComputes the worst case mean variance portfolio according to user-selected uncertainty sets (see UncertaintyTypes) for the portfolio return and covariance. We can chose any of the objective functions in ObjFuncs.\n\n:Min_Risk: worst case minimum risk mean-variance portfolio,\n\nbeginalign*\nundersetbmwmax qquad undersetmathbfSigma in U_mathbfSigmamax bmw^intercal mathbfSigma bmw\nmathrmst qquad mathbfA bmw geq mathbfB\nendalign*\n\n:Utility: worst case maximum utility mean-variance portfolio,\n\nbeginalign*\nundersetbmwmax qquad undersetbmmu in U_bmmumin R(bmw) - undersetmathbfSigma in U_mathbfSigmamax lambda bmw^intercal mathbfSigma bmw\nmathrmst qquad mathbfA bmw geq mathbfB\nendalign*\n\n:Sharpe: worst case maximum risk-adjusted return ratio mean-variance portfolio,\n\nbeginalign*\nundersetbmwmax qquad dfracundersetbmmu in U_bmmumin R(bmw) - rundersetmathbfSigma in U_mathbfSigmamax left(bmw^intercal mathbfSigma bmwright)^12 \nmathrmst qquad mathbfA bmw geq mathbfB\nendalign*\n\n:Max_Ret: worst case maximum return mean-variance portfolio,\n\nbeginalign*\nundersetbmwmax qquad undersetbmmu in U_bmmumin R(bmw)\nmathrmst qquad mathbfA bmw geq mathbfB\nendalign*\n\nWhere:\n\nbmw are the asset weights.\nmathbfSigma is the covariance matrix of asset returns.\nU_Sigma is the uncertainty set for the covariance matrix, they can be:\n\nbeginalign*\nU_Sigma^mathrmbox = leftmathbfSigma vert mathbfSigma_l leq mathbfSigma leq mathbfSigma_u mathbfSigma succeq 0right\nU_Sigma^mathrmellipse = leftmathbfSigma vert leftmathrmvecleft(mathbfSigmaright) - mathrmvecleft(hatmathbfSigmaright)right mathbfSigma_mathbfSigma^-1 leftmathrmvecleft(mathbfSigmaright) - mathrmvecleft(hatmathbfSigmaright)right^intercal leq k_mathbfSigma^2  mathbfSigma succeq 0right\nendalign*\n\nWhere the following variables are estimated by assuming that the portfolio's asset return covariance can be generated by some matrix distribution. The distribution is sampled, and the estimates are calculated from them. Available choices can be found in BoxTypes and EllipseTypes for the box and ellipse sets respectively: \nthe mathrml and mathrmu subscripts denote lower and upper bounds for the covariance matrix given the samples.\nmathbfSigma_mathbfSigma is the covariance of the samples.\nhatmathbfSigma the expected covariance given the samples.\nand k_mathbfSigma is a significance parameter of the matrix distribution.\nmathbfA bmw geq mathbfB is a set of linear constraints.\nbmmu is the vector of expected returns for each asset. \nR(bmw) is the return function from KellyRet.\nU_bmmu is the uncertainty set for the asset returns, they can be:\n\nbeginalign*\nU_bmmu^mathrmbox = leftbmmu vert vert bmmu - bmhatmu vert leq delta right\nU_bmmu^mathrmellipse = leftbmmu vert left(bmmu - bmhatmuright) mathbfSigma_bmmu^-1 left(bmmu - bmhatmuright)^intercal leq k_bmmu^2right\nendalign*\n\nWhere the following variables are estimated by assuming that the portfolio's asset mean returns can be generated by some distribution. The distribution is sampled, and the estimates are calculated from them. Available choices can be found in BoxTypes and EllipseTypes for the box and ellipse sets respectively:\nhatbmmu the expected portfolio asset mean returns given the samples.\nmathbfSigma_bmmu is the covariance of the samples.\nand k_bmmu is a significance parameter of the distribution.\nlambda is the risk aversion coefficient.\nand r is the risk-free rate.\n\nThe worst case uncertainty sets are computed by wc_statistics!.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.RRPVersions","page":"Definitions","title":"PortfolioOptimiser.RRPVersions","text":"RRPVersions = (:None, :Reg, :Reg_Pen)\n\nAvailable versions of Relaxed Risk Parity Optimisations (see PortTypes).\n\n:None: no penalty.\n:Reg: regularisation constraint, rho.\n:Reg_Pen: regularisation and penalisation constraints, lambda and rho.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.UncertaintyTypes","page":"Definitions","title":"PortfolioOptimiser.UncertaintyTypes","text":"UncertaintyTypes = (:None, :Box, :Ellipse)\n\nAvailable types of uncertainty sets that can be computed with wc_statistics!, which are used by Worst Case Mean Variance Optimisations (see PortTypes, EllipseTypes, and BoxTypes).\n\n:Box: are box uncertainty sets, ie the sets are full matrices.\n:Ellipse: are elliptical uncertainty sets, ie the sets are diagonal matrices.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.EllipseTypes","page":"Definitions","title":"PortfolioOptimiser.EllipseTypes","text":"EllipseTypes = (:Stationary, :Circular, :Moving, :Normal)\n\nAvailable types of elliptical sets that can be computed with wc_statistics!, which are used by Worst Case Mean Variance Optimisations (see PortTypes).\n\n:Stationary: stationary bootstrapping method.\n:Circular: circular block bootstrapping method.\n:Moving: moving block bootstrapping method.\n:Normal: sets generated by assuming returns are normally distributed.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.BoxTypes","page":"Definitions","title":"PortfolioOptimiser.BoxTypes","text":"BoxTypes = (:Stationary, :Circular, :Moving, :Normal, :Delta)\n\nAvailable types of box sets that can be computed with wc_statistics!, which are used by Worst Case Mean Variance Optimisations (see PortTypes).\n\n:Stationary: stationary bootstrapping method.\n:Circular: circular block bootstrapping method.\n:Moving: moving block bootstrapping method.\n:Normal: normally distributed covariance and mean samples.\n:Delta: box sets are assumed to fall in the extrema of a well-defined interval.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.KindBootstrap","page":"Definitions","title":"PortfolioOptimiser.KindBootstrap","text":"KindBootstrap = (:Stationary, :Circular, :Moving)\n\nKind of bootstrap for computing the uncertainty sets with wc_statistics!, which are used by Worst Case Mean Variance Optimisations (see PortTypes).\n\n:Stationary: stationary bootstrapping method.\n:Circular: circular block bootstrapping method.\n:Moving: moving block bootstrapping method.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.BLFMType","page":"Definitions","title":"PortfolioOptimiser.BLFMType","text":"BLFMType = (:A, :B)\n\nVersions of the factor Black-Litterman Model.\n\n:B: Bayesian Black-Litterman, which uses the factors to generate the Black-Litterman estimates.\n:A: Augmented Black-Litterman, which uses the factors to adjust the Black-Litterman views.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.RPConstraintTypes","page":"Definitions","title":"PortfolioOptimiser.RPConstraintTypes","text":"RPConstraintTypes = (:Assets, :Classes)\n\nTypes of risk parity constraints for building the set of linear constraints via rp_constraints.\n\n:Assets: restrict the assets that meet the criteria.\n:Classes: restrict the assets in that class.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.DBHTRootMethods","page":"Definitions","title":"PortfolioOptimiser.DBHTRootMethods","text":"DBHTRootMethods = (:Unique, :Equal)\n\nMethods for finding the root of a Direct Bubble Hierarchical Clustering Tree in DBHTs, in case there is more than one candidate.\n\n:Unique: create a unique root.\n:Equal: the root is created from the candidate's adjacency tree. \n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.OWAMethods","page":"Definitions","title":"PortfolioOptimiser.OWAMethods","text":"OWAMethods = (:CRRA, :E, :SS, :SD)\n\nMethods for computing the weights used to combine higher order L-moments in owa_l_moment_crm.\n\nCRRA: Normalised Constant Relative Risk Aversion Coefficients.\n:E: Maximum Entropy.\n:SS: Minimum Sum of Squares.\n:SD: Minimum Square Distance.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.BinTypes","page":"Definitions","title":"PortfolioOptimiser.BinTypes","text":"BinTypes = (:KN, :FD, :SC, :HGR)\n\nMethods for calculating bin widths for mutual and variational information matrices computed by mut_var_info_mtx.\n\n:KN: Knuth's choice.\n:FD: Freedman-Diaconis' choice.\n:SC: Schotts' choice.\n:HGR: Hacine-Gharbi and Ravier's choice.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.HRRiskMeasures","page":"Definitions","title":"PortfolioOptimiser.HRRiskMeasures","text":"HRRiskMeasures = (\n    :SD,\n    :MAD,\n    :SSD,\n    :FLPM,\n    :SLPM,\n    :WR,\n    :CVaR,\n    :EVaR,\n    :RVaR,\n    :MDD,\n    :ADD,\n    :CDaR,\n    :UCI,\n    :EDaR,\n    :RDaR,\n    :Kurt,\n    :SKurt,\n    :GMD,\n    :RG,\n    :RCVaR,\n    :TG,\n    :RTG,\n    :OWA,\n    :Variance,\n    :Equal,\n    :VaR,\n    :DaR,\n    :DaR_r,\n    :MDD_r,\n    :ADD_r,\n    :CDaR_r,\n    :EDaR_r,\n    :RDaR_r,\n)\n\nAvailable risk measures for optimisations of HCPortfolio.\n\n:SD = standard deviation (SD).\n:MAD = max absolute deviation (MAD).\n:SSD = semi standard deviation (SSD).\n:FLPM = first lower partial moment (Omega ratio) (FLPM).\n:SLPM = second lower partial moment (Sortino ratio) (SLPM).\n:WR = worst realisation (WR).\n:CVaR = conditional value at risk (CVaR).\n:EVaR = entropic value at risk (EVaR).\n:RVaR = relativistic value at risk (RVaR).\n:MDD = maximum drawdown of uncompounded cumulative returns (Calmar ratio) (MDD_abs).\n:ADD = average drawdown of uncompounded cumulative returns (ADD_abs).\n:CDaR = conditional drawdown at risk of uncompounded cumulative returns (CDaR_abs).\n:UCI = ulcer index of uncompounded cumulative returns (UCI_abs).\n:EDaR = entropic drawdown at risk of uncompounded cumulative returns (EDaR_abs).\n:RDaR = relativistic drawdown at risk of uncompounded cumulative returns (RDaR_abs).\n:Kurt = square root kurtosis (Kurt).\n:SKurt = square root semi-kurtosis (SKurt).\n:GMD = gini mean difference (GMD).\n:RG = range of returns (RG).\n:RCVaR = range of conditional value at risk (RCVaR).\n:TG = tail gini (TG).\n:RTG = range of tail gini (RTG).\n:OWA = ordered weight array (generic OWA weights) (OWA).\n:Variance = variance (Variance).\n:Equal = equal risk contribution, 1/N where N is the number of assets.\n:VaR = value at risk (VaR).\n:DaR = drawdown at risk of uncompounded cumulative returns (DaR_abs).\n:DaR_r = drawdown at risk of compounded cumulative returns (DaR_rel).\n:MDD_r = maximum drawdown of compounded cumulative returns (MDD_rel).\n:ADD_r = average drawdown of compounded cumulative returns (ADD_rel).\n:CDaR_r = conditional drawdown at risk of compounded cumulative returns (CDaR_rel).\n:UCI_r = ulcer index of compounded cumulative returns (UCI_rel).\n:EDaR_r = entropic drawdown at risk of compounded cumulative returns (EDaR_rel).\n:RDaR_r = relativistic drawdown at risk of compounded cumulative returns (RDaR_rel).\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.HCPortTypes","page":"Definitions","title":"PortfolioOptimiser.HCPortTypes","text":"HCPortTypes = (:HRP, :HERC, :NCO)\n\nAvailable optimisation types for HCPortfolio.\n\n:HRP: Hierarchical Risk Parity.\n:HERC: Hierarhical Equal Risk Contribution.\n:NCO: Nested Clustered Optimisation.\n\nBoth :HERC and :NCO split their optimisations into two parts:\n\ninter-cluster optimisation.\nintra-cluster optimisation.\n\nThrefore they can make use of extra parameters:\n\n:HERC: accepts an extra risk measure rm_i and OWA weights owa_w_i parameters, which are used for the intra-cluster optimisations. They default to the same value as their external counterparts.\n:NCO: accepts an extra objective function obj_i kelly return kelly_i risk aversion parameter l_i risk measure rm_i and OWA weights owa_w_i parameters. They default to the same value as their external counterparts.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.CodepTypes","page":"Definitions","title":"PortfolioOptimiser.CodepTypes","text":"CodepTypes = (\n    :Pearson,\n    :Spearman,\n    :Kendall,\n    :Gerber0,\n    :Gerber1,\n    :Gerber2,\n    :Abs_Pearson,\n    :Abs_Spearman,\n    :Abs_Kendall,\n    :Distance,\n    :Mutual_Info,\n    :Tail,\n    :Cov_to_Cor,\n    :Custom_Func,\n    :Custom_Val,\n)\n\nMethods for estimating the codependence (correlation) matrix mathbfP, and distance matrix mathbfD.\n\n:Pearson: Pearson correlation, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Spearman: Spearman correlation, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Kendall: Kendall correlation, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Gerber0: Gerber statistic 0, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Gerber1: Gerber statistic 1, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Gerber2: Gerber statistic 2, mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Abs_Pearson: absolute value of the Pearson correlation, mathbfD_ij = sqrt1 - leftlvertmathbfP_ijrightrvert.\n:Abs_Spearman: absolute value of the Spearman correlation, mathbfD_ij = sqrt1 - leftlvertmathbfP_ijrightrvert.\n:Abs_Kendall: absolute value of the Kendall correlation, mathbfD_ij = sqrt1 - leftlvertmathbfP_ijrightrvert.\n:Distance: distance correlation matrix, , mathbfD_ij = sqrt1 - mathbfP_ij\n:Mutual_Info: mutual information matrix, mathbfD_ij is the variation information matrix.\n:Tail: lower tail dependence index matrix, mathbfD_ij = -logleft(mathbfP_ijright)\n:Cov_to_Cor: the covariance matrix is converted to a correlation matrix, the distance matrix is computed by a distance function which defaults to mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Custom_Func: custom function provided, the distance matrix is computed by a distance function which defaults to mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n:Custom_Val: custom value provided, the distance matrix is computed by a distance function which defaults to mathbfD_ij = sqrtdfrac12 left(1- mathbfP_ij right).\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.LinkageTypes","page":"Definitions","title":"PortfolioOptimiser.LinkageTypes","text":"LinkageTypes = (:single, :complete, :average, :ward, :ward_presquared, :DBHT)\n\nLinkage types available when optimising a HCPortfolio.\n\n:DBHT: is Direct Bubble Hierarchical Tree clustering.\nThe rest are linkage types supported by Clustering.hclust.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.BranchOrderTypes","page":"Definitions","title":"PortfolioOptimiser.BranchOrderTypes","text":"BranchOrderTypes = (:optimal, :barjoseph, :r, :default)\n\nAlgorithm to order leaves and branches.\n\n:default: if linkage is :DBHT, the leaves and branches remain as the algorithm orders them. If any other linkage is used, they fall back to :r as that is their default according to Clustering.hclust.\nAll other branch orders are as defined by Clustering.hclust.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.HRObjFuncs","page":"Definitions","title":"PortfolioOptimiser.HRObjFuncs","text":"HRObjFuncs = (:Min_Risk, :Utility, :Sharpe, :Max_Ret, :Equal)\n\nObjective funcions for :NCO HCPortTypes of HCPortfolio. \n\n:Min_Risk, :Utility, :Sharpe and :Max_Ret: optimise the sub-portfolios as :Trad PortTypes of Portfolio according to their respective definitions in ObjFuncs. \n:Equal: optimises the sub-portfolios as :RP optimisations with equal risk contribution per asset/cluster. We can't offer customiseable risk contributions because the size and composition of the clusters is initially unknown and depends on the chosen linkage method.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.MuTypes","page":"Definitions","title":"PortfolioOptimiser.MuTypes","text":"MuTypes = (:Default, :JS, :BS, :BOP, :CAPM, :Custom_Func, :Custom_Val)\n\nMethods for estimating the mean returns vector bmmu in mean_vec.\n\n:Default: is the standard historical.\n:JS: James-Stein.\n:BS: Bayes-Stein.\n:BOP: Bodnar-Okhrin-Parolya.\n:CAPM: Capital Asset Pricing Model.\n:Custom_Func: custom function provided.\n:Custom_Val: custom value provided.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.MuTargets","page":"Definitions","title":"PortfolioOptimiser.MuTargets","text":"MuTargets = (:GM, :VW, :SE)\n\nTargets for the :JS, :BS and :BOP estimators in mean_vec and mu_estimator.\n\n:GM: grand mean.\n:VW: volatility-weighted grand mean.\n:SE: mean square error of sample mean.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.CovTypes","page":"Definitions","title":"PortfolioOptimiser.CovTypes","text":"CovTypes = (:Full, :Semi, :Gerber0, :Gerber1, :Gerber2, :Custom_Func, :Custom_Val)\n\nMethods for estimating the covariance matrix mathbfSigma.\n\n:Full: full covariance matrix.\n:Semi: semi-covariance matrix.\n:Gerber0: Gerber statistic 0.\n:Gerber1: Gerber statistic 1.\n:Gerber2: Gerber statistic 2.\n:Custom_Func: custom function provided.\n:Custom_Val: custom value provided.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.PosdefFixes","page":"Definitions","title":"PortfolioOptimiser.PosdefFixes","text":"PosdefFixes = (:None, :Nearest, :Custom_Func)\n\nMethods for fixing non-positive definite matrices.\n\n:None: no fix is applied.\n:Nearest: nearest correlation matrix.\nCustom_Func: custom function provided.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.RegCriteria","page":"Definitions","title":"PortfolioOptimiser.RegCriteria","text":"RegCriteria = (:pval, GLM.aic, GLM.aicc, GLM.bic, GLM.r2, GLM.adjr2)\n\nCriteria for feature selection in regression functions.\n\n:pval: p-value feature selection.\nThe rest are methods applied to a fitted General Linear Model from GLM.jl.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.FSType","page":"Definitions","title":"PortfolioOptimiser.FSType","text":"FSType = (:FReg, :BReg, :PCR)\n\nMethods for feature selection when creating the loadings matrix.\n\n:FReg: forward regression;\n:Breg: backward regression;\n:PCR: Principal Component Regression using PCA.\n\n\n\n\n\n","category":"constant"},{"location":"Definitions/#PortfolioOptimiser.BLHist","page":"Definitions","title":"PortfolioOptimiser.BLHist","text":"BLHist = (1, 2, 3)\n\nChoice of what estimate of mathbfSigma to use. Factor models, :FM and :BLFM, can also use a factor model estimate of the returns matrix mathbfX.\n\n1:\n:FM: uses the factor model estimates of mathbfSigma and mathbfX.\n:BL: uses the Black Litterman estimate of mathbfSigma.\n:BLFM: uses the Black Litterman factor model estimate of mathbfSigma and factor model estimate of mathbfX.\n2:\n:FM: uses the standard estimates of mathbfSigma and mathbfX.\n:BL: uses the standard estimate of mathbfSigma.\n:BLFM: uses the standard estimates of mathbfSigma and mathbfX.\n3\n:FM and :BL do not support this option.\n:BLFM: uses the factor model estimates of mathbfSigma and mathbfX.\n\n\n\n\n\n","category":"constant"},{"location":"Types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Types/","page":"Types","title":"Types","text":"AbstractPortfolio\nPortfolio\nHCPortfolio","category":"page"},{"location":"Types/#PortfolioOptimiser.AbstractPortfolio","page":"Types","title":"PortfolioOptimiser.AbstractPortfolio","text":"AbstractPortfolio\n\nAbstract type for portfolios. Concrete portfolios subtype this see Portfolio and HCPortfolio.\n\n\n\n\n\n","category":"type"},{"location":"Types/#PortfolioOptimiser.Portfolio","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"mutable struct Portfolio{\n    # Portfolio characteristics\n    ast,\n    dat,\n    r,\n    s,\n    us,\n    ul,\n    ssl,\n    mnea,\n    mna,\n    mnaf,\n    tfa,\n    tfdat,\n    tretf,\n    l,\n    # Risk parameters\n    msvt,\n    lpmt,\n    ai,\n    a,\n    as,\n    tat,\n    bi,\n    b,\n    bs,\n    k,\n    tiat,\n    lnk,\n    topk,\n    tomk,\n    tk2,\n    tkinv,\n    tinvopk,\n    tinvomk,\n    mnak,\n    # Benchmark constraints\n    to,\n    tobw,\n    kte,\n    te,\n    rbi,\n    bw,\n    blbw,\n    # Risk and return constraints\n    ami,\n    bvi,\n    rbv,\n    ler,\n    ud,\n    umad,\n    usd,\n    ucvar,\n    uwr,\n    uflpm,\n    uslpm,\n    umd,\n    uad,\n    ucdar,\n    uuci,\n    uevar,\n    uedar,\n    ugmd,\n    ur,\n    urcvar,\n    utg,\n    urtg,\n    uowa,\n    wowa,\n    uk,\n    usk,\n    urvar,\n    urdar,\n    # Optimisation model inputs\n    tmu,\n    tcov,\n    tkurt,\n    tskurt,\n    tl2,\n    ts2,\n    tmuf,\n    tcovf,\n    tmufm,\n    tcovfm,\n    tmubl,\n    tcovbl,\n    tmublf,\n    tcovblf,\n    trfm,\n    tevar,\n    tedar,\n    trvar,\n    trdar,\n    tcovl,\n    tcovu,\n    tcovmu,\n    tcovs,\n    tdmu,\n    tkmu,\n    tks,\n    topt,\n    trpopt,\n    trrpopt,\n    twcopt,\n    tlim,\n    tfront,\n    tsolv,\n    tf,\n    toptpar,\n    tmod,\n} <: AbstractPortfolio\n    # Portfolio characteristics.\n    assets::ast\n    timestamps::dat\n    returns::r\n    short::s\n    short_u::us\n    long_u::ul\n    sum_short_long::ssl\n    min_number_effective_assets::mnea\n    max_number_assets::mna\n    max_number_assets_factor::mnaf\n    f_assets::tfa\n    f_timestamps::tfdat\n    f_returns::tretf\n    loadings::l\n    # Risk parameters.\n    msv_target::msvt\n    lpm_target::lpmt\n    alpha_i::ai\n    alpha::a\n    a_sim::as\n    at::tat\n    beta_i::bi\n    beta::b\n    b_sim::bs\n    kappa::k\n    invat::tiat\n    ln_k::lnk\n    opk::topk\n    omk::tomk\n    invkappa2::tk2\n    invk::tkinv\n    invopk::tinvopk\n    invomk::tinvomk\n    max_num_assets_kurt::mnak\n    # Benchmark constraints.\n    turnover::to\n    turnover_weights::tobw\n    kind_tracking_err::kte\n    tracking_err::te\n    tracking_err_returns::rbi\n    tracking_err_weights::bw\n    bl_bench_weights::blbw\n    # Risk and return constraints.\n    a_mtx_ineq::ami\n    b_vec_ineq::bvi\n    risk_budget::rbv\n    mu_l::ler\n    dev_u::ud\n    mad_u::umad\n    sdev_u::usd\n    cvar_u::ucvar\n    wr_u::uwr\n    flpm_u::uflpm\n    slpm_u::uslpm\n    mdd_u::umd\n    add_u::uad\n    cdar_u::ucdar\n    uci_u::uuci\n    evar_u::uevar\n    edar_u::uedar\n    gmd_u::ugmd\n    rg_u::ur\n    rcvar_u::urcvar\n    tg_u::utg\n    rtg_u::urtg\n    owa_u::uowa\n    owa_w::wowa\n    krt_u::uk\n    skrt_u::usk\n    rvar_u::urvar\n    rdar_u::urdar\n    # Optimisation model inputs.\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    mu_f::tmuf\n    cov_f::tcovf\n    mu_fm::tmufm\n    cov_fm::tcovfm\n    mu_bl::tmubl\n    cov_bl::tcovbl\n    mu_bl_fm::tmublf\n    cov_bl_fm::tcovblf\n    returns_fm::trfm\n    z::tz\n    # Inputs of Worst Case Optimization Models.\n    cov_l::tcovl\n    cov_u::tcovu\n    cov_mu::tcovmu\n    cov_sigma::tcovs\n    d_mu::tdmu\n    k_mu::tkmu\n    k_sigma::tks\n    # Optimal portfolios.\n    optimal::topt\n    limits::tlim\n    frontier::tfront\n    # Solver params.\n    solvers::tsolv\n    opt_params::toptpar\n    fail::tf\n    model::tmod\nend\n\nPortfolio(;\n    # Portfolio characteristics.\n    returns = DataFrame(),\n    ret::Matrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n    timestamps::Vector{<:Dates.AbstractTime} = Vector{Date}(undef, 0),\n    assets = Vector{String}(undef, 0),\n    short::Bool = false,\n    short_u::Real = 0.2,\n    long_u::Real = 1.0,\n    sum_short_long::Real = 1.0,\n    min_number_effective_assets::Integer = 0,\n    max_number_assets::Integer = 0,\n    max_number_assets_factor::Real = 100_000.0,\n    f_returns = DataFrame(),\n    loadings = Matrix{Float64}(undef, 0, 0),\n    # Risk parameters.\n    msv_target = Inf,\n    lpm_target = Inf,\n    alpha_i::Real = 0.0001,\n    alpha::Real = 0.05,\n    a_sim::Integer = 100,\n    beta_i::Union{<:Real, Nothing} = nothing,\n    beta::Union{<:Real, Nothing} = nothing,\n    b_sim::Union{<:Integer, Nothing} = nothing,\n    kappa::Real = 0.3,\n    max_num_assets_kurt::Integer = 0,\n    # Benchmark constraints.\n    turnover::Real = Inf,\n    turnover_weights = Vector{Float64}(undef, 0),\n    kind_tracking_err::Symbol = :Weights,\n    tracking_err::Real = Inf,\n    tracking_err_returns = Vector{Float64}(undef, 0),\n    tracking_err_weights = Vector{Float64}(undef, 0),\n    bl_bench_weights = Vector{Float64}(undef, 0),\n    # Risk and return constraints.\n    a_mtx_ineq = Matrix{Float64}(undef, 0, 0),\n    b_vec_ineq = Vector{Float64}(undef, 0),\n    risk_budget::Union{<:Real, AbstractVector{<:Real}} = Vector{Float64}(undef, 0),\n    mu_l::Real = Inf,\n    dev_u::Real = Inf,\n    mad_u::Real = Inf,\n    sdev_u::Real = Inf,\n    cvar_u::Real = Inf,\n    wr_u::Real = Inf,\n    flpm_u::Real = Inf,\n    slpm_u::Real = Inf,\n    mdd_u::Real = Inf,\n    add_u::Real = Inf,\n    cdar_u::Real = Inf,\n    uci_u::Real = Inf,\n    evar_u::Real = Inf,\n    edar_u::Real = Inf,\n    gmd_u::Real = Inf,\n    rg_u::Real = Inf,\n    rcvar_u::Real = Inf,\n    tg_u::Real = Inf,\n    rtg_u::Real = Inf,\n    owa_u::Real = Inf,\n    owa_w = Vector{Float64}(undef, 0),\n    krt_u::Real = Inf,\n    skrt_u::Real = Inf,\n    rvar_u::Real = Inf,\n    rdar_u::Real = Inf,\n    # Optimisation model inputs.\n    mu = Vector{Float64}(undef, 0),\n    cov = Matrix{Float64}(undef, 0, 0),\n    kurt = Matrix{Float64}(undef, 0, 0),\n    skurt = Matrix{Float64}(undef, 0, 0),\n    L_2 = SparseMatrixCSC{Float64, Int}(undef, 0, 0),\n    S_2 = SparseMatrixCSC{Float64, Int}(undef, 0, 0),\n    mu_f = Vector{Float64}(undef, 0),\n    cov_f = Matrix{Float64}(undef, 0, 0),\n    mu_fm = Vector{Float64}(undef, 0),\n    cov_fm = Matrix{Float64}(undef, 0, 0),\n    mu_bl = Vector{Float64}(undef, 0),\n    cov_bl = Matrix{Float64}(undef, 0, 0),\n    mu_bl_fm = Vector{Float64}(undef, 0),\n    cov_bl_fm = Matrix{Float64}(undef, 0, 0),\n    returns_fm = Matrix{Float64}(undef, 0, 0),\n    z_evar::Real = Inf,\n    z_edar::Real = Inf,\n    z_rvar::Real = Inf,\n    z_rdar::Real = Inf,\n    # Inputs of Worst Case Optimization Models.\n    cov_l = Matrix{Float64}(undef, 0, 0),\n    cov_u = Matrix{Float64}(undef, 0, 0),\n    cov_mu = Diagonal{Float64}(undef, 0),\n    cov_sigma = Diagonal{Float64}(undef, 0),\n    d_mu = Vector{Float64}(undef, 0),\n    k_mu::Real = Inf,\n    k_sigma::Real = Inf,\n    # Optimal portfolios.\n    optimal::AbstractDict = Dict(),\n    limits = Matrix{Float64}(undef, 0, 0),\n    frontier = Matrix{Float64}(undef, 0, 0),\n    # Solutions.\n    solvers::AbstractDict = Dict(),\n    opt_params::AbstractDict = Dict(),\n    fail::AbstractDict = Dict(),\n    model = JuMP.Model(),\n)\n\n\n\n\n\n","category":"type"},{"location":"Types/#PortfolioOptimiser.HCPortfolio","page":"Types","title":"PortfolioOptimiser.HCPortfolio","text":"mutable struct HCPortfolio{\n    ast,\n    dat,\n    r,\n    # Risk parmeters.\n    ai,\n    a,\n    as,\n    bi,\n    b,\n    bs,\n    k,\n    ata,\n    gst,\n    # Optimisation parameters.\n    tymu,\n    tmu,\n    tycov,\n    tcov,\n    tbin,\n    wmi,\n    wma,\n    ttco,\n    tco,\n    tdist,\n    tcl,\n    tk,\n    # Optimal portfolios.\n    topt,\n    # Solutions.\n    tsolv,\n    toptpar,\n    tf,\n} <: AbstractPortfolio\n    # Portfolio characteristics.\n    assets::ast\n    timestamps::dat\n    returns::r\n    # Risk parmeters.\n    alpha_i::ai\n    alpha::a\n    a_sim::as\n    beta_i::bi\n    beta::b\n    b_sim::bs\n    kappa::k\n    alpha_tail::ata\n    gs_threshold::gst\n    # Optimisation parameters.\n    mu_type::tymu\n    mu::tmu\n    cov_type::tycov\n    jlogo::tjlogo\n    cov::tcov\n    bins_info::tbin\n    w_min::wmi\n    w_max::wma\n    codep_type::ttco\n    codep::tco\n    dist::tdist\n    clusters::tcl\n    k::tk\n    # Optimal portfolios.\n    optimal::topt\n    # Solutions.\n    solvers::tsolv\n    opt_params::toptpar\n    fail::tf\nend\n\nHCPortfolio(;\n    # Portfolio characteristics.\n    returns = DataFrame(),\n    ret::Matrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n    timestamps::Vector{<:Dates.AbstractTime} = Vector{Date}(undef, 0),\n    assets = Vector{String}(undef, 0),\n    # Risk parmeters.\n    alpha_i::Real = 0.0001,\n    alpha::Real = 0.05,\n    a_sim::Integer = 100,\n    beta_i::Union{<:Real, Nothing} = nothing,\n    beta::Union{<:Real, Nothing} = nothing,\n    b_sim::Union{<:Integer, Nothing} = nothing,\n    kappa::Real = 0.3,\n    alpha_tail::Real = 0.05,\n    gs_threshold::Real = 0.5,\n    # Optimisation parameters.\n    mu_type::Symbol = :Default,\n    mu = Vector{Float64}(undef, 0),\n    cov_type::Symbol = :Full,\n    tjlogo::Bool = false,\n    cov = Matrix{Float64}(undef, 0, 0),\n    bins_info::Union{Symbol, Int} = :KN,\n    w_min::Union{<:Real, AbstractVector{<:Real}, Nothing} = 0.0,\n    w_max::Union{<:Real, AbstractVector{<:Real}, Nothing} = 1.0,\n    codep_type::Symbol = :Pearson,\n    codep = Matrix{Float64}(undef, 0, 0),\n    dist = Matrix{Float64}(undef, 0, 0),\n    clusters = Hclust{Float64}(Matrix{Int64}(undef, 0, 2), Float64[], Int64[], :nothing),\n    k::Union{Int, Nothing} = nothing,\n    # Solutions.\n    solvers::AbstractDict = Dict(),\n    opt_params::AbstractDict = Dict(),\n    fail::AbstractDict = Dict(),\n)\n\n\n\n\n\n","category":"type"},{"location":"Risk_measures/#Risk-Measures","page":"Risk Measures","title":"Risk Measures","text":"","category":"section"},{"location":"Risk_measures/#Traditional-Risk-Measures","page":"Risk Measures","title":"Traditional Risk Measures","text":"","category":"section"},{"location":"Risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Variance\nSD\nSSD\nMAD\nKurt\nSKurt\nFLPM\nSLPM\nWR\nVaR\nCVaR\nERM\nEVaR\nRRM\nRVaR\nDaR_abs\nMDD_abs\nADD_abs\nCDaR_abs\nUCI_abs\nEDaR_abs\nRDaR_abs\nDaR_rel\nMDD_rel\nADD_rel\nCDaR_rel\nUCI_rel\nEDaR_rel\nRDaR_rel","category":"page"},{"location":"Risk_measures/#PortfolioOptimiser.Variance","page":"Risk Measures","title":"PortfolioOptimiser.Variance","text":"Variance(w::AbstractVector, Σ::AbstractMatrix)\n\nCompute the Variance. Square of SD.\n\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\n\nArguments\n\nw: vector of asset weights;\nΣ: covariance matrix of asset returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.SD","page":"Risk Measures","title":"PortfolioOptimiser.SD","text":"SD(w::AbstractVector, Σ::AbstractMatrix)\n\nCompute the Standard Deviation. Square root of Variance.\n\nmathrmSD(bmw mathbfSigma) = leftbmw^intercal  mathbfSigma  bmwright^12\n\nArguments\n\nw: vector of asset weights;\nΣ: covariance matrix of asset returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.SSD","page":"Risk Measures","title":"PortfolioOptimiser.SSD","text":"SSD(x::AbstractVector)\n\nCompute the mean Semi-Standard Deviation.\n\nmathrmSSD(bmx) = leftdfrac1T-1 sumlimits_t=1^Tminleft(bmx_t - mathbbE(bmx) 0right)^2right^12\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.MAD","page":"Risk Measures","title":"PortfolioOptimiser.MAD","text":"MAD(x::AbstractVector)\n\nCompute the Mean Absolute Deviation.\n\nmathrmMAD(bmx) = dfrac1T sumlimits_t=1^T leftlvert x_t - mathbbE(bmx) rightrvert\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.Kurt","page":"Risk Measures","title":"PortfolioOptimiser.Kurt","text":"Kurt(x::AbstractVector)\n\nCompute the square root kurtosis.\n\nmathrmKurt(bmx) = leftdfrac1T sumlimits_t=1^T left( x_t - mathbbE(bmx) right)^4 right^12\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.SKurt","page":"Risk Measures","title":"PortfolioOptimiser.SKurt","text":"SKurt(x::AbstractVector)\n\nCompute the square root semi-kurtosis.\n\nmathrmSKurt(bmx) = leftdfrac1T sumlimits_t=1^T minleft( x_t - mathbbE(bmx) 0 right)^4 right^12\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.FLPM","page":"Risk Measures","title":"PortfolioOptimiser.FLPM","text":"FLPM(x::AbstractVector, r::Real = 0.0)\n\nCompute the First Lower Partial Moment (Omega ratio).\n\nmathrmFLPM(bmx r) = dfrac1T  sumlimits_t=1^Tmaxleft(r - bmx_t 0right)\n\nArguments\n\nx: vector of portfolio returns;\nr: minimum return target.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.SLPM","page":"Risk Measures","title":"PortfolioOptimiser.SLPM","text":"SLPM(x::AbstractVector, r::Real = 0.0)\n\nCompute the Second Lower Partial Moment (Sortino Ratio).\n\nmathrmSLPM(bmx r) = leftdfrac1T-1 sumlimits_t=1^Tmaxleft(r - bmx_t 0right)^2right^12\n\nArguments\n\nx: vector of portfolio returns;\nr: minimum return target.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.WR","page":"Risk Measures","title":"PortfolioOptimiser.WR","text":"WR(x::AbstractVector)\n\nCompute the Worst Realisation or Worst Case Scenario.\n\nmathrmWR(bmx) = -min(bmx)\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.VaR","page":"Risk Measures","title":"PortfolioOptimiser.VaR","text":"VaR(x::AbstractVector, α::Real = 0.05)\n\nCompute the Value at Risk, used in CVaR.\n\nmathrmVaR(bmx alpha) = -undersett in (0 T)inf left x_t in mathbbR  F_bmx(x_t)  alpha right\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.CVaR","page":"Risk Measures","title":"PortfolioOptimiser.CVaR","text":"CVaR(x::AbstractVector, α::Real = 0.05)\n\nCompute the Conditional Value at Risk.\n\nmathrmCVaR(bmx alpha) = mathrmVaR(bmx alpha) - dfrac1alpha T sumlimits_t=1^T minleft( x_t + mathrmVaR(bmx alpha) 0right)\n\nwhere mathrmVaR(bmx alpha) is the value at risk as defined in VaR.\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.ERM","page":"Risk Measures","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector, z::Real = 1.0, α::Real = 0.05)\n\nCompute the Entropic Risk Measure.\n\nmathrmERM(bmx z alpha) = z ln left( dfracM_bmxleft(z^-1right)alpha right)\n\nwhere M_bmxleft(z^-1right) is the moment generating function of bmx.\n\nArguments\n\nx: vector;\nα: significance level, α ∈ (0, 1);\nz: free parameter.\n\nERM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Risk Measure by minimising the function with respect to z. Used in EVaR, EDaR_abs and EDaR_rel.\n\nmathrmERM = begincases\nundersetz t umin  t + z ln(dfrac1alpha T)\nmathrmst  z geq sumlimits_i=1^T u_i\n (-x_i-t z u_i) in mathcalK_exp  forall  i=1dots T\nendcases\n\nwhere mathcalK_exp is the exponential cone.\n\nArguments\n\nx: vector;\nsolvers: dictionary of JuMP-supported solvers with Exponential Cone support;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.EVaR","page":"Risk Measures","title":"PortfolioOptimiser.EVaR","text":"EVaR(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Value at Risk.\n\nmathrmEVaR(bmxalpha) = undersetz  0inf leftmathrmERM(bmx z alpha)right\n\nwhere mathrmERM(bmx z alpha) is the entropic risk measure as defined in ERM.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with Exponential Cone support;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RRM","page":"Risk Measures","title":"PortfolioOptimiser.RRM","text":"RRM(\n    x::AbstractVector,\n    solvers::AbstractDict,\n    α::Real = 0.05,\n    κ::Real = 0.3,\n)\n\nCompute the Relativistic Risk Measure.\n\nmathrmRRM(bmx alpha kappa) = begincases\nundersetz t psi theta varepsilon omegamin  t + z ln_kappaleft(dfrac1alpha Tright) + sumlimits_i=1^T left(psi_i + theta_iright) \nmathrmst  z geq 0 \n -x_i - t + varepsilon_i + omega_i leq 0 \n left(zleft(dfrac1+kappa2kapparight) psi_ileft(dfrac1+kappakapparight) varepsilon_i right) in mathcalP_3^1(1+kappa) kappa(1+kappa) \n left(omega_ileft(dfrac11-kapparight) theta_ileft(dfrac1kapparight) -zleft(dfrac12kapparight) right) in mathcalP_3^1-kappa kappa \n forall  i = 1ldots T\nendcases\n\nwhere ln_kappa(x) = dfracx^kappa - x^-kappa2 kappa and mathcalP_3^alpha 1-alpha is the 3D Power Cone.\n\nArguments\n\nx: vector;\nsolvers: dictionary of JuMP-supported solvers with 3D Power Cone support;\nα: significance level, α ∈ (0, 1);\nκ: relativistic deformation parameter.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RVaR","page":"Risk Measures","title":"PortfolioOptimiser.RVaR","text":"RVaR(\n    x::AbstractVector,\n    solvers::AbstractDict,\n    α::Real = 0.05,\n    κ::Real = 0.3,\n)\n\nCompute the Relativistic Value at Risk.\n\nmathrmRVaR(bmx alpha kappa) = mathrmRRM(bmx alpha kappa)\n\nwhere mathrmRRM(bmx alpha kappa) is the Relativistic Risk Measure as defined in RRM.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with 3D Power Cone support;\nα: significance level, α ∈ (0, 1);\nκ: relativistic deformation parameter.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.DaR_abs","page":"Risk Measures","title":"PortfolioOptimiser.DaR_abs","text":"DaR_abs(x::AbstractArray, alpha::Real = 0.05)\n\nCompute the Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign*\nmathrmDaR_a(bmx alpha) = undersetj in (0 T)max left mathrmDD_a(bmx j) in mathbbR  F_mathrmDDleft(mathrmDD_a(bmx j)right)  1 - alpha right\nmathrmDD_a(bmx j) = undersett in (0 j)maxleft( sumlimits_i=0^t x_i right) - sumlimits_i=0^j x_i\nendalign*\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.MDD_abs","page":"Risk Measures","title":"PortfolioOptimiser.MDD_abs","text":"MDD_abs(x::AbstractVector)\n\nCompute the Maximum Drawdown of uncompounded cumulative returns.\n\nmathrmMDD_a(bmx) = undersetj in (0 T)max mathrmDD_a(bmx j)\n\nwhere mathrmDD_a(bmx j) is the Drawdown of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.ADD_abs","page":"Risk Measures","title":"PortfolioOptimiser.ADD_abs","text":"ADD_abs(x::AbstractVector)\n\nCompute the Average Drawdown of uncompounded cumulative returns.\n\nmathrmADD_a(bmx) = dfrac1T sumlimits_j=0^T mathrmDD_a(bmx j)\n\nwhere mathrmDD_a(bmx j) is the Drawdown of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.CDaR_abs","page":"Risk Measures","title":"PortfolioOptimiser.CDaR_abs","text":"CDaR_abs(x::AbstractVector, alpha::Real = 0.05)\n\nCompute the Conditional Drawdown at Risk of uncompounded cumulative returns.\n\nmathrmCDaR_a(bmx alpha) = mathrmDaR_a(bmx alpha) + dfrac1alpha T sumlimits_j=0^T maxleftmathrmDD_a(bmx j) - mathrmDaR_a(bmx alpha) 0 right \n\nwhere mathrmDD_a(bmx j) is the Drawdown of uncompounded cumulative returns as defined in DaR_abs, and mathrmDaR_a(bmx alpha) the Drawdown at Risk of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.UCI_abs","page":"Risk Measures","title":"PortfolioOptimiser.UCI_abs","text":"UCI_abs(x::AbstractVector)\n\nCompute the Ulcer Index of uncompounded cumulative returns.\n\nmathrmUCI_a(bmx) = leftdfrac1T sumlimits_j=0^T mathrmDD_a(bmx j)^2right^12\n\nwhere mathrmDD_a(bmx j) is the Drawdown of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.EDaR_abs","page":"Risk Measures","title":"PortfolioOptimiser.EDaR_abs","text":"EDaR_abs(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Drawdown at Risk of uncompounded cumulative returns.\n\nbeginalign*\nmathrmEDaR_a(bmxalpha) = undersetz  0inf leftmathrmERM(mathrmDD_a(bmx) z alpha)right\nmathrmDD_a(bmx) = leftj in (0 T)  mathrmDD_a(bmx j) right\nendalign*\n\nwhere mathrmERM(bmx z alpha) is the entropic risk measure as defined in ERM and mathrmDD_a(bmx j) the drawdown of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with Exponential Cone support;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RDaR_abs","page":"Risk Measures","title":"PortfolioOptimiser.RDaR_abs","text":"RDaR_abs(\n    x::AbstractVector,\n    solvers::AbstractDict,\n    alpha::Real = 0.05,\n    kappa::Real = 0.3,\n)\n\nCompute the Relativistic Drawdown at Risk of uncompounded cumulative returns.\n\nmathrmRDaR_a(bmx alpha kappa) = mathrmRRM(mathrmDD_a(bmx) alpha kappa)\n\nwhere mathrmRRM(mathrmDD_a(bmx) alpha kappa) is the relativistic risk measure as defined in RRM, and mathrmDD_a(bmx) the drawdown of uncompounded cumulative returns as defined in DaR_abs.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with 3D Power Cone support;\nα: significance level, α ∈ (0, 1);\nκ: relativistic deformation parameter.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.DaR_rel","page":"Risk Measures","title":"PortfolioOptimiser.DaR_rel","text":"DaR_rel(x::AbstractArray, alpha::Real = 0.05)\n\nCompute the Drawdown at Risk of compounded cumulative returns.\n\nbeginalign*\nmathrmDaR_r(bmx alpha) = undersetj in (0 T)max left mathrmDD_r(bmx j) in mathbbR  F_mathrmDDleft(mathrmDD_r(bmx j)right)  1 - alpha right\nmathrmDD_r(bmx j) = undersett in (0 j)maxleft( prodlimits_i=0^t left(1+x_iright) right) - prodlimits_i=0^j left(1+x_iright) \nendalign*\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.MDD_rel","page":"Risk Measures","title":"PortfolioOptimiser.MDD_rel","text":"MDD_rel(x::AbstractVector)\n\nCompute the Maximum Drawdown of compounded cumulative returns.\n\nmathrmMDD_r(bmx) = undersetj in (0 T)max mathrmDD_r(bmx j)\n\nwhere mathrmDD_a(bmx j) is the Drawdown of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.ADD_rel","page":"Risk Measures","title":"PortfolioOptimiser.ADD_rel","text":"ADD_rel(x::AbstractVector)\n\nCompute the Average Drawdown of compounded cumulative returns.\n\nmathrmADD_r(bmr) = dfrac1T sumlimits_j=0^T mathrmDD_r(bmx j)\n\nwhere mathrmDD_a(bmx j) is the Drawdown of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.CDaR_rel","page":"Risk Measures","title":"PortfolioOptimiser.CDaR_rel","text":"CDaR_rel(x::AbstractVector, alpha::Real = 0.05)\n\nCompute the Conditional Drawdown at Risk of compounded cumulative returns.\n\nmathrmCDaR_r(bmx alpha) = mathrmDaR_r(bmx alpha) + dfrac1alpha T sumlimits_j=0^T maxleftmathrmDD_r(bmx j) - mathrmDaR_r(bmx alpha) 0 right \n\nwhere mathrmDD_r(bmx j) is the Drawdown of compounded cumulative returns as defined in DaR_rel, and mathrmDaR_r(bmx alpha) the Drawdown at Risk of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level, α ∈ (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.UCI_rel","page":"Risk Measures","title":"PortfolioOptimiser.UCI_rel","text":"UCI_rel(x::AbstractVector)\n\nCompute the Ulcer Index of compounded cumulative returns.\n\nmathrmUCI_r(bmx) = leftdfrac1T sumlimits_j=0^T mathrmDD_r(bmx j)^2right^12\n\nwhere mathrmDD_r(bmx j) is the Drawdown of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.EDaR_rel","page":"Risk Measures","title":"PortfolioOptimiser.EDaR_rel","text":"EDaR_rel(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05)\n\nCompute the Entropic Drawdown at Risk of compounded cumulative returns.\n\nbeginalign*\nmathrmEDaR_r(bmxalpha) = undersetz  0inf leftmathrmERM(mathrmDD_r(bmx) z alpha)right\nmathrmDD_r(bmx) = leftj in (0 T)  mathrmDD_r(bmx j) right\nendalign*\n\nwhere mathrmERM(bmx z alpha) is the entropic risk measure as defined in ERM and mathrmDD_r(bmx j) the drawdown of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with 3D Power Cone support;\nα: significance level, α ∈ (0, 1);\nκ: relativistic deformation parameter.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RDaR_rel","page":"Risk Measures","title":"PortfolioOptimiser.RDaR_rel","text":"RDaR_rel(\n    x::AbstractVector,\n    solvers::AbstractDict,\n    alpha::Real = 0.05,\n    kappa::Real = 0.3,\n)\n\nCompute the Relativistic Drawdown at Risk of compounded cumulative returns.\n\nmathrmRDaR_r(bmx alpha kappa) = mathrmRRM(mathrmDD_r(bmx) alpha kappa)\n\nwhere mathrmRRM(mathrmDD_r(bmx) alpha kappa) is the Relativistic Risk Measure as defined in RRM where the returns vector, and mathrmDD_r(bmx) the drawdown of compounded cumulative returns as defined in DaR_rel.\n\nArguments\n\nx: vector of portfolio returns;\nsolvers: dictionary of JuMP-supported solvers with 3D Power Cone support;\nα: significance level, α ∈ (0, 1);\nκ: relativistic deformation parameter.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#Ordered-Weight-Array-(OWA)-Risk-Measures","page":"Risk Measures","title":"Ordered Weight Array (OWA) Risk Measures","text":"","category":"section"},{"location":"Risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"GMD\nRG\nRCVaR\nTG\nRTG\nOWA","category":"page"},{"location":"Risk_measures/#PortfolioOptimiser.GMD","page":"Risk Measures","title":"PortfolioOptimiser.GMD","text":"GMD(x::AbstractVector)\n\nCompute the Gini Mean Difference.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RG","page":"Risk Measures","title":"PortfolioOptimiser.RG","text":"RG(x::AbstractVector)\n\nCompute the Range.\n\nArguments\n\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RCVaR","page":"Risk Measures","title":"PortfolioOptimiser.RCVaR","text":"RCVaR(\n    x::AbstractVector;\n    α::Real = 0.05,\n    β::Union{<:Real, Nothing} = nothing,\n)\n\nCompute the CVaR Range.\n\nArguments\n\nx: vector of portfolio returns;\nα: significance level of CVaR losses, α ∈ (0, 1).\nβ: significance level of CVaR gains, β ∈ (0, 1), if nothing it takes the value of α.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.TG","page":"Risk Measures","title":"PortfolioOptimiser.TG","text":"TG(x::AbstractVector; α_i::Real = 0.0001, α::Real = 0.05, α_sim::Int = 100)\n\nCompute the Tail Gini.\n\nArguments\n\nx: vector of portfolio returns;\nα_i: start value of the significance level of CVaR losses, 0 < α_i < α;\nα: end value of the significance level of CVaR losses, α ∈ (0, 1);\nα_sim: number of steps between α_i and α.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.RTG","page":"Risk Measures","title":"PortfolioOptimiser.RTG","text":"RTG(\n    x::AbstractVector;\n    α_i::Real = 0.0001,\n    α::Real = 0.05,\n    α_sim::Real = 100,\n    β_i::Union{<:Real, Nothing} = nothing,\n    β::Union{<:Real, Nothing} = nothing,\n    β_sim::Union{Int, Nothing} = nothing,\n)\n\nCompute the Tail Gini Range.\n\nArguments\n\nx: vector of portfolio returns;\nα_i: start value of the significance level of CVaR losses, 0 < α_i < α;\nα: end value of the significance level of CVaR losses, α ∈ (0, 1);\nα_sim: number of steps between α_i and α.\nβ_i: start value of the significance level of CVaR gains, 0 < β_i < β, if nothing it takes the value of α_i;\nβ: end value of the significance level of CVaR gains, β ∈ (0, 1), if nothing it takes the value of α;\nβ_sim: number of steps between β_i and β, if nothing it takes the value of α_sim.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#PortfolioOptimiser.OWA","page":"Risk Measures","title":"PortfolioOptimiser.OWA","text":"OWA(x::AbstractVector, w::AbstractVector)\n\nCompute the Ordered Weight Array risk measure.\n\nArguments\n\nw: vector of asset weights;\nx: vector of portfolio returns.\n\n\n\n\n\n","category":"function"},{"location":"Risk_measures/#Wrapper-Functions","page":"Risk Measures","title":"Wrapper Functions","text":"","category":"section"},{"location":"Risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"calc_risk","category":"page"},{"location":"Risk_measures/#PortfolioOptimiser.calc_risk","page":"Risk Measures","title":"PortfolioOptimiser.calc_risk","text":"calc_risk(\n    w::AbstractVector,\n    returns::AbstractMatrix;\n    rm::Symbol = :SD,\n    rf::Real = 0.0,\n    cov::AbstractMatrix,\n    α_i::Real = 0.0001,\n    α::Real = 0.05,\n    α_sim::Int = 100,\n    β_i::Union{<:Real, Nothing} = nothing,\n    β::Union{<:Real, Nothing} = nothing,\n    β_sim::Union{<:Real, Nothing} = nothing,\n    κ::Real = 0.3,\n    solvers::Union{<:AbstractDict, Nothing} = nothing,\n)\n\nCompute the value of a risk measure given a vector of asset weights and returns.\n\nArguments\n\nw: vector of asset weights;\nreturns: matrix of asset returns where columns are assets and rows are timesteps;\nrm: risk measure from RiskMeasures and HRRiskMeasures;\nrf: risk-free rate at the frequency of returns, used as the minimum return target, r, in FLPM and SLPM;\ncov: covariance matrix of asset returns;\nα_i: start value of the significance level of CVaR losses, 0 < α_i < α;\nα: α ∈ (0, 1)\nif rm is not an OWA range measure: significance level; \nif rm is an OWA range measure: end value of the significance level of CVaR losses;\nα_sim: number of steps between α_i and α.\nβ_i: start value of the significance level of CVaR gains, 0 < β_i < β, if nothing it takes the value of α_i;\nβ: end value of the significance level of CVaR gains, β ∈ (0, 1), if nothing it takes the value of α;\nβ_sim: number of steps between β_i and β, if nothing it takes the value of α_sim;\nsolvers: dictionary of JuMP-supported solvers;\nif rm is an entropic risk measure, they need Exponential Cone support;\nif rm is a relativistic risk measure, they need 3D Power Cone.\n\ncalc_risk(\n    portfolio::AbstractPortfolio;\n    type::Symbol = isa(portfolio, Portfolio) ? :Trad : :HRP,\n    rm::Symbol = :SD,\n    rf::Real = 0.0,\n)\n\nCompute the value of a risk measure given a portfolio.\n\nArguments\n\nportfolio: optimised portfolio;\ntype: type of portfolio from PortTypes or HCPortTypes.\nrm: risk measure from RiskMeasures and HRRiskMeasures;\nrf: risk-free rate at the frequency of portfolio.returns, used as the minimum return target, r, in FLPM and SLPM.\n\n\n\n\n\n","category":"function"},{"location":"idx/#PortfolioOptimiser-API-Index","page":"Index","title":"PortfolioOptimiser API Index","text":"","category":"section"},{"location":"idx/","page":"Index","title":"Index","text":"","category":"page"},{"location":"OWA/#Ordered-Weight-Arrays","page":"OWA","title":"Ordered Weight Arrays","text":"","category":"section"},{"location":"OWA/","page":"OWA","title":"OWA","text":"owa_l_moment_crm","category":"page"},{"location":"OWA/#PortfolioOptimiser.owa_l_moment_crm","page":"OWA","title":"PortfolioOptimiser.owa_l_moment_crm","text":"owa_l_moment_crm(\n    T;\n    k = 2,\n    method = :SD,\n    g = 0.5,\n    max_phi = 0.5,\n    solvers = Dict(),\n    sol_params = Dict(),\n)\n\n\n\n\n\n","category":"function"},{"location":"Codependence/#Codependence","page":"Codependence","title":"Codependence","text":"","category":"section"},{"location":"Codependence/","page":"Codependence","title":"Codependence","text":"mut_var_info_mtx","category":"page"},{"location":"Codependence/#PortfolioOptimiser.mut_var_info_mtx","page":"Codependence","title":"PortfolioOptimiser.mut_var_info_mtx","text":"mut_var_info_mtx(x, bins_info = :KN, normed = true)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PortfolioOptimiser","category":"page"},{"location":"#PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PortfolioOptimiser.","category":"page"}]
}
