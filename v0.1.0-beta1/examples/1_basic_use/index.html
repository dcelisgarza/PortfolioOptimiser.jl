<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 1: Basic use · PortfolioOptimiser.jl</title><meta name="title" content="Example 1: Basic use · PortfolioOptimiser.jl"/><meta property="og:title" content="Example 1: Basic use · PortfolioOptimiser.jl"/><meta property="twitter:title" content="Example 1: Basic use · PortfolioOptimiser.jl"/><meta name="description" content="Documentation for PortfolioOptimiser.jl."/><meta property="og:description" content="Documentation for PortfolioOptimiser.jl."/><meta property="twitter:description" content="Documentation for PortfolioOptimiser.jl."/><meta property="og:url" content="https://dcelisgarza.github.io/PortfolioOptimiser.jl/examples/1_basic_use/"/><meta property="twitter:url" content="https://dcelisgarza.github.io/PortfolioOptimiser.jl/examples/1_basic_use/"/><link rel="canonical" href="https://dcelisgarza.github.io/PortfolioOptimiser.jl/examples/1_basic_use/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PortfolioOptimiser.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PortfolioOptimiser.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../0_not_financial_advice/">Example 0: Not financial advice</a></li><li class="is-active"><a class="tocitem" href>Example 1: Basic use</a><ul class="internal"><li><a class="tocitem" href="#1.1-Downloading-the-data"><span>1.1 Downloading the data</span></a></li><li><a class="tocitem" href="#1.2-Instantiating-an-instance-of-[Portfolio](@ref)."><span>1.2 Instantiating an instance of <code>Portfolio</code>.</span></a></li><li><a class="tocitem" href="#1.3-Computing-statistics"><span>1.3 Computing statistics</span></a></li><li><a class="tocitem" href="#1.4-Optimising-the-portfolio"><span>1.4 Optimising the portfolio</span></a></li><li><a class="tocitem" href="#1.5-Asset-allocation"><span>1.5 Asset allocation</span></a></li><li><a class="tocitem" href="#1.6-Plotting-the-portfolio"><span>1.6 Plotting the portfolio</span></a></li><li><a class="tocitem" href="#1.7-Efficient-frontier"><span>1.7 Efficient frontier</span></a></li></ul></li><li><a class="tocitem" href="../2_asset_statistics/">Example 2: Asset statistics</a></li><li><a class="tocitem" href="../3_shorting_portfolios/">Example 3: Shorting and leveraged portfolios</a></li><li><a class="tocitem" href="../4_hrp_portfolios/">Example 4: Hierarchical risk parity</a></li><li><a class="tocitem" href="../5_risk_parity_portfolios/">Example 5: Risk parity</a></li><li><a class="tocitem" href="../6_worst_case_mv_portfolios/">Example 6: Worst case Mean-Variance</a></li><li><a class="tocitem" href="../7_worst_case_statistics/">Example 7: Worst case statistics</a></li><li><a class="tocitem" href="../8_relaxed_risk_parity_variance_portfolios/">-</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Risk Measures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../RiskMeasures/RiskMeasures/">Types</a></li><li><a class="tocitem" href="../../RiskMeasures/RiskValue/">Risk value</a></li><li><a class="tocitem" href="../../RiskMeasures/RiskStatistics/">Risk statistics</a></li><li><a class="tocitem" href="../../RiskMeasures/MiscRiskMeasureFunctions/">Miscelaneous Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ParameterEstimation/PosdefFix/">Fixing non-positive definite matrices</a></li><li><a class="tocitem" href="../../ParameterEstimation/MatrixDenoising/">Matrix denoising</a></li><li><a class="tocitem" href="../../ParameterEstimation/DistanceMatrices/">Distance matrices</a></li><li><a class="tocitem" href="../../ParameterEstimation/Clustering/">Clustering</a></li><li><a class="tocitem" href="../../ParameterEstimation/CovCorKurtSkew/">Covariance, correlation, cokurtosis and coskewness</a></li><li><a class="tocitem" href="../../ParameterEstimation/MeanEstimators/">Expected returns</a></li><li><a class="tocitem" href="../../ParameterEstimation/WorstCase/">Worst case mean variance sets</a></li><li><a class="tocitem" href="../../ParameterEstimation/Regression/">Regression</a></li><li><a class="tocitem" href="../../ParameterEstimation/BlackLitterman/">Black Litterman models</a></li><li><a class="tocitem" href="../../ParameterEstimation/OWA/">Ordered Weight Arrays</a></li><li><a class="tocitem" href="../../ParameterEstimation/ParameterEstimationMisc/">Miscelaneous</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Constraints</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Constraints/WeightConstraints/">Weight constraints</a></li><li><a class="tocitem" href="../../Constraints/ViewsConstraints/">Views constraints</a></li><li><a class="tocitem" href="../../Constraints/NetworkConstraints/">Network constraints</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">(HC)Portfolio</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Portfolio/PortfolioTypes/">Types</a></li><li><a class="tocitem" href="../../Portfolio/PortfolioStatistics/">Statistics</a></li><li><a class="tocitem" href="../../Portfolio/PortfolioRisk/">Risk</a></li><li><a class="tocitem" href="../../Portfolio/PortfolioClustering/">Clustering</a></li><li><a class="tocitem" href="../../Portfolio/PortfolioNetwork/">Network</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Optimisation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Optimisation/OptimisationKinds/">Optimisation kinds</a></li><li><a class="tocitem" href="../../Optimisation/ObjectiveFunctions/">Objective functions</a></li><li><a class="tocitem" href="../../Optimisation/PortfolioClasses/">Portfolio classes</a></li><li><a class="tocitem" href="../../Optimisation/AssetAllocation/">Asset allocation</a></li><li><a class="tocitem" href="../../Optimisation/OptimisationConstraints/">Constraints</a></li><li><a class="tocitem" href="../../Optimisation/OptimisationSetup/">Setup functions</a></li><li><a class="tocitem" href="../../Optimisation/OptimisationRiskMeasures/">Risk measures</a></li><li><a class="tocitem" href="../../Optimisation/OptimisationGetZ/">Entropic and relativistic moments</a></li><li><a class="tocitem" href="../../Optimisation/OptimisationFinalisation/">Finalisation functions</a></li></ul></li><li><a class="tocitem" href="../../PlotsExtension/">Plots Extension</a></li><li><a class="tocitem" href="../../References/">References</a></li><li><a class="tocitem" href="../../Contents/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Example 1: Basic use</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 1: Basic use</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dcelisgarza/PortfolioOptimiser.jl/blob/main/examples/1_basic_use.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>The source files for all examples can be found in <a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl/tree/main/examples/">/examples</a>.</p><h1 id="Example-1:-Basic-use"><a class="docs-heading-anchor" href="#Example-1:-Basic-use">Example 1: Basic use</a><a id="Example-1:-Basic-use-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Basic-use" title="Permalink"></a></h1><p>This example should serve as a minimum working example for using <a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl/"><code>PortfolioOptimiser.jl</code></a>.</p><h2 id="1.1-Downloading-the-data"><a class="docs-heading-anchor" href="#1.1-Downloading-the-data">1.1 Downloading the data</a><a id="1.1-Downloading-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#1.1-Downloading-the-data" title="Permalink"></a></h2><p><a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl"><code>PortfolioOptimiser</code></a> does not ship with supporting packages that are not integral to its internal functionality. This means users are responsible for installing packages to load and download data, <a href="https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers"><code>JuMP</code></a>-compatible solvers, pretty printing, and the plotting functionality is an extension which requires <a href="https://github.com/JuliaPlots/GraphRecipes.jl"><code>GraphRecipes</code></a> and <a href="https://github.com/JuliaPlots/StatsPlots.jl"><code>StatsPlots</code></a>.</p><p>Which means we need a few extra packages to be installed. Uncomment the first two lines if these packages are not in your Julia environment.</p><pre><code class="language-julia hljs"># using Pkg
# Pkg.add.([&quot;StatsPlots&quot;, &quot;GraphRecipes&quot;, &quot;YFinance&quot;, &quot;Clarabel&quot;, &quot;HiGHS&quot;, &quot;PrettyTables&quot;])
using Clarabel, DataFrames, Dates, GraphRecipes, HiGHS, YFinance, PortfolioOptimiser,
      PrettyTables, Statistics, StatsBase, StatsPlots, TimeSeries

# These are helper functions for formatting tables.
fmt1 = (v, i, j) -&gt; begin
    if j == 1
        return v
    else
        return isa(v, Number) ? &quot;$(round(v*100, digits=3)) %&quot; : v
    end
end;

fmt2 = (v, i, j) -&gt; begin
    if j == 5
        return isa(v, Number) ? &quot;$(round(v*100, digits=3)) %&quot; : v
    else
        return v
    end
end;

fmt3 = (v, i, j) -&gt; begin
    if j ∈ (2, 6, 7)
        return isa(v, Number) ? &quot;$(round(v*100, digits=3)) %&quot; : v
    else
        return v
    end
end;</code></pre><p>We define our list of meme stonks and a generous date range. We will only be keeping the adjusted close price. In practice it doesn&#39;t really matter because we&#39;re using daily data.</p><pre><code class="language-julia hljs">function stock_price_to_time_array(x)
    coln = collect(keys(x))[3:end] # only get the keys that are not ticker or datetime
    m = hcat([x[k] for k ∈ coln]...) #Convert the dictionary into a matrix
    return TimeArray(x[&quot;timestamp&quot;], m, Symbol.(coln), x[&quot;ticker&quot;])
end

assets = [&quot;AAL&quot;, &quot;AAPL&quot;, &quot;AMC&quot;, &quot;BB&quot;, &quot;BBY&quot;, &quot;DELL&quot;, &quot;DG&quot;, &quot;DRS&quot;, &quot;GME&quot;, &quot;INTC&quot;, &quot;LULU&quot;,
          &quot;MARA&quot;, &quot;MCI&quot;, &quot;MSFT&quot;, &quot;NKLA&quot;, &quot;NVAX&quot;, &quot;NVDA&quot;, &quot;PARA&quot;, &quot;PLNT&quot;, &quot;SAVE&quot;, &quot;SBUX&quot;,
          &quot;SIRI&quot;, &quot;STX&quot;, &quot;TLRY&quot;, &quot;TSLA&quot;]
Date_0 = &quot;2019-01-01&quot;
Date_1 = &quot;2023-01-01&quot;
prices = get_prices.(assets; startdt = Date_0, enddt = Date_1)
prices = stock_price_to_time_array.(prices)
prices = hcat(prices...)
cidx = colnames(prices)[occursin.(r&quot;adj&quot;, string.(colnames(prices)))]
prices = prices[cidx]
TimeSeries.rename!(prices, Symbol.(assets))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1008×25 TimeSeries.TimeArray{Float64, 2, Dates.DateTime, Matrix{Float64}} 2019-01-02T14:30:00 to 2022-12-30T14:30:00
┌─────────────────────┬─────────┬─────────┬─────────┬──────┬─────────┬──────────
│<span class="sgr1">                     </span>│<span class="sgr1"> AAL     </span>│<span class="sgr1"> AAPL    </span>│<span class="sgr1"> AMC     </span>│<span class="sgr1"> BB   </span>│<span class="sgr1"> BBY     </span>│<span class="sgr1"> DELL   </span> ⋯
├─────────────────────┼─────────┼─────────┼─────────┼──────┼─────────┼──────────
│ 2019-01-02T14:30:00 │ 31.9632 │ 37.7086 │ 119.143 │ 7.11 │ 43.6631 │ 22.2917 ⋯
│ 2019-01-03T14:30:00 │ 29.5817 │ 33.9525 │ 120.715 │ 6.88 │  42.767 │ 21.3503 ⋯
│ 2019-01-04T14:30:00 │ 31.5302 │  35.402 │ 125.151 │ 7.23 │ 42.9707 │ 21.7713 ⋯
│ 2019-01-07T14:30:00 │ 32.4257 │ 35.3232 │ 130.512 │ 7.43 │ 45.4226 │ 21.9133 ⋯
│ 2019-01-08T14:30:00 │ 31.9041 │ 35.9965 │ 134.672 │ 7.41 │ 46.7586 │ 22.1735 ⋯
│ 2019-01-09T14:30:00 │ 32.8882 │ 36.6078 │ 128.941 │ 7.47 │ 47.1089 │ 22.2066 ⋯
│ 2019-01-10T14:30:00 │ 31.5302 │ 36.7248 │ 126.907 │ 7.52 │ 46.3268 │ 21.3787 ⋯
│ 2019-01-11T14:30:00 │  31.294 │ 36.3643 │  129.68 │ 7.57 │ 46.0336 │ 21.0381 ⋯
│          ⋮          │    ⋮    │    ⋮    │    ⋮    │  ⋮   │    ⋮    │    ⋮    ⋱
│ 2022-12-21T14:30:00 │   13.03 │  134.04 │    53.0 │ 3.75 │ 74.3655 │ 37.4134 ⋯
│ 2022-12-22T14:30:00 │   12.56 │ 130.854 │    49.1 │ 3.43 │ 74.2087 │ 37.4326 ⋯
│ 2022-12-23T14:30:00 │   12.71 │ 130.488 │    44.0 │  3.4 │ 75.0295 │ 37.4134 ⋯
│ 2022-12-27T14:30:00 │   12.53 │ 128.677 │    40.3 │ 3.29 │ 75.4999 │ 37.6908 ⋯
│ 2022-12-28T14:30:00 │   12.32 │ 124.728 │    38.4 │ 3.18 │ 73.9412 │ 37.0691 ⋯
│ 2022-12-29T14:30:00 │    12.7 │ 128.261 │    41.4 │ 3.26 │ 74.9281 │ 38.0829 ⋯
│ 2022-12-30T14:30:00 │   12.72 │ 128.578 │    40.7 │ 3.26 │ 73.9781 │ 38.4654 ⋯
└─────────────────────┴─────────┴─────────┴─────────┴──────┴─────────┴──────────
<span class="sgr36">                                                 19 columns and 993 rows omitted</span></code></pre><h2 id="1.2-Instantiating-an-instance-of-[Portfolio](@ref)."><a class="docs-heading-anchor" href="#1.2-Instantiating-an-instance-of-[Portfolio](@ref).">1.2 Instantiating an instance of <a href="../../Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio"><code>Portfolio</code></a>.</a><a id="1.2-Instantiating-an-instance-of-[Portfolio](@ref).-1"></a><a class="docs-heading-anchor-permalink" href="#1.2-Instantiating-an-instance-of-[Portfolio](@ref)." title="Permalink"></a></h2><p>Now that we have our data we can instantiate a portfolio. We also need to give it an optimiser for the continuous optimisation and an MIP optimiser for the discrete allocation of funds, we&#39;ll use <a href="https://github.com/oxfordcontrol/Clarabel.jl"><code>Clarabel.jl</code></a> and <a href="https://github.com/jump-dev/HiGHS.jl"><code>HiGHS.jl</code></a>.</p><pre><code class="language-julia hljs">portfolio = Portfolio(; prices = prices,
                      # Continuous optimiser.
                      solvers = Dict(:Clarabel =&gt; Dict(:solver =&gt; Clarabel.Optimizer,
                                                       :check_sol =&gt; (allow_local = true,
                                                                      allow_almost = true),
                                                       :params =&gt; Dict(&quot;verbose&quot; =&gt; false))),
                      # MIP optimiser for the discrete allocation.
                      alloc_solvers = Dict(:HiGHS =&gt; Dict(:solver =&gt; HiGHS.Optimizer,
                                                          :check_sol =&gt; (allow_local = true,
                                                                         allow_almost = true),
                                                          :params =&gt; Dict(&quot;log_to_console&quot; =&gt; false))))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Portfolio{Vector{String}, Vector{Dates.DateTime}, Matrix{Float64}, Vector{String}, Vector{Dates.Date}, Matrix{Float64}, DataFrames.DataFrame, Union{Nothing, PortfolioOptimiser.RegressionType}, Bool, Float64, Float64, Float64, Float64, Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}, Int64, Int64, Float64, Int64, Int64, Float64, Float64, PortfolioOptimiser.AbstractTR, PortfolioOptimiser.AbstractTR, PortfolioOptimiser.TrackingErr, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PortfolioOptimiser.AdjacencyConstraint, PortfolioOptimiser.AdjacencyConstraint, Vector{Float64}, Float64, Float64, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, Float64, Float64, Dict{Any, Any}, Dict{Any, Any}, Dict{Any, Any}, Dict{Symbol, Dict{Symbol, Any}}, Dict{Any, Any}, JuMP.Model, Vector{Float64}, Dict{Any, Any}, Dict{Any, Any}, Dict{Symbol, Dict{Symbol, Any}}, Dict{Any, Any}, JuMP.Model}([&quot;AAL&quot;, &quot;AAPL&quot;, &quot;AMC&quot;, &quot;BB&quot;, &quot;BBY&quot;, &quot;DELL&quot;, &quot;DG&quot;, &quot;DRS&quot;, &quot;GME&quot;, &quot;INTC&quot;  …  &quot;NVAX&quot;, &quot;NVDA&quot;, &quot;PARA&quot;, &quot;PLNT&quot;, &quot;SAVE&quot;, &quot;SBUX&quot;, &quot;SIRI&quot;, &quot;STX&quot;, &quot;TLRY&quot;, &quot;TSLA&quot;], [Dates.DateTime(&quot;2019-01-03T14:30:00&quot;), Dates.DateTime(&quot;2019-01-04T14:30:00&quot;), Dates.DateTime(&quot;2019-01-07T14:30:00&quot;), Dates.DateTime(&quot;2019-01-08T14:30:00&quot;), Dates.DateTime(&quot;2019-01-09T14:30:00&quot;), Dates.DateTime(&quot;2019-01-10T14:30:00&quot;), Dates.DateTime(&quot;2019-01-11T14:30:00&quot;), Dates.DateTime(&quot;2019-01-14T14:30:00&quot;), Dates.DateTime(&quot;2019-01-15T14:30:00&quot;), Dates.DateTime(&quot;2019-01-16T14:30:00&quot;)  …  Dates.DateTime(&quot;2022-12-16T14:30:00&quot;), Dates.DateTime(&quot;2022-12-19T14:30:00&quot;), Dates.DateTime(&quot;2022-12-20T14:30:00&quot;), Dates.DateTime(&quot;2022-12-21T14:30:00&quot;), Dates.DateTime(&quot;2022-12-22T14:30:00&quot;), Dates.DateTime(&quot;2022-12-23T14:30:00&quot;), Dates.DateTime(&quot;2022-12-27T14:30:00&quot;), Dates.DateTime(&quot;2022-12-28T14:30:00&quot;), Dates.DateTime(&quot;2022-12-29T14:30:00&quot;), Dates.DateTime(&quot;2022-12-30T14:30:00&quot;)], [-0.0745073711209265 -0.09960756019954525 … -0.006528513914982477 -0.03147171266518322; 0.06586836347092641 0.04268939539488685 … -0.0007143293108264721 0.05769739091207081; … ; 0.030844165897224662 0.02832412080988005 … 0.03875974651483776 0.0808269069678895; 0.0015748392176419634 0.002468912262902751 … 0.003731339632150324 0.011164017515666588], String[], Dates.Date[], Matrix{Float64}(undef, 0, 0), <span class="sgr1">0×0 DataFrame</span>, nothing, false, 1.0, 0.2, 1.0, 0.2, 0.0, 0.0, 0, 0, 100000.0, 0, 2, 0.0, 0.0, NoTR(), NoTR(), NoTracking(), Float64[], Matrix{Float64}(undef, 0, 0), Float64[], Float64[], Float64[], NoAdj(), NoAdj(), Float64[], 0.0, Inf, Float64[], Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), sparse(Int64[], Int64[], Float64[], 0, 0), sparse(Int64[], Int64[], Float64[], 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Float64[], Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Float64[], Matrix{Float64}(undef, 0, 0), Float64[], Matrix{Float64}(undef, 0, 0), Float64[], Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Matrix{Float64}(undef, 0, 0), Float64[], Inf, Inf, Dict{Any, Any}(), Dict{Any, Any}(), Dict{Any, Any}(), Dict{Symbol, Dict{Symbol, Any}}(:Clarabel =&gt; Dict(:solver =&gt; Clarabel.MOIwrapper.Optimizer, :params =&gt; Dict{String, Bool}(&quot;verbose&quot; =&gt; 0), :check_sol =&gt; (allow_local = true, allow_almost = true))), Dict{Any, Any}(), A JuMP Model
├ solver: none
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none, [12.720000267028809, 128.57786560058594, 40.70000076293945, 3.259999990463257, 73.97811126708984, 38.46544647216797, 238.62326049804688, 12.779999732971191, 18.459999084472656, 25.48586082458496  …  10.279999732971191, 14.604384422302246, 16.283218383789062, 78.80000305175781, 17.627973556518555, 95.27733612060547, 56.31087112426758, 49.40781021118164, 2.690000057220459, 123.18000030517578], Dict{Any, Any}(), Dict{Any, Any}(), Dict{Symbol, Dict{Symbol, Any}}(:HiGHS =&gt; Dict(:solver =&gt; HiGHS.Optimizer, :params =&gt; Dict{String, Bool}(&quot;log_to_console&quot; =&gt; 0), :check_sol =&gt; (allow_local = true, allow_almost = true))), Dict{Any, Any}(), A JuMP Model
├ solver: none
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none)</code></pre><p>The constructor automatically computes the returns, sets the assets, and timestamps if you give it the price data. Users can also provide these directly, the timestamps aren&#39;t needed anywhere but plotting so they are not required. This structure contains a lot of data. But we will only show the basics for now.</p><h2 id="1.3-Computing-statistics"><a class="docs-heading-anchor" href="#1.3-Computing-statistics">1.3 Computing statistics</a><a id="1.3-Computing-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#1.3-Computing-statistics" title="Permalink"></a></h2><p>There are myriad of statistics and methods for computing said statistics. Users can define their own methods with Julia&#39;s multiple dispatch and <a href="https://github.com/JuliaStats/StatsAPI.jl"><code>StatsAPI.jl</code></a> interface.</p><p>We will do a simple Mean-Variance optimisation, using the simplest methods for computing the expected returns vector and covariance matrices. Later tutorials will go more in-depth.</p><pre><code class="language-julia hljs"># T is the number of observations, N the number of assets.
T, N = size(portfolio.returns)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1007, 25)</code></pre><p>Simple mean, it also accepts weights for computing weighted means. This will compute the weighted mean for lambda = 1/T.</p><pre><code class="language-julia hljs">mu_type = MuSimple(;)
# mu_type = MuSimple(; w = eweights(1:T, 1/T, scale=true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MuSimple(nothing)</code></pre><p><a href="../../ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor"><code>PortCovCor</code></a> is quite special because it accepts covariance estimators, methods for fixing non positive definite matrices, denoising methods, and a graph-based approach for computing the covariance by identifying related asset groups.</p><p>The estimators are all different, and PortfolioOptimiser offers a few of them. They all have their own parameters. They all subtype <a href="https://juliastats.org/StatsBase.jl/stable/cov/#StatsBase.CovarianceEstimator"><code>StatBase.CovarianceEstimator</code></a>, meaning <a href="../../ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor"><code>PortCovCor</code></a> works with external estimators such as those in <a href="https://github.com/mateuszbaran/CovarianceEstimation.jl"><code>CovarianceEstimation.jl</code></a>, as well as user-defined methods.</p><p>This defaults to the full sample covariance estimator. We can provide the estimator with some weights to compute a weighted covariance too. We&#39;ll leave other estimators for future tutorials. For the time being, feel free to play around with the weights. There is some nesting involved, but that is due to the fact that we are composing various estimators to get our desired outcome.</p><pre><code class="language-julia hljs">cov_type = PortCovCor(;)
# cov_type = PortCovCor(;
#                       ce = CovFull(; ce = StatsBase.SimpleCovariance(; corrected = false),
#                                    w = eweights(1:T, 1 / T; scale = true)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PortCovCor(CovFull(false, StatsBase.SimpleCovariance(true), nothing), PosdefNearest(NearestCorrelationMatrix.Newton{Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}}(1.0e-12, 0.01, 0.0001, 200, 20, (), Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}())), NoDenoise(), NoLoGo())</code></pre><p>We can then call <a href="../../Portfolio/PortfolioStatistics/#PortfolioOptimiser.asset_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}"><code>asset_statistics!</code></a> which computes all the asset statistics. It will also compute other statistics by default but we can set some flags to stop this from happening.</p><pre><code class="language-julia hljs">asset_statistics!(portfolio; mu_type = mu_type, cov_type = cov_type, set_kurt = false,
                  set_skurt = false, set_skew = false, set_sskew = false);</code></pre><h2 id="1.4-Optimising-the-portfolio"><a class="docs-heading-anchor" href="#1.4-Optimising-the-portfolio">1.4 Optimising the portfolio</a><a id="1.4-Optimising-the-portfolio-1"></a><a class="docs-heading-anchor-permalink" href="#1.4-Optimising-the-portfolio" title="Permalink"></a></h2><p>We will only look at a vanilla optimisation in this tutorial.</p><p>There are quite a few risk measures, some require statistics we have not computed, others don&#39;t require any precomputed statistics at all. You can see the risk measure has a few internal parameters, they all do. We&#39;ll only show the classic mean variance risk measure, but you can uncomment each of the next few lines in turn and try some of the others.</p><pre><code class="language-julia hljs">rm = SD() # Variance
# rm = MAD() # Mean absolute deviation
# rm = SSD() # Semi variance
# rm = CVaR() # Critical Value at Risk
# rm = CDaR() # Critical Drawdown at Risk</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SD(RMSettings{Float64, Float64}(true, 1.0, Inf), SOCSD(), nothing)</code></pre><p>There are four objective functions we can use they all serve their purpose but for the tutorial, we&#39;ll be minimising the risk. Try the other objective functions and change the parameters to see their effects.</p><pre><code class="language-julia hljs">obj = MinRisk()
# obj = MaxRet() # Only useful for maximising the return while constraining the risk to be under a given value.
# obj = Utility(; l = 2) # Maximises the utility = return - l * risk
# obj = Sharpe(; rf = 3.5/100/254) # Maximises the sharpe ratio = (mu - rf)/risk, where mu is the expected return.

w1 = optimise!(portfolio; rm = rm, obj = obj)
pretty_table(w1; formatters = fmt1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌─────────┬──────────┐
│<span class="sgr1"> tickers </span>│<span class="sgr1">  weights </span>│
│<span class="sgr90">  String </span>│<span class="sgr90">  Float64 </span>│
├─────────┼──────────┤
│     AAL │    0.0 % │
│    AAPL │  0.011 % │
│     AMC │    0.0 % │
│      BB │  0.002 % │
│     BBY │    0.0 % │
│    DELL │    0.0 % │
│      DG │  38.92 % │
│     DRS │  2.369 % │
│     GME │    0.0 % │
│    INTC │    0.0 % │
│    LULU │    0.0 % │
│    MARA │    0.0 % │
│     MCI │ 30.632 % │
│    MSFT │  0.501 % │
│    NKLA │  0.843 % │
│    NVAX │  0.001 % │
│    NVDA │    0.0 % │
│    PARA │    0.0 % │
│    PLNT │    0.0 % │
│    SAVE │    0.0 % │
│    SBUX │  8.278 % │
│    SIRI │ 14.767 % │
│     STX │  3.674 % │
│    TLRY │    0.0 % │
│    TSLA │    0.0 % │
└─────────┴──────────┘</code></pre><p>We now have the portfolio for these assets and this period of time that minimises the variance. <a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl/"><code>PortfolioOptimiser</code></a> also lets you constrain the optimisation such that you have a minimum required return. However this will be explored in a later tutorial.</p><h2 id="1.5-Asset-allocation"><a class="docs-heading-anchor" href="#1.5-Asset-allocation">1.5 Asset allocation</a><a id="1.5-Asset-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#1.5-Asset-allocation" title="Permalink"></a></h2><p>For now we want to know how many assets we need to buy, this only gives us the mathematically optimal weights. We have a function for this. Given that we used the price data directly, <a href="../../Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio"><code>Portfolio</code></a> will take the last entry in the prices and use that as the current price for each asset. You can of course change this, or directly provide them as a vector to the <a href="../../Optimisation/AssetAllocation/#PortfolioOptimiser.allocate!-Tuple{PortfolioOptimiser.AbstractPortfolio}"><code>allocate!</code></a> function, though the order of the prices must be the same as the original asset order.</p><p>For this example, lets say we have 1000 dollars. Change this value to see how the allocation changes. The larger it becomes, the closer they get to the optimal value.</p><pre><code class="language-julia hljs">investment = 1000;</code></pre><p>There are two methods we can use for allocating. The one we have chosen uses mixed-integer linear programming to discretly allocate assets. This however can only allocate discrete quantities. The second method is a greedy algorithm that allocates based on which asset has the highest difference between its mathematical optimum and current weight, it only tries to allocate based on whether you can afford it. However, it can allocate fractional shares up to an integer multiple of the value in rounding (defaults to 1). Given it is a greedy algorithm, it is not guaranteed to give an optimum solution, but will always find a solution, unlike the LP() method which can fail. Also the higher the investment, the more accurate it gets.</p><pre><code class="language-julia hljs">method = LP()
# method = Greedy(; rounding=0.5)

w2 = allocate!(portfolio; investment = investment)
pretty_table(w2; formatters = fmt2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌─────────┬────────┬─────────┬─────────┬──────────┐
│<span class="sgr1"> tickers </span>│<span class="sgr1"> shares </span>│<span class="sgr1">   price </span>│<span class="sgr1">    cost </span>│<span class="sgr1">  weights </span>│
│<span class="sgr90">  String </span>│<span class="sgr90">  Int64 </span>│<span class="sgr90"> Float64 </span>│<span class="sgr90"> Float64 </span>│<span class="sgr90">  Float64 </span>│
├─────────┼────────┼─────────┼─────────┼──────────┤
│     AAL │      0 │   12.72 │     0.0 │    0.0 % │
│    AAPL │      0 │ 128.578 │     0.0 │    0.0 % │
│     AMC │      0 │    40.7 │     0.0 │    0.0 % │
│      BB │      0 │    3.26 │     0.0 │    0.0 % │
│     BBY │      0 │ 73.9781 │     0.0 │    0.0 % │
│    DELL │      0 │ 38.4654 │     0.0 │    0.0 % │
│      DG │      2 │ 238.623 │ 477.247 │ 47.725 % │
│     DRS │      1 │   12.78 │   12.78 │  1.278 % │
│     GME │      0 │   18.46 │     0.0 │    0.0 % │
│    INTC │      0 │ 25.4859 │     0.0 │    0.0 % │
│    LULU │      0 │  320.38 │     0.0 │    0.0 % │
│    MARA │      0 │    3.42 │     0.0 │    0.0 % │
│     MCI │     25 │ 11.9609 │ 299.023 │ 29.902 % │
│    MSFT │      0 │  236.42 │     0.0 │    0.0 % │
│    NKLA │      0 │    64.8 │     0.0 │    0.0 % │
│    NVAX │      0 │   10.28 │     0.0 │    0.0 % │
│    NVDA │      0 │ 14.6044 │     0.0 │    0.0 % │
│    PARA │      0 │ 16.2832 │     0.0 │    0.0 % │
│    PLNT │      0 │    78.8 │     0.0 │    0.0 % │
│    SAVE │      0 │  17.628 │     0.0 │    0.0 % │
│    SBUX │      1 │ 95.2773 │ 95.2773 │  9.528 % │
│    SIRI │      2 │ 56.3109 │ 112.622 │ 11.262 % │
│     STX │      0 │ 49.4078 │     0.0 │    0.0 % │
│    TLRY │      1 │    2.69 │    2.69 │  0.269 % │
│    TSLA │      0 │  123.18 │     0.0 │    0.0 % │
└─────────┴────────┴─────────┴─────────┴──────────┘</code></pre><h2 id="1.6-Plotting-the-portfolio"><a class="docs-heading-anchor" href="#1.6-Plotting-the-portfolio">1.6 Plotting the portfolio</a><a id="1.6-Plotting-the-portfolio-1"></a><a class="docs-heading-anchor-permalink" href="#1.6-Plotting-the-portfolio" title="Permalink"></a></h2><p>This section is the one most bound to change as the plotting functions are still somewhat preliminary. There are a variety of plots but we&#39;ll only show the most basic ones. By default, the plots will take the mathematically optimal portfolio. Lets see what it looks like.</p><p>Plot the portfolio returns.</p><pre><code class="language-julia hljs">plt = plot_returns(portfolio)</code></pre><img src="b43639fe.svg" alt="Example block output"/><p>Plot the portfolio returns per asset.</p><pre><code class="language-julia hljs">plt = plot_returns(portfolio; per_asset = true)</code></pre><img src="7045af06.svg" alt="Example block output"/><p>Plot portfolio composition.</p><pre><code class="language-julia hljs">plt = plot_bar(portfolio)</code></pre><img src="5a51209f.svg" alt="Example block output"/><p>Plot the returns histogram.</p><pre><code class="language-julia hljs">plt = plot_hist(portfolio)</code></pre><img src="8c2bb3f4.svg" alt="Example block output"/><p>Plot the portfolio range of returns.</p><pre><code class="language-julia hljs">plt = plot_range(portfolio)</code></pre><img src="134339a8.svg" alt="Example block output"/><p>Plot portfolio drawdown.</p><pre><code class="language-julia hljs">plt = plot_drawdown(portfolio)</code></pre><img src="7c542d24.svg" alt="Example block output"/><p>This is, however not our actual portfolio, it is the optimal one. To plot the allocated portfolio we need to know the key it is stored under and pass that on to the plotting functions along with a flag. The key is the symbol composed of the allocation method, in this case LP() and the portfolio type, which is something we have not discussed, but defaults to Trad(), as a Symbol.</p><pre><code class="language-julia hljs"># Side by side optimal portfolio vs allocated portfolio.
pretty_table(hcat(portfolio.optimal[:Trad],
                  DataFrames.rename!(portfolio.alloc_optimal[:LP_Trad][!, 2:end],
                                     Dict(:weights =&gt; :alloc_weights)),
                  DataFrame(;
                            weight_diff = portfolio.optimal[:Trad].weights -
                                          portfolio.alloc_optimal[:LP_Trad].weights));
             formatters = fmt3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌─────────┬──────────┬────────┬─────────┬─────────┬───────────────┬─────────────┐
│<span class="sgr1"> tickers </span>│<span class="sgr1">  weights </span>│<span class="sgr1"> shares </span>│<span class="sgr1">   price </span>│<span class="sgr1">    cost </span>│<span class="sgr1"> alloc_weights </span>│<span class="sgr1"> weight_diff </span>│
│<span class="sgr90">  String </span>│<span class="sgr90">  Float64 </span>│<span class="sgr90">  Int64 </span>│<span class="sgr90"> Float64 </span>│<span class="sgr90"> Float64 </span>│<span class="sgr90">       Float64 </span>│<span class="sgr90">     Float64 </span>│
├─────────┼──────────┼────────┼─────────┼─────────┼───────────────┼─────────────┤
│     AAL │    0.0 % │      0 │   12.72 │     0.0 │         0.0 % │       0.0 % │
│    AAPL │  0.011 % │      0 │ 128.578 │     0.0 │         0.0 % │     0.011 % │
│     AMC │    0.0 % │      0 │    40.7 │     0.0 │         0.0 % │       0.0 % │
│      BB │  0.002 % │      0 │    3.26 │     0.0 │         0.0 % │     0.002 % │
│     BBY │    0.0 % │      0 │ 73.9781 │     0.0 │         0.0 % │       0.0 % │
│    DELL │    0.0 % │      0 │ 38.4654 │     0.0 │         0.0 % │       0.0 % │
│      DG │  38.92 % │      2 │ 238.623 │ 477.247 │      47.725 % │    -8.804 % │
│     DRS │  2.369 % │      1 │   12.78 │   12.78 │       1.278 % │     1.091 % │
│     GME │    0.0 % │      0 │   18.46 │     0.0 │         0.0 % │       0.0 % │
│    INTC │    0.0 % │      0 │ 25.4859 │     0.0 │         0.0 % │       0.0 % │
│    LULU │    0.0 % │      0 │  320.38 │     0.0 │         0.0 % │       0.0 % │
│    MARA │    0.0 % │      0 │    3.42 │     0.0 │         0.0 % │       0.0 % │
│     MCI │ 30.632 % │     25 │ 11.9609 │ 299.023 │      29.902 % │     0.729 % │
│    MSFT │  0.501 % │      0 │  236.42 │     0.0 │         0.0 % │     0.501 % │
│    NKLA │  0.843 % │      0 │    64.8 │     0.0 │         0.0 % │     0.843 % │
│    NVAX │  0.001 % │      0 │   10.28 │     0.0 │         0.0 % │     0.001 % │
│    NVDA │    0.0 % │      0 │ 14.6044 │     0.0 │         0.0 % │       0.0 % │
│    PARA │    0.0 % │      0 │ 16.2832 │     0.0 │         0.0 % │       0.0 % │
│    PLNT │    0.0 % │      0 │    78.8 │     0.0 │         0.0 % │       0.0 % │
│    SAVE │    0.0 % │      0 │  17.628 │     0.0 │         0.0 % │       0.0 % │
│    SBUX │  8.278 % │      1 │ 95.2773 │ 95.2773 │       9.528 % │    -1.249 % │
│    SIRI │ 14.767 % │      2 │ 56.3109 │ 112.622 │      11.262 % │     3.505 % │
│     STX │  3.674 % │      0 │ 49.4078 │     0.0 │         0.0 % │     3.674 % │
│    TLRY │    0.0 % │      1 │    2.69 │    2.69 │       0.269 % │    -0.269 % │
│    TSLA │    0.0 % │      0 │  123.18 │     0.0 │         0.0 % │       0.0 % │
└─────────┴──────────┴────────┴─────────┴─────────┴───────────────┴─────────────┘</code></pre><p>Plot the portfolio returns.</p><pre><code class="language-julia hljs">plt = plot_returns(portfolio; type = :LP_Trad, allocated = true)</code></pre><img src="cbbe85e2.svg" alt="Example block output"/><p>Plot the portfolio returns per asset.</p><pre><code class="language-julia hljs">plt = plot_returns(portfolio; type = :LP_Trad, allocated = true, per_asset = true)</code></pre><img src="354df6aa.svg" alt="Example block output"/><p>Plot portfolio composition.</p><pre><code class="language-julia hljs">plt = plot_bar(portfolio; type = :LP_Trad, allocated = true)</code></pre><img src="9679259d.svg" alt="Example block output"/><p>Plot the returns histogram.</p><pre><code class="language-julia hljs">plt = plot_hist(portfolio; type = :LP_Trad, allocated = true)</code></pre><img src="7311635f.svg" alt="Example block output"/><p>Plot the portfolio range of returns.</p><pre><code class="language-julia hljs">plt = plot_range(portfolio; type = :LP_Trad, allocated = true)</code></pre><img src="dc370853.svg" alt="Example block output"/><p>Plot portfolio drawdown.</p><pre><code class="language-julia hljs">plt = plot_drawdown(portfolio; type = :LP_Trad, allocated = true)</code></pre><img src="20ec927c.svg" alt="Example block output"/><h2 id="1.7-Efficient-frontier"><a class="docs-heading-anchor" href="#1.7-Efficient-frontier">1.7 Efficient frontier</a><a id="1.7-Efficient-frontier-1"></a><a class="docs-heading-anchor-permalink" href="#1.7-Efficient-frontier" title="Permalink"></a></h2><p>We have seen how you can optimise a single portfolio, but in reality there are an infinite number of optimal portfolios which exist along what is called the efficient frontier. We can compute and view this frontier, as well as viewing its composition very easily using <a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl"><code>PortfolioOptimiser</code></a>.</p><p>The idea is to first compute the minimum risk and maximum return portfolios. From these we generate a range of risks and returns. We then loop over all these values. At each step we maximise the expected return whilst constraining the risk to be lower than or equal to current risk value in the range of risks. If an optimisation fails, we instead minimise the risk whilst constraining the expected return to be bigger than or equal to the corresponding value in the range of expected returns. We save the results for each step. We can then use these to plot the efficient frontier and its composition at each point.</p><pre><code class="language-julia hljs"># Compute 50 points in the efficient frontier.
points = 50
frontier = efficient_frontier!(portfolio; rm = rm, points = points)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Any} with 3 entries:
  :sharpe  =&gt; true
  :weights =&gt; <span class="sgr1">25×52 DataFrame</span>…
  :risks   =&gt; [0.0124128, 0.0142144, 0.016016, 0.0178176, 0.0196192, 0.0214208,…</code></pre><p>Plot the efficient frontier.</p><pre><code class="language-julia hljs">plt = plot_frontier(portfolio; rm = rm)</code></pre><img src="dc301c62.svg" alt="Example block output"/><p>Plot frontier asset composition.</p><pre><code class="language-julia hljs">plt = plot_frontier_area(portfolio; rm = rm)</code></pre><img src="28b3d15f.svg" alt="Example block output"/><p>The efficient frontier is outputted by <a href="../../Optimisation/OptimisationKinds/#PortfolioOptimiser.efficient_frontier!-Tuple{Portfolio}"><code>efficient_frontier!</code></a>, but also saves it in the <code>portfolio</code> instance. It is a dictionary whose keys are the symbols of the risk measure used to compute the efficient frontier. We&#39;ve only computed the efficient frontier for the SD, so we can access the efficient frontier data by indexing into the <code>:SD</code> key. The documentation for <a href="../../Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio"><code>Portfolio</code></a> contains more details.</p><p>As the last demo we will display a heatmap of the portfolio composition of the efficient frontier in <code>SD()</code>.</p><pre><code class="language-julia hljs"># Check if the sharpe ratio is found in the frontier.
if portfolio.frontier[:SD][:sharpe]
    risks = portfolio.frontier[:SD][:risks]
    weights = DataFrames.rename(portfolio.frontier[:SD][:weights],
                                Symbol.(1:length(risks)) .=&gt;
                                    Symbol.(round.(risks * 100, digits = 2)))
    idx = sortperm(portfolio.frontier[:SD][:risks])
    weights = weights[!, [1; idx .+ 1]]
    risks = risks[idx]
else
    weights = Matrix(portfolio.frontier[:SD][:weights])
    risks = portfolio.frontier[:SD][:risks]
end

plot(Matrix(weights[!, 2:end]); st = :heatmap, clim = (0, 1),
             yticks = (1:N, portfolio.assets), yflip = true,
             xticks = (1:3:length(risks), round.(risks * sqrt(252), digits = 2)[1:3:end]),
             xrotation = 60, xtickfontsize = 10, xlabel = &quot;Expected Anualised Risk (SD)&quot;,
             color = cgrad(:Spectral), size = (600, 600), colorbar_title = &quot;\nAsset Weight&quot;)</code></pre><img src="8fe0111f.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../0_not_financial_advice/">« Example 0: Not financial advice</a><a class="docs-footer-nextpage" href="../2_asset_statistics/">Example 2: Asset statistics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 10 November 2024 14:14">Sunday 10 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
