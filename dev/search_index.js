var documenterSearchIndex = {"docs":
[{"location":"ParameterEstimation/ParameterEstimationMisc/#Miscelaneous","page":"Miscelaneous","title":"Miscelaneous","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Public","page":"Miscelaneous","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/ParameterEstimationMisc/#Private","page":"Miscelaneous","title":"Private","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#Network-constraints","page":"Network constraints","title":"Network constraints","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#Public","page":"Network constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BetweennessCentrality","page":"Network constraints","title":"PortfolioOptimiser.BetweennessCentrality","text":"@kwdef mutable struct BetweennessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.BoruvkaTree","page":"Network constraints","title":"PortfolioOptimiser.BoruvkaTree","text":"@kwdef mutable struct BoruvkaTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.ClosenessCentrality","page":"Network constraints","title":"PortfolioOptimiser.ClosenessCentrality","text":"@kwdef mutable struct ClosenessCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.DegreeCentrality","page":"Network constraints","title":"PortfolioOptimiser.DegreeCentrality","text":"@kwdef mutable struct DegreeCentrality{T1 <: Integer} <: CentralityType\n    type::T1 = 0\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.EigenvectorCentrality","page":"Network constraints","title":"PortfolioOptimiser.EigenvectorCentrality","text":"struct EigenvectorCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KatzCentrality","page":"Network constraints","title":"PortfolioOptimiser.KatzCentrality","text":"@kwdef mutable struct KatzCentrality{T1 <: Real} <: CentralityType\n    alpha::T1 = 0.3\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.KruskalTree","page":"Network constraints","title":"PortfolioOptimiser.KruskalTree","text":"@kwdef mutable struct KruskalTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.MST","page":"Network constraints","title":"PortfolioOptimiser.MST","text":"@kwdef mutable struct MST{T1 <: Integer} <: NetworkType\n    tree::TreeType = KruskalTree()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.Pagerank","page":"Network constraints","title":"PortfolioOptimiser.Pagerank","text":"@kwdef mutable struct Pagerank{T1 <: Real, T2 <: Integer, T3 <: Real} <: CentralityType\n    alpha::T1 = 0.85\n    n::T2 = 100\n    epsilon::T3 = 1e-6\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.PrimTree","page":"Network constraints","title":"PortfolioOptimiser.PrimTree","text":"@kwdef mutable struct PrimTree <: TreeType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.RadialityCentrality","page":"Network constraints","title":"PortfolioOptimiser.RadialityCentrality","text":"struct RadialityCentrality <: CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.StressCentrality","page":"Network constraints","title":"PortfolioOptimiser.StressCentrality","text":"@kwdef mutable struct StressCentrality <: CentralityType\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TMFG","page":"Network constraints","title":"PortfolioOptimiser.TMFG","text":"@kwdef mutable struct TMFG{T1 <: Integer} <: NetworkType\n    similarity::DBHTSimilarity = DBHTMaxDist()\n    steps::T1 = 1\n    centrality::CentralityType = DegreeCentrality()\nend\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#Private","page":"Network constraints","title":"Private","text":"","category":"section"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.CentralityType","page":"Network constraints","title":"PortfolioOptimiser.CentralityType","text":"abstract type CentralityType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.NetworkType","page":"Network constraints","title":"PortfolioOptimiser.NetworkType","text":"abstract type NetworkType end\n\n\n\n\n\n","category":"type"},{"location":"Constraints/NetworkConstraints/#PortfolioOptimiser.TreeType","page":"Network constraints","title":"PortfolioOptimiser.TreeType","text":"abstract type TreeType end\n\n\n\n\n\n","category":"type"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#Example-5:-Black-Litterman-Mean-Risk-Optimisation","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"The Black Litterman model only adjusts the vector of expected returns and covariance matrix. Therefore, it will only affect optimisations which make use of either of these.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#1.-Download-data.","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"1. Download data.","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#2.-Estimating-Black-Litterman-Portfolios","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"2. Estimating Black Litterman Portfolios","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#2.1.-Reference-portfolio","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"2.1. Reference portfolio","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"For API details and options available see: Portfolio, PortOptSolver, PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, BLType, asset_statistics!, black_litterman, RiskMeasure, PortfolioOptimiser.ObjectiveFunction, PortfolioOptimiser.OptimType.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices,\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n\n# Compute relevant statistics.\n# Expected returns and covariance estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\n\n# Only compute `mu` and `cov`.\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\n# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj)\n\n# Optimise portfolio.\nw1 = optimise!(port, type)\npretty_table(w1; formatters = fmt2)\nplot_bar(port)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#2.2.-Asset-sets-and-asset-views","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"2.2. Asset sets and asset views","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"The function asset_views takes in two dataframes, one defining the asset views, and another defining the asset sets.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"asset_sets = DataFrame(;\n                       Asset = [\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\",\n                                \"COST\", \"CSCO\", \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\",\n                                \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\", \"NFLX\", \"NVDA\", \"ORLY\",\n                                \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\", \"VRTX\"],\n                       Sector = [\"Technology\", \"Technology\", \"Technology\", \"Health Care\",\n                                 \"Consumer Discretionary\", \"Consumer Discretionary\",\n                                 \"Telecommunications\", \"Consumer Discretionary\",\n                                 \"Telecommunications\", \"Health Care\", \"Technology\",\n                                 \"Technology\", \"Industrials\", \"Health Care\", \"Industrials\",\n                                 \"Consumer Discretionary\", \"Technology\", \"Health Care\",\n                                 \"Technology\", \"Consumer Discretionary\", \"Technology\",\n                                 \"Consumer Discretionary\", \"Technology\", \"Technology\",\n                                 \"Consumer Discretionary\", \"Telecommunications\",\n                                 \"Telecommunications\", \"Consumer Discretionary\",\n                                 \"Technology\", \"Health Care\"],\n                       Industry = [\"Computer Manufacturing\", \"Semiconductors\",\n                                   \"EDP Services\",\n                                   \"Biotechnology: Biological Products (No Diagnostic Substances)\",\n                                   \"Catalog/Specialty Distribution\",\n                                   \"Transportation Services\",\n                                   \"Cable & Other Pay Television Services\",\n                                   \"Department/Specialty Retail Stores\",\n                                   \"Computer Communications Equipment\",\n                                   \"Biotechnology: Biological Products (No Diagnostic Substances)\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Aerospace\", \"Industrial Specialties\", \"Major Chemicals\",\n                                   \"Hotels/Resorts\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Biotechnology: Pharmaceutical Preparations\",\n                                   \"Computer Software: Prepackaged Software\",\n                                   \"Consumer Electronics/Video Chains\", \"Semiconductors\",\n                                   \"Auto & Home Supply Stores\",\n                                   \"Computer peripheral equipment\",\n                                   \"Radio And Television Broadcasting And Communications Equipment\",\n                                   \"Restaurants\", \"Telecommunications Equipment\",\n                                   \"Telecommunications Equipment\", \"Auto Manufacturing\",\n                                   \"Semiconductors\",\n                                   \"Biotechnology: Pharmaceutical Preparations\"])\npretty_table(asset_sets)\n\nviews = DataFrame(\"Enabled\" => [true, true, true, true, true, true, true, true, true, true,\n                                true, true],\n                  \"Type\" => [\"Asset\", \"Asset\", \"Asset\", \"Asset\", \"Asset\", \"Asset\", \"Subset\",\n                             \"Subset\", \"Subset\", \"Subset\", \"Subset\", \"Subset\"],\n                  \"Set\" => [\"\", \"\", \"\", \"\", \"\", \"\", \"Sector\", \"Sector\", \"Industry\",\n                            \"Industry\", \"Sector\", \"Industry\"],\n                  \"Position\" => [\"AAPL\", \"AMZN\", \"COST\", \"T\", \"SBUX\", \"ADI\", \"Technology\",\n                                 \"Consumer Discretionary\", \"Semiconductors\",\n                                 \"Computer Software: Programming Data Processing\",\n                                 \"Industrials\",\n                                 \"Biotechnology: Biological Products (No Diagnostic Substances)\"],\n                  \"Sign\" => [\">=\", \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\", \"<=\",\n                             \">=\", \"<=\"],\n                  \"Return\" => [-0.07 / 252, 0.2 / 252, 0.05 / 252, -0.03 / 252, 0.11 / 252,\n                               -0.11 / 252, -0.02 / 252, 0.01 / 252, 0.08 / 252,\n                               -0.06 / 252, 0.13 / 252, -0.04 / 252],\n                  \"Relative_Type\" => [\"\", \"\", \"Asset\", \"Asset\", \"Subset\", \"Subset\", \"\", \"\",\n                                      \"Asset\", \"Asset\", \"Subset\", \"Subset\"],\n                  \"Relative_Set\" => [\"\", \"\", \"\", \"\", \"Sector\", \"Industry\", \"\", \"\", \"\", \"\",\n                                     \"Sector\", \"Industry\"],\n                  \"Relative_Position\" => [\"\", \"\", \"LIN\", \"TSLA\", \"Technology\",\n                                          \"Computer Software: Programming Data Processing\",\n                                          \"\", \"\", \"VRTX\", \"AAPL\", \"Health Care\",\n                                          \"Telecommunications Equipment\"])\npretty_table(views)\n\nP, Q = asset_views(views, asset_sets)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#2.3.-Computing-the-Black-Litterman-statistics.","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"2.3. Computing the Black-Litterman statistics.","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"bl_type = BLType()\nblack_litterman_statistics!(port; P = P, Q = Q, w = w1.weights, mu_type = mu_type,\n                            cov_type = cov_type)\n\n# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\nclass = BL()\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj, class = class)\n\n# Optimise Black Litterman portfolio.\nw2 = optimise!(port, type)\npretty_table(w2; formatters = fmt2)\nplot_bar(port)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/#3.-Efficient-Frontier","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"3. Efficient Frontier","text":"","category":"section"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"It's possible to compute the efficient frontier of the Black Litterman model. It will be different to the vanilla one because the expected returns and covariance matrix have been adjusted.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"points = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt2)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"Plot frontier.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"plot_frontier(port; rm = rm)","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"Plot frontier area.","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"plot_frontier_area(port; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"","category":"page"},{"location":"examples/5_Black_Litterman_Mean_Risk_Optimisation/","page":"Example 5: Black Litterman Mean Risk Optimisation","title":"Example 5: Black Litterman Mean Risk Optimisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-3/#Downside","page":"Downside","title":"Downside","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/","page":"Downside","title":"Downside","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-3/#Worst-Realisation","page":"Downside","title":"Worst Realisation","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.WR","page":"Downside","title":"PortfolioOptimiser.WR","text":"struct WR <: RiskMeasure\n\nMeasures and computes the portfolio Worst Realization/Return (WR). It is the absolute value of the most extreme loss for the period. Best used in combination with other risk measures.\n\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmWR(bmX) = -min(bmX)\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\n\nSee also: RiskMeasure, RMSettings, Portfolio, VaR, CVaR, EVaR, RLVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe WR risk is defined as an AffExpr with the key, :wr_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :wr_risk_ub.\n\nFunctor\n\n(wr::WR)(x::AbstractVector): computes the WR risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-3/#Conditional-Value-at-Risk","page":"Downside","title":"Conditional Value at Risk","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.CVaR","page":"Downside","title":"PortfolioOptimiser.CVaR","text":"mutable struct CVaR{T1 <: Real} <: RiskMeasure\n\nMeasures and computes the portfolio Conditional Value at Risk (CVaR). Also known as the Expected Shortfall, it is the weighted average of all tail losses up to the Value at Risk, which is the threshold below or equal to which are the worst alpha % of portfolio returns.\n\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmCVaR(bmX alpha) = mathrmVaR(bmX alpha) + dfrac1alpha T sumlimits_t=1^T maxleft(-X_t - mathrmVaR(bmX alpha) 0right)\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\nmathrmVaR(bmX alpha): is the Value at Risk as defined in VaR.\nT: is the number of observations.\nX_t: is the t-th value of the portfolio returns vector.\n\nSee also: RiskMeasure, RMSettings, Portfolio, VaR, WR, EVaR, RLVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe CVaR is defined as an AffExpr with the key, :cvar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :cvar_risk_ub.\n\nFunctor\n\n(cvar::CVaR)(x::AbstractVector): computes the CVaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-3/#Distributionally-Robust-Conditional-Value-at-Risk","page":"Downside","title":"Distributionally Robust Conditional Value at Risk","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.DRCVaR","page":"Downside","title":"PortfolioOptimiser.DRCVaR","text":"\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-3/#Entropic-Value-at-Risk","page":"Downside","title":"Entropic Value at Risk","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.EVaR","page":"Downside","title":"PortfolioOptimiser.EVaR","text":"mutable struct EVaR{T1 <: Real} <: RiskMeasureSolvers\n\nMeasures and computes the portfolio Entropic Value at Risk (EVaR). It is the upper bound of the Chernoff inequality for the VaR and CVaR.\n\nUses ExponentialCone constraints.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmEVaR(bmXalpha) = undersetz  0inf leftmathrmERM(bmX z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(bmX z alpha) is the entropic risk measure as defined in ERM.\nz: is the entropic value at risk.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\n\nSee also: RiskMeasureSolvers, RMSettings, Portfolio, VaR, WR, CVaR, RLVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}} = nothing: optional abstract dictionary containing the solvers, their settings, solution criteria, and other arguments.\nIf isnothing(solvers): it takes its value from the solvers property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe EVaR is defined as an AffExpr with the key, :evar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :evar_risk_ub.\n\nFunctor\n\n(evar::EVaR)(x::AbstractVector): computes the EVaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-3/#Relativistic-Value-at-Risk","page":"Downside","title":"Relativistic Value at Risk","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.RLVaR","page":"Downside","title":"PortfolioOptimiser.RLVaR","text":"mutable struct RLVaR{T1 <: Real, T2 <: Real} <: RiskMeasureSolvers\n\nMeasures and computes the portfolio Relativistic Value at Risk (RLVaR). It is a generalisation of the EVaR.\n\nUses PowerCone constraints.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\nlimlimits_kappa to 0 mathrmRLVaR(bmX alpha kappa) approx mathrmEVaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLVaR(bmX alpha kappa) approx mathrmWR(bmX)\n\nbeginalign\nmathrmRLVaR(bmX alpha kappa) = mathrmRRM(bmX alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(bmX alpha kappa) is the Relativistic Risk Measure as defined in RRM.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\nkappa: is the relativistic deformation parameter.\n\nSee also: RiskMeasureSolvers, RMSettings, Portfolio, VaR, WR, CVaR, EVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: relativistic deformation level, kappa ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}} = nothing: optional abstract dictionary containing the solvers, their settings, solution criteria, and other arguments. In order to solve the problem, a solver must be compatible with ExponentialCone.\nIf isnothing(solvers): it takes its value from the solvers property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe RLVaR is defined as an AffExpr with the key, :rlvar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :rlvar_risk_ub.\n\nFunctor\n\n(rlvar::RLVaR)(x::AbstractVector): computes the RLVaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-3/#Tail-Gini","page":"Downside","title":"Tail Gini","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-3/#PortfolioOptimiser.TG","page":"Downside","title":"PortfolioOptimiser.TG","text":"mutable struct TG{T1 <: Real, T2 <: Real, T3 <: Integer} <: RiskMeasureOWA\n\nMeasures and computes the portfolio Tail Gini (TG).\n\nSee also: See also: RiskMeasureOWA, RMSettings, Portfolio, owa_tg, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nformulation::OWAFormulation = OWAApprox(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe TG risk is defined as an AffExpr with the key, :tg_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :tg_risk_ub.\n\nFunctor\n\n(tg::TG)(x::AbstractVector): computes the TG risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Dispersion","page":"Dispersion","title":"Dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/","page":"Dispersion","title":"Dispersion","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-1/#Variance","page":"Dispersion","title":"Variance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.Variance","page":"Dispersion","title":"PortfolioOptimiser.Variance","text":"mutable struct Variance <: RiskMeasureSigma\n\nMeasures and computes the portfolio Variance (Variance).\n\nbeginalign\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nSee also: RiskMeasureSigma, RMSettings, SD, PortClass, OptimType, NOC, NoAdj, IP, SDP, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: (optional) N×N covariance matrix.\nIf nothing: takes its value from the instance Portfolio, the specific property depends on the PortClass parameter of the OptimType used.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nNoAdj, IP network and cluster constraints\n\nRequires a solver that supports SecondOrderCone constraints.\nRequires a solver capable of handling quadratic expressions.\nDefines the variance risk, :variance_risk, as a QuadExpr.\nIf it exists, the upper bound is defined via the portfolio standard deviation with the key, :dev_ub.\nIncompatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\n\nSDP network and/or cluster constraints\n\nRequires a solver that supports PSDCone constraints.\nDefines the variance risk, :variance_risk, as an AffExpr.\nCompatible with NOC (Near Optimal Centering) optimisations because AffExpr are strictly convex.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :variance_risk_ub.\n\nFunctor\n\n(variance::Variance)(w::AbstractVector): computes the Variance of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Standard-Deviation","page":"Dispersion","title":"Standard Deviation","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.SD","page":"Dispersion","title":"PortfolioOptimiser.SD","text":"mutable struct SD <: RiskMeasureSigma\n\nMeasures and computes the portfolio Standard Deviation (SD).\n\nbeginalign\nmathrmSD(bmw mathbfSigma) = left(bmw^intercal  mathbfSigma  bmwright)^12\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nSee also: RiskMeasureSigma, RMSettings, Variance, Portfolio, PortClass, OptimType, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: (optional) N×N covariance matrix.\nIf nothing: takes its value from the instance Portfolio, the specific property depends on the PortClass parameter of the OptimType used.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe SD risk is defined as a VariableRef with the key, :sd_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :sd_risk_ub.\nRequires a solver that supports SecondOrderCone constraints.\n\nFunctor\n\n(sd::SD)(w::AbstractVector): computes the SD risk of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Mean-Absolute-Deviation","page":"Dispersion","title":"Mean Absolute Deviation","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.MAD","page":"Dispersion","title":"PortfolioOptimiser.MAD","text":"mutable struct MAD <: RiskMeasureTarget\n\nMeasures and computes the portfolio Mean Absolute Deviation (MAD). In other words, it is the expected value of the absolute deviation from a target return of the returns vector. This is a generalisation to accomodate the use of weighted means, and predefined targets rather than forcing the MAD to be computed from the expected returns vector.\n\nbeginalign\nmathrmMAD(bmX) = mathbbEleft(leftlvert bmX - r bmw_erightrvertright)\nendalign\n\nWhere:\n\nmathbbE(cdot bmw): is the optionally weighted expected value.\nIf bmw is not provided it is the expected value.\nbmX: is the T×1 portfolio returns vector.\nbmw_e: is an optional weights vector for computing the MAD.\nlvert cdot rvert: is the absolute value.\nr: is the target return value. Defaults to mathbbE(bmX bmw).\nbmw: is an optional weights vector used for computing the expected value.\n\nSee also: RiskMeasureTarget, RMSettings, Portfolio, PortClass, OptimType, expected_risk, optimise!, calc_target_ret_mu, calc_ret_mu, calc_rm_target, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\ntarget::target::Union{<:Real, <:AbstractVector{<:Real}, Nothing} = nothing:\nIf isnothing(target): Its value can be computed via calc_target_ret_mu or calc_rm_target.\nelse: directly provides the target return for computing the deviation.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector (internal expected value) via calc_target_ret_mu.\nwe::Union{<:AbstractWeights, Nothing} = nothing: (optional) T×1 vector of weights for computing the expected value of the absolute deviation (external expected value).\nIf isnothing(we): computes the unweighted mean.\nElse: computes the weighted mean.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional) N×1 vector of weights for computing the expected value of the returns vector (internal expected value) via calc_ret_mu or set_rm.\n\nwarning: Warning\nUsing w to compute the MAD risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of mu used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :mad_risk. Alternatively, use the value of mu in both.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe MAD risk is defined as an AffExpr with the key, :mad_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :mad_risk_ub.\n\nFunctor\n\n(mad::MAD)(X::AbstractMatrix, w::AbstractVector, fees::Real = 0.0): computes the MAD risk of a T×N returns matrix, a N×1 vector of asset weights w, and fees fees.\nfees: must be consistent with the returns frequency.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Square-Root-Kurtosis","page":"Dispersion","title":"Square Root Kurtosis","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.Kurt","page":"Dispersion","title":"PortfolioOptimiser.Kurt","text":"mutable struct Kurt <: RiskMeasureMu\n\nMeasures and computes the portfolio Square Root Kurtosis (Kurt).\n\nbeginalign\nmathrmKurt(bmX) = left(dfrac1T sumlimits_t=1^T left(X_t - mathbbE(bmX) right)^4 right)^12\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nT: is the number of observations.\nX_t: is the t-th value of the portfolio returns vector.\nmathbbE(cdot): is the expected value.\n\nSee also: RiskMeasureMu, RMSettings, SKurt, Kurtosis, SKurtosis, expected_risk, Portfolio, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional, functor-exclusive) N×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nkt::Union{<:AbstractMatrix, Nothing} = nothing: (optional, set_rm exclusive) N²×N² cokurtosis matrix.\nIf nothing: takes its value from the kurt instance Portfolio.\nkt has no effect in optimisations that don't use JuMP models, because the kurtosis is computed from the returns vector.\n\nwarning: Warning\nUsing w to compute the Kurt risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of kurt in the instance of Portfolio used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :kurt_risk.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nUses PSDCone constraints.\nThe Kurt risk is defined as an AffExpr with the key, :kurt_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :kurt_risk_ub.\n\nFunctor\n\n(kurt::Kurt)(x::AbstractVector): computes the Kurt risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Range","page":"Dispersion","title":"Range","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.RG","page":"Dispersion","title":"PortfolioOptimiser.RG","text":"mutable struct RG <: RiskMeasure\n\nMeasures and computes the portfolio Range (RG). It is the difference between the best and worst return.\n\nbeginalign\nmathrmRG(bmX) = max(bmX) - min(bmX)\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\n\nSee also: RiskMeasure, RMSettings, Portfolio, WR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe RG risk is defined as an AffExpr with the key, :rg_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :rg_risk_ub.\n\nFunctor\n\n(rg::RG)(x::AbstractVector): computes the RG risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Conditional-Value-at-Risk-Range","page":"Dispersion","title":"Conditional Value at Risk Range","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.CVaRRG","page":"Dispersion","title":"PortfolioOptimiser.CVaRRG","text":"mutable struct CVaRRG{T1 <: Real, T2 <: Real} <: RiskMeasure\n\nMeasures and computes the portfolio Conditional Value at Risk Range (CVaRRG). It measures the difference between the weighted average of all head gains up to the Value at Risk for gains, which is the threshold above or equal to which are the best beta % of portfolio returns. And the weighted average of all tail losses up to the Value at Risk, which is the threshold below or equal to which are the worst alpha % of portfolio returns.\n\nbeginalign\nmathrmCVaRRG(bmX alphabeta) = mathrmCVaR(bmX alpha) - mathrmCVaR(-bmX beta)\nendalign\n\nWhere:\n\nmathrmCVaR(bmX alpha): is the Conditional Value at Risk as defined in CVaR.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level of losses.\nbeta: is the significance level of gains.\n\nSee also: See also: RiskMeasure, RMSettings, Portfolio, CVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level of losses, alpha ∈ (0, 1).\nbeta::T1 = 0.05: significance level of gains, beta ∈ (0, 1).\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe CVaRRG is defined as an AffExpr with the key, :cvarrg_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :cvarrg_risk_ub.\n\nFunctor\n\n(cvarrg::CVaRRG)(x::AbstractVector): computes the CVaRRG of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Tail-Gini-Range","page":"Dispersion","title":"Tail Gini Range","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.TGRG","page":"Dispersion","title":"PortfolioOptimiser.TGRG","text":"mutable struct TGRG{T1 <: Real, T2 <: Real, T3 <: Integer, \n                    T4 <: Real, T5 <: Real, T6 <: Integer} <: RiskMeasureOWA\n\nMeasures and computes the portfolio Tail Gini Range (TGRG). It is the difference between the Head Gini and Tail Gini.\n\nbeginalign\nmathrmTGRG(bmX alpha beta) = mathrmTG(bmXalpha) - mathrmTG(-bmXbeta)\nendalign\n\nWhere:\n\nmathrmTG: is the Tail Gini defined in TG.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level of losses.\nbeta: is the significance level of gains.\n\nSee also: See also: RiskMeasureOWA, RMSettings, Portfolio, owa_tgrg, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nformulation::OWAFormulation = OWAApprox(): OWA risk measure settings.\nalpha_i::T1 = 0.0001: start value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\nalpha::T2 = 0.05: end value of the significance level of CVaR losses, 0 < alpha_i < alpha < 1.\na_sim::T3 = 100: number of CVaRs to approximate the Tail Gini losses, a_sim > 0.\nbeta_i::T4 = 0.0001: start value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nbeta::T5 = 0.05: end value of the significance level of CVaR gains, 0 < beta_i < beta < 1.\nb_sim::T6 = 100: number of CVaRs to approximate the Tail Gini gains, b_sim > 0.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe TGRG risk is defined as an AffExpr with the key, :tgrg_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :tgrg_risk_ub.\n\nFunctor\n\n(tgrg::TGRG)(x::AbstractVector): computes the TGRG risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Gini-Mean-Difference","page":"Dispersion","title":"Gini Mean Difference","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.GMD","page":"Dispersion","title":"PortfolioOptimiser.GMD","text":"mutable struct GMD <: RiskMeasureOWA\n\nMeasures and computes the portfolio Gini Mean Difference (GMD).\n\nSee also: See also: RiskMeasureOWA, RMSettings, Portfolio, owa_gmd, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nformulation::OWAFormulation = OWAApprox(): OWA risk measure settings.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe GMD risk is defined as an AffExpr with the key, :gmd_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :gmd_risk_ub.\n\nFunctor\n\n(gmd::GMD)(x::AbstractVector): computes the GMD risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Negative-Quadratic-Skewness","page":"Dispersion","title":"Negative Quadratic Skewness","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.NQSkew","page":"Dispersion","title":"PortfolioOptimiser.NQSkew","text":"mutable struct NQSkew <: RiskMeasureSkew\n\nMeasures and computes the portfolio Negative Quadratic Skewness (NQSkew).\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw: is the vector of asset weights.\nmathbfV: is the sum of the symmetric negative spectral slices of the coskewness.\n\nSee also: See also: RiskMeasureSkew, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: (optional) N×N² custom coskewness matrix.\nIf isnothing(skew): takes its value from the skew property of the instance of Portfolio.\nV::Union{Nothing, <:AbstractMatrix}: (optional) Na×Na custom sum of the symmetric negative spectral slices of the coskewness.\nIf isnothing(V): takes its value from the V property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe NQSkew risk is defined as an QuadExpr with the key, :nqskew_risk = t_nqskew^2.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :t_nqskew_ub.\nIncompatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\n\nFunctor\n\n(nqskew::NQSkew)(w::AbstractVector): computes the NQSkew risk of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Negative-Skewness","page":"Dispersion","title":"Negative Skewness","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.NSkew","page":"Dispersion","title":"PortfolioOptimiser.NSkew","text":"mutable struct NSkew <: RiskMeasureSkew\n\nMeasures and computes the portfolio Negative Skewness (NSkew).\n\nbeginalign\nnu = left(bmw^intercal mathbfV bmwright)^12\nendalign\n\nWhere:\n\nbmw: is the vector of asset weights.\nmathbfV: is the sum of the symmetric negative spectral slices of the coskewness.\n\nSee also: See also: RiskMeasureSkew, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: (optional) N×N² custom coskewness matrix.\nIf isnothing(skew): takes its value from the skew property of the instance of Portfolio.\nV::Union{Nothing, <:AbstractMatrix}: (optional) Na×Na custom sum of the symmetric negative spectral slices of the coskewness.\nIf isnothing(V): takes its value from the V property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe NQSkew risk is defined as an AffExpr with the key, :nskew_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :nskew_risk_ub.\n\nFunctor\n\n(nskew::NSkew)(w::AbstractVector): computes the NSkew risk of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Brownian-Distance-Variance","page":"Dispersion","title":"Brownian Distance Variance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.BDVariance","page":"Dispersion","title":"PortfolioOptimiser.BDVariance","text":"struct BDVariance <: RiskMeasure\n\nMeasures and computes the portfolio Brownian Distance Variance (BDVariance). It captures linear and non-linear codependence between assets.\n\nbeginalign\nmathrmBDVariance(bmX) = mathrmBDCov(bmX bmX) =  dfrac1T^2 sumlimits_i=1^Tsumlimits_j=1^T A_ij^2\nmathrmBDCov(bmX bmY) = dfrac1T^2 sumlimits_i=1^T sumlimits_j=1^T A_ij B_ij\nA_ij = a_ij - bara_i - bara_j + bara_\nB_ij = b_ij - barb_i - barb_j + barb_\na_ij = lVert X_i - X_j rVert_2 quad forall i j = 1 ldots  T\nb_ij = lVert Y_i - Y_j rVert_2 quad forall i j = 1 ldots  T\nendalign\n\nWhere:\n\nbmX and bmY : are random variables, they are equal in this case as they are the portfolio returns.\na_ij and b_ij : are entries of a distance matrix where i and j are points in time. Each entry is defined as the Euclidean distance lVert cdot rVert_2 between the value of the random variable at time i and its value at time j.\nbara_icdot and barb_icdot : are the i-th row means of their respective matrices.\nbara_cdotj and barb_cdotj : are the j-th column means of their respective matrices.\nbara_cdotcdot and barb_cdotcdot : are the grand means of their respective matrices.\nA_ij and B_ij : are doubly centered distances.\n\nSee also: See also: RiskMeasure, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe BDVariance risk is defined as a QuadExpr with the key, :bdvariance_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :bdvariance_risk_ub.\n\nFunctor\n\n(bdvariance::BDVariance)(x::AbstractVector): computes the BDVariance risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-1/#Worst-Case-Variance","page":"Dispersion","title":"Worst Case Variance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-1/#PortfolioOptimiser.WCVariance","page":"Dispersion","title":"PortfolioOptimiser.WCVariance","text":"mutable struct WCVariance{T1 <: Real} <: RiskMeasureSigma\n\nMeasures and computes the portfolio Variance with uncertainty sets.\n\nOnly has an effect on optimisations which take risk measures and use JuMP models.\nIt is not affected by VarianceFormulation.\nIt otherwise acts the same as the Variance except for the fact that it always gets its value from the cov property of the Portfolio instance.\n\nbeginalign\nmathrmVariance(bmw mathbfSigma) = bmw^intercal  mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nSee also: RiskMeasureSigma, RMSettings, WCType, WCSetMuSigma, Box, Ellipse, Variance, VarianceFormulation, Portfolio, wc_statistics!, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nwc_set::WCSetMuSigma = Box(): uncertainty set apply to the variance in the optimisation.\nIf isa(wc_set, Box): uses cov_l and cov_u, either from the risk measure, or their corresponding instance of Portfolio.\nIf isa(wc_set, Ellipse): uses cov_sigma and k_sigma, either from the risk measure, or their corresponding instance of Portfolio.\nsigma::Union{<:AbstractMatrix, Nothing} = nothing: (optional) N×N covariance matrix.\nIf nothing: takes its value from the cov property of the instance Portfolio.\ncov_l::Union{AbstractMatrix{<:Real}, Nothing} = nothing: N×N lower percentile of the covariance matrix of the Box uncertainty set.\nIf nothing: takes its value from the cov_l property of the instance of Portfolio.\ncov_u::Union{AbstractMatrix{<:Real}, Nothing} = nothing: N×N upper percentile of the covariance matrix of the Box uncertainty set.\nIf nothing: takes its value from the cov_u property of the instance of Portfolio.\ncov_sigma::Union{AbstractMatrix{<:Real}, Nothing} = nothing: N²×N² covariance matrix of the estimation errors of the covariance of the Ellipse uncertainty set.\nIf nothing: takes its value from the cov_sigma property of the instance of Portfolio.\nk_sigma::T1 = Inf: square root of the size of the Ellipse uncertainty set.\nIf nothing: takes its value from the k_sigma property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nUses PSDCone constraints.\nThe WCVariance risk is defined as an AffExpr with the key, :wcvariance_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :wcvariance_risk_ub.\n\nFunctor\n\n(variance::WCVariance)(w::AbstractVector): computes the WCVariance (which is equal to the variance) of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioRisk/#Risk","page":"Risk","title":"Risk","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/#Public","page":"Risk","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.expected_risk","page":"Risk","title":"PortfolioOptimiser.expected_risk","text":"expected_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.factor_risk_contribution","page":"Risk","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                         F::AbstractMatrix = port.f_returns,\n                         type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n                         rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6)\n\nCompute the factor risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nw: Na×1 vector of asset weights.\nX: T×Na matrix of asset returns.\nF: T×Nf matrix of factor returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nOutputs\n\nrc_f: Nf×1 vector of risk contribution per factor.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.number_effective_assets","page":"Risk","title":"PortfolioOptimiser.number_effective_assets","text":"number_effective_assets(port; type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP)\n\nCompute the number of effective assets.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.risk_contribution","page":"Risk","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n                  rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6,\n                  marginal::Bool = false)\n\nCompute the asset risk contribution for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the marginal risk and equal risk measure Equal.\nmarginal:\nif true: compute the marginal risk contribution.\nelse: compute the risk by contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc: Na×1 vector of risk contribution per asset.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#PortfolioOptimiser.sharpe_ratio","page":"Risk","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n             mu::AbstractVector = port.mu,\n             type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n             rm::AbstractRiskMeasure = SD(), delta::Real = 1e-6, rf::Real = 0.0,\n             kelly::Bool = false)\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N matrix of asset returns.\nmu: N×1 vector of expected returns.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: risk measure AbstractRiskMeasure.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioRisk/#Private","page":"Risk","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#Downside-dispersion","page":"Downside dispersion","title":"Downside dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/","page":"Downside dispersion","title":"Downside dispersion","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-2/#Semi-Variance","page":"Downside dispersion","title":"Semi Variance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.SVariance","page":"Downside dispersion","title":"PortfolioOptimiser.SVariance","text":"mutable struct SVariance <: RiskMeasureTarget\n\nMeasures and computes the portfolio Semi Variance (SVariance). Measures the variance equal to or below the target return.\n\nbeginalign\nmathrmSVariance(bmX) = dfrac1T-1 sumlimits_t=1^Tminleft(X_t - mathbbE(bmX) 0right)^2\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nT: is the number of observations.\nX_t: is the t-th value of the portfolio returns vector.\nmathbbE(cdot): is the expected value.\n\nSee also: RiskMeasureMu, RMSettings, Portfolio, SD, Variance, SSD, NOC, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\ntarget::target::Union{<:Real, <:AbstractVector{<:Real}, Nothing} = nothing: minimum return threshold for classifying downside returns. Only returns equal to or below this value are considered in the calculation. Its value can be computed via calc_target_ret_mu or calc_rm_target.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional) N×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu or set_rm.\n\nwarning: Warning\nUsing w to compute the SVariance risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of mu used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :svariance_risk. Alternatively, use the value of mu in both.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe SVariance risk is defined as a QuadExpr with the key, :svariance_risk.\nIf it exists, the upper bound is defined via the portfolio semi standard deviation with the key, :sdev_ub.\nIncompatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\n\nFunctor\n\n(svariance::SVariance)(X::AbstractMatrix, w::AbstractVector, fees::Real = 0.0): computes the SVariance risk of a T×N returns matrix, a N×1 vector of asset weights w, and fees fees.\nfees: must be consistent with the returns frequency.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-2/#Semi-Standard-Deviation","page":"Downside dispersion","title":"Semi Standard Deviation","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.SSD","page":"Downside dispersion","title":"PortfolioOptimiser.SSD","text":"mutable struct SSD <: RiskMeasureTarget\n\nMeasures and computes the portfolio Semi Standard Deviation (SSD). Measures the standard deviation equal to or below the target return. If the target return is the risk-free rate, the risk-adjusted return ratio of this risk measure is commonly known as the Sortino ratio.\n\nbeginalign\nmathrmSSD(bmX) = left(dfrac1T-1 sumlimits_t=1^Tminleft(X_t - r 0right)^2right)^12\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nT: is the number of observations.\nr: is the minimum acceptable return.\nX_t: is the t-th value of the portfolio returns vector.\nmathbbE(cdot): is the expected value.\n\nSee also: RiskMeasureMu, RMSettings, Portfolio, SD, Variance, SVariance, expected_risk, optimise!, calc_target_ret_mu, calc_ret_mu, calc_rm_target, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\ntarget::target::Union{<:Real, <:AbstractVector{<:Real}, Nothing} = nothing: minimum return threshold for classifying downside returns. Only returns equal to or below this value are considered in the calculation. Its value can be computed via calc_target_ret_mu or calc_rm_target.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional) N×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu or set_rm.\n\nwarning: Warning\nUsing w to compute the SSD risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of mu used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :ssd_risk. Alternatively, use the value of mu in both.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe SSD risk is defined as an AffExpr with the key, :ssd_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :ssd_risk_ub.\n\nFunctor\n\n(ssd::SSD)(X::AbstractMatrix, w::AbstractVector, fees::Real = 0.0): computes the SSD risk of a T×N returns matrix, a N×1 vector of asset weights w, and fees fees.\nfees: must be consistent with the returns frequency.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-2/#First-Lower-Partial-Moment","page":"Downside dispersion","title":"First Lower Partial Moment","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.FLPM","page":"Downside dispersion","title":"PortfolioOptimiser.FLPM","text":"mutable struct FLPM <: RiskMeasureTarget\n\nMeasures and computes the portfolio First Lower Partial Moment (FLPM). Measures the dispersion equal to or below the target return threshold. The risk-adjusted return ratio of this risk measure is commonly known as the Omega ratio.\n\nbeginalign\nmathrmFLPM(bmX r) = dfrac1T sumlimits_t=1^Tmaxleft(r - X_t 0right)\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nr: is the minimum acceptable return.\nT: is the number of observations.\nX_t: is the t-th value of the portfolio returns vector.\n\nSee also: RiskMeasureTarget, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\ntarget::T1 = 0.0: minimum return threshold for classifying downside returns. Only returns equal to or below this value are considered in the calculation. Its value can be computed via calc_target_ret_mu or calc_rm_target.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional) N×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu or set_rm.\n\nwarning: Warning\nUsing w to compute the FLPM risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of mu used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :flpm_risk. Alternatively, use the value of mu in both.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe FLPM risk is defined as an AffExpr with the key, :flpm_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :flpm_risk_ub.\n\nFunctor\n\n(flpm::FLPM)(X::AbstractMatrix, w::AbstractVector, fees::Real = 0.0): computes the FLPM risk of a T×N returns matrix, a N×1 vector of asset weights w, and fees fees.\nfees: must be consistent with the returns frequency.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-2/#Square-Root-Semi-Kurtosis","page":"Downside dispersion","title":"Square Root Semi Kurtosis","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.SKurt","page":"Downside dispersion","title":"PortfolioOptimiser.SKurt","text":"mutable struct SKurt <: RiskMeasureMu\n\nMeasures and computes the portfolio Square Root Semi Kurtosis (SKurt). Measures the kurtosis equal to or below the mean portfolio returns.\n\nbeginalign\nmathrmSKurt(bmX) = left(dfrac1T sumlimits_t=1^T minleft(X_t - mathbbE(bmX) 0 right)^4 right)^12\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nT: is the number of observations.\nX_t: is the t-th value of the portfolio returns vector.\nmathbbE(cdot): is the expected value.\n\nSee also: RiskMeasureMu, RMSettings, Kurt, Kurtosis, SKurtosis, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\nw::Union{<:AbstractWeights, Nothing} = nothing: (optional, functor-exclusive) T×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nmu::Union{<:AbstractVector{<:Real}, Nothing} = nothing: (optional, functor-exclusive) N×1 vector of weights for computing the expected value of the returns vector via calc_ret_mu.\nkt::Union{<:AbstractMatrix, Nothing} = nothing: (optional, set_rm exclusive) N²×N² cokurtosis matrix.\nIf nothing: takes its value from the skurt instance Portfolio.\nkt has no effect in optimisations that don't use JuMP models, because the kurtosis is computed from the returns vector.\n\nwarning: Warning\nUsing w to compute the Kurt risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of skurt in the instance of Portfolio used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :skurt_risk.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nUses PSDCone constraints.\nThe Kurt risk is defined as an AffExpr with the key, :skurt_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :skurt_risk_ub.\n\nFunctor\n\n(skurt::SKurt)(x::AbstractVector): computes the SKurt risk of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-2/#Negative-Quadratic-Semi-Skewness","page":"Downside dispersion","title":"Negative Quadratic Semi Skewness","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.NQSSkew","page":"Downside dispersion","title":"PortfolioOptimiser.NQSSkew","text":"mutable struct NQSSkew <: RiskMeasureSkew\n\nMeasures and computes the portfolio Negative Quadratic Semi Skewness (NQSSkew).\n\nbeginalign\nnu = bmw^intercal mathbfV bmw\nendalign\n\nWhere:\n\nbmw: is the vector of asset weights.\nmathbfV: is the sum of the symmetric negative spectral slices of the semi coskewness.\n\nSee also: See also: RiskMeasureSkew, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: (optional) N×N² custom semi coskewness matrix.\nIf isnothing(skew): takes its value from the sskew property of the instance of Portfolio.\nV::Union{Nothing, <:AbstractMatrix}: (optional) Na×Na custom sum of the symmetric negative spectral slices of the semi coskewness.\nIf isnothing(V): takes its value from the SV property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe NQSSkew risk is defined as an AffExpr with the key, :nqsskew_risk = t_nqsskew^2.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :t_nqsskew_ub.\nIncompatible with NOC (Near Optimal Centering) optimisations because QuadExpr are not strictly convex.\n\nFunctor\n\n(nqsskew::NQSSkew)(w::AbstractVector): computes the NQSSkew risk of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-2/#Negative-Semi-Skewness","page":"Downside dispersion","title":"Negative Semi Skewness","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-2/#PortfolioOptimiser.NSSkew","page":"Downside dispersion","title":"PortfolioOptimiser.NSSkew","text":"mutable struct NSSkew <: RiskMeasureSkew\n\nMeasures and computes the portfolio Negative Semi Skewness (NSSkew).\n\nbeginalign\nnu = left(bmw^intercal mathbfV bmwright)^12\nendalign\n\nWhere:\n\nbmw: is the vector of asset weights.\nmathbfV: is the sum of the symmetric negative spectral slices of the semi coskewness.\n\nSee also: See also: RiskMeasureSkew, RMSettings, Portfolio, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nskew::Union{<:AbstractMatrix, Nothing}: (optional) N×N² custom semi coskewness matrix.\nIf isnothing(skew): takes its value from the sskew property of the instance of Portfolio.\nV::Union{Nothing, <:AbstractMatrix}: (optional) Na×Na custom sum of the symmetric negative spectral slices of the semi coskewness.\nIf isnothing(V): takes its value from the SV property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe NSSkew risk is defined as an AffExpr with the key, :nsskew_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :nsskew_risk_ub.\n\nFunctor\n\n(nsskew::NSSkew)(w::AbstractVector): computes the NSSkew risk of an N×1 vector of asset weights.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"Constraints/ViewsConstraints/#Views-constraints","page":"Views constraints","title":"Views constraints","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/#Public","page":"Views constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.asset_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.asset_views","text":"asset_views(views::DataFrame, asset_sets::DataFrame)\n\nCreate the asset views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×9 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nType: (String) specifies the object(s) to which a view applies:\nAsset: specific asset.\nSubset: whole class.\nSet: (String) if Type is Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the view applies.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nReturn: (<:Real) the view's return.\nRelative_Type: (String) specifies to what the view is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative view.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nP: Nv×Na matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nviews = DataFrame(\"Enabled\" => [true, true, true, true, true],\n                  \"Type\" => [\"Asset\", \"Subset\", \"Subset\", \"Asset\", \"Subset\"],\n                  \"Set\" => [\"\", \"Class 2\", \"Class 1\", \"\", \"Class 1\"],\n                  \"Position\" => [\"WFC\", \"Financial\", \"Equity\", \"FB\", \"Fixed Income\"],\n                  \"Sign\" => [\"<=\", \">=\", \">=\", \">=\", \"<=\"],\n                  \"Return\" => [0.3, 0.1, 0.05, 0.03, 0.017],\n                  \"Relative_Type\" => [\"Asset\", \"Subset\", \"Asset\", \"\", \"\"],\n                  \"Relative_Set\" => [\"\", \"Class 1\", \"\", \"\", \"\"],\n                  \"Relative_Position\" => [\"FB\", \"Fixed Income\", \"TLT\", \"\", \"\"])\nP, Q = asset_views(views, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#PortfolioOptimiser.factor_views-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Views constraints","title":"PortfolioOptimiser.factor_views","text":"factor_views(views::DataFrame, loadings::DataFrame)\n\nCreate the factor views matrix P and vector Q:\n\nmathbfP bmw geq bmQ.\n\nInputs\n\nviews: Nv×4 DataFrame, where Nv is the number of views. The required columns are:\nEnabled: (Bool) indicates if the view is enabled.\nFactor: (String) name of the view's factor.\nSign: (String) specifies whether the view is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the view is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nP: Nv×Nf matrix of views where Nv is the number of views and .\nQ: Nv×1 vector of views where Nv is the number of views.\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nviews = DataFrame(\"Enabled\" => [true, true, true], \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\"],\n                  \"Sign\" => [\"<=\", \"<=\", \">=\"], \"Value\" => [0.9, -1.2, 0.3],\n                  \"Relative_Factor\" => [\"USMV\", \"\", \"\"])\nP, Q = factor_views(views, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/ViewsConstraints/#Private","page":"Views constraints","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-1/#Dispersion","page":"Dispersion","title":"Dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-1/","page":"Dispersion","title":"Dispersion","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-1/#Value-at-Risk-Range","page":"Dispersion","title":"Value at Risk Range","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-1/#PortfolioOptimiser.VaRRG","page":"Dispersion","title":"PortfolioOptimiser.VaRRG","text":"mutable struct VaRRG{T1 <: Real, T2 <: Real} <: HCRiskMeasure\n\nMeasures and computes the portfolio Value at Risk Range (VaRRG). It measures the difference between the threshold above or equal to which are the best beta % of portfolio returns. And the threshold below or equal to which are the worst alpha % of portfolio returns.\n\nbeginalign\nmathrmVaRRG(bmX alphabeta) = mathrmVaR(bmX alpha) - mathrmVaR(-bmX beta)\nendalign\n\nWhere:\n\nmathrmVaR(bmX alpha): is the Value at Risk as defined in VaR.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level of losses.\nbeta: is the significance level of gains.\n\nSee also: See also: RiskMeasure, RMSettings, Portfolio, VaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level of losses, alpha ∈ (0, 1).\nbeta::T1 = 0.05: significance level of gains, beta ∈ (0, 1).\n\nFunctor\n\n(varrg::VaRRG)(x::AbstractVector): computes the VaRRG of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-1/#Fourth-Central-Moment","page":"Dispersion","title":"Fourth Central Moment","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-1/#PortfolioOptimiser.FTCM","page":"Dispersion","title":"PortfolioOptimiser.FTCM","text":"\n\n\n\n","category":"type"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"M. M. López de Prado. Machine Learning for Asset Managers. Elements in Quantitative Finance (Cambridge University Press, 2020).\n\n\n\nM. L. De Prado. Building diversified portfolios that outperform out of sample. The Journal of Portfolio Management 42, 59–69 (2016).\n\n\n\nA. Hacine-Gharbi, P. Ravier, R. Harba and T. Mohamadi. Low bias histogram-based estimation of mutual information for feature selection. Pattern Recognition Letters 33, 1302–1308 (2012).\n\n\n\nW.-M. Song, T. Di Matteo and T. Aste. Hierarchical information clustering by means of topologically embedded graphs. PloS one 7, e31929 (2012).\n\n\n\nW.-M. Song, T. D. Matteo and T. Aste. Nested hierarchies in planar graphs. Discrete Applied Mathematics 159, 2135–2146 (2011).\n\n\n\nW. Barfuss, G. P. Massara, T. Di Matteo and T. Aste. Parsimonious modeling with information filtering networks. Phys. Rev. E 94, 062306 (2016).\n\n\n\nG. P. Massara, T. Di Matteo and T. Aste. Network Filtering for Big Data: Triangulated Maximally Filtered Graph. Journal of Complex Networks 5, 161–178 (2016), arXiv:https://academic.oup.com/comnet/article-pdf/5/2/161/13794756/cnw015.pdf.\n\n\n\nT. Bodnar, O. Okhrin and N. Parolya. Optimal shrinkage estimator for high-dimensional mean vector. Journal of Multivariate Analysis 170, 63–79 (2019). Special Issue on Functional Data Analysis and Related Topics.\n\n\n\nP. Jorion. Bayes-Stein Estimation for Portfolio Analysis. The Journal of Financial and Quantitative Analysis 21, 279–292 (1986). Accessed on Mar 1, 2024.\n\n\n\nA. Meucci. Risk and asset allocation. Vol. 1 (Springer, 2005).\n\n\n\nY. Feng and D. P. Palomar. A Signal Processing Perspective on Financial Engineering. Foundations and Trends® in Signal Processing 9, 1–231 (2016).\n\n\n\nD. Cajas. Higher Order Moment Portfolio Optimization with L-Moments. Available at SSRN 4393155 (2023).\n\n\n\n","category":"page"},{"location":"RiskMeasures/RiskMeasures3-4/#Drawdown","page":"Drawdown","title":"Drawdown","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/","page":"Drawdown","title":"Drawdown","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-4/#Drawdown-at-Risk-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Drawdown at Risk of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.DaR","page":"Drawdown","title":"PortfolioOptimiser.DaR","text":"mutable struct DaR{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for uncompounded cumulative returns.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmDaR_a(bmX alpha) = undersetj in (0 T)max left mathrmDD_a(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_a(bmX j)right)  1 - alpha right\nmathrmDD_a(bmX j) = undersett in (0 j)maxleft( sumlimits_i=0^t X_i right) - sumlimits_i=0^j X_i\nmathrmDD_a(bmX) = leftj in (0T)    mathrmDD_a(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns.\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j.\nmathrmDaR_a(bmX alpha) the Drawdown at Risk of uncompounded cumulative returns.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::DaR, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR()\n\n# Custom significance level\ndar = DaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Drawdown-at-Risk-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Drawdown at Risk of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.DaR_r","page":"Drawdown","title":"PortfolioOptimiser.DaR_r","text":"mutable struct DaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nDefines the Drawdown at Risk for compounded cumulative returns.\n\nMeasures the lower bound of the peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmDaR_r(bmX alpha) = undersetj in (0 T)max left mathrmDD_r(bmX j) in mathbbR    F_mathrmDDleft(mathrmDD_r(bmX j)right)  1 - alpha right\nmathrmDD_r(bmX j) = undersett in (0 j)maxleft( prodlimits_i=0^t left(1+X_iright) right) - prodlimits_i=0^j left(1+X_iright)\nmathrmDD_r(bmX) = leftj in (0T)    mathrmDD_r(bmX j)right\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns.\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::DaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ndar = DaR_r()\n\n# Custom significance level\ndar = DaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Maximum-Drawdown-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Maximum Drawdown of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.MDD_r","page":"Drawdown","title":"PortfolioOptimiser.MDD_r","text":"mutable struct MDD_r <: HCRiskMeasure\n\nDescription\n\nMaximum Drawdown (Calmar ratio) risk measure for compounded cumulative returns.\n\nMeasures the largest peak-to-trough decline.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmMDD_r(bmX) = max mathrmDD_r(bmX)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX) is the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::MDD_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nmdd = MDD_r()\n\n# Custom significance level\nmdd = MDD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Average-Drawdown-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Average Drawdown of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.ADD_r","page":"Drawdown","title":"PortfolioOptimiser.ADD_r","text":"mutable struct ADD_r <: HCRiskMeasure\n\nDescription\n\nAverage Drawdown risk measure for uncompounded cumulative returns.\n\nMeasures the average of all peak-to-trough declines.\nProvides a more balanced view than the maximum drawdown MDD_r.\n\nbeginalign\nmathrmADD_r(bmX) = dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, expected_risk(::ADD_r, ::AbstractVector), ADD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nadd = ADD_r()\n\n# Custom significance level\nadd = ADD_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Ulcer-Index-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Ulcer Index of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.UCI_r","page":"Drawdown","title":"PortfolioOptimiser.UCI_r","text":"mutable struct UCI_r <: HCRiskMeasure\n\nDescription\n\nUlcer Index risk measure for compounded cumulative returns.\n\nPenalizes larger drawdowns more than smaller ones.\n\nbeginalign\nmathrmUCI_r(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_r(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::UCI_r, ::AbstractVector), UCI.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nuci_r = UCI_r()\n\n# Custom settings\nuci_r = UCI_r(; settings = HCRMSettings(; scale = 1.5))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Conditional-Drawdown-at-Risk-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Conditional Drawdown at Risk of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.CDaR_r","page":"Drawdown","title":"PortfolioOptimiser.CDaR_r","text":"mutable struct CDaR_r{T1 <: Real} <: HCRiskMeasure\n\nDescription\n\nConditional Drawdown at Risk risk measure for compounded cumulative returns.\n\nMeasures the expected peak-to-trough loss in the worst alpha % of cases.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmCDaR_r(bmX alpha) = mathrmDaR_r(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_r(bmX j) - mathrmDaR_r(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_r(bmX j) is the Drawdown of compounded cumulative returns at time j as defined in DaR_r.\nmathrmDaR_r(bmX alpha) the Drawdown at Risk of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::CDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\ncdar_r = CDaR_r()\n\n# Custom significance level\ncdar_r = CDaR_r(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01) # 1 % significance level\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Entropic-Drawdown-at-Risk-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Entropic Drawdown at Risk of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.EDaR_r","page":"Drawdown","title":"PortfolioOptimiser.EDaR_r","text":"mutable struct EDaR_r{T1 <: Real} <: HCRiskMeasureSolvers\n\nDescription\n\nEntropic Drawdown at Risk risk measure for compounded cumulative returns.\n\nUses ExponentialCone constraints.\nIt is the upper bound of the Chernoff inequality for the DaR and CDaR.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: HCRiskMeasure, HCRMSettings, Portfolio, optimise!, expected_risk(::EDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}}: optional JuMP-compatible solvers for exponential cone problems.\n\nBehaviour\n\nRequires solver capability for exponential cone problems.\nWhen computing expected_risk(::EDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nedar_r = EDaR_r()\n\n# Custom configuration with specific solver\nedar_r = EDaR_r(; alpha = 0.025,  # 2.5 % significance level\n                solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-4/#Relativistic-Drawdown-at-Risk-of-Compounded-Cumulative-Returns","page":"Drawdown","title":"Relativistic Drawdown at Risk of Compounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-4/#PortfolioOptimiser.RLDaR_r","page":"Drawdown","title":"PortfolioOptimiser.RLDaR_r","text":"mutable struct RLDaR_r{T1 <: Real, T2 <: Real} <: HCRiskMeasureSolvers\n\nDescription\n\nRelativistic Drawdown at Risk risk measure for compounded cumulative returns. It is a generalisation of the EDaR_r.\n\nUses PowerCone constraints.\nmathrmDaR_r(bmX alpha) leq mathrmCDaR_r(bmX alpha) leq mathrmEDaR_r(bmX alpha) leq mathrmRLDaR_r(bmX alpha kappa) leq mathrmMDD_r(bmX).\nlimlimits_kappa to 0 mathrmRLDaR_r(bmX alpha kappa) approx mathrmEDaR_r(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR_r(bmX alpha kappa) approx mathrmMDD_r(bmX)\n\nbeginalign\nmathrmRLDaR_r(bmX alpha kappa) = mathrmRRM(mathrmDD_r(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_r(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of compounded cumulative returns as defined in DaR_r.\n\nSee also: RiskMeasure, RMSettings, Portfolio, optimise!, expected_risk(::RLDaR_r, ::AbstractVector), VaR, CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: significance level, kappa ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}}: optional JuMP-compatible solvers for 3D power cone problems.\n\nBehaviour\n\nRequires solver capability for 3D power cone problems.\nWhen computing expected_risk(::RLDaR_r, ::AbstractVector):\nIf solvers is nothing: uses solvers from Portfolio/.\nIf solvers is provided: use the solvers.\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\nWhen setting kappa at construction or runtime, kappa ∈ (0, 1).\n\nExamples\n\n# Default settings\nrldar = RLDaR()\n\n# Custom configuration\nrldar = RLDaR(; alpha = 0.05, # 5 % significance level\n              kappa = 0.3,    # 30 % Deformation parameter\n              solvers = Dict(\"solver\" => my_solver))\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationRiskMeasures/#Risk-measures","page":"Risk measures","title":"Risk measures","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#Public","page":"Risk measures","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#Private","page":"Risk measures","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationRiskMeasures/#PortfolioOptimiser.calc_rm_target-NTuple{4, Any}","page":"Risk measures","title":"PortfolioOptimiser.calc_rm_target","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationRiskMeasures/#PortfolioOptimiser.set_rm-Tuple{Any, Variance, Union{NOC, RB, Trad}}","page":"Risk measures","title":"PortfolioOptimiser.set_rm","text":"set_rm(port, rm::RiskMeasure, type::Union{Trad, RB, NOC}; kwargs...)\nset_rm(port, rm::AbstractVector{<:RiskMeasure}, type::Union{Trad, RB, NOC}; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Matrix-denoising","page":"Matrix denoising","title":"Matrix denoising","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#Public","page":"Matrix denoising","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseFixed","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseFixed","text":"@kwdef mutable struct DenoiseFixed{T1, T2, T3, T4} <: AbstractDenoise\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the fixed type in denoise! [1, Chapter 2]. This type performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to their average, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: remove the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to remove from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseShrink","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseShrink","text":"@kwdef mutable struct DenoiseShrink{T1, T2, T3, T4, T5} <: AbstractDenoise\n    alpha::Real = 0.0\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the shrink type in denoise! [1, Chapter 2]. This type shrinks the covariance to a target of unequal variance of the matrix reconstructed with the eigenvalues that are below the noise significance value. The degree of shrinkage is parametrised by alpha.\n\nbeginalign\nmathbfC = mathbfC_u + alpha mathbfC_l + (1 - alpha) mathrmDiag(mathbfC)\nmathbfC_u = mathbfE_u mathbflambda_u mathbfE_u^intercal\nmathbfC_l = mathbfE_l mathbflambda_l mathbfE_l^intercal\nendalign\n\nWhere:\n\nmathbfC is the denoised correlation matrix.\nmathbfC_u is the reconstructed correlation matrix out of the eigenvalues that are above the noise significance threshold, and their corresponding eigenvectors.\nmathbfC_l is the reconstructed correlation matrix out of the eigenvalues that are below the noise significance threshold, and their corresponding eigenvectors.\nmathbfE_u are the eigenvectors corresponding to the eigenvalues that are above the noise significance threshold.\nmathbflambda_u is the diagonal matrix of eigenvalues that are above the noise significance threshold.\nmathbfE_l are the eigenvectors corresponding to the eigenvalues that are below the noise significance threshold.\nmathbflambda_l is the diagonal matrix of eigenvalues that are below the noise significance threshold.\n\nParameters\n\nalpha: tuning parameter for how much the matrix should be shrunk, alpha ∈ [0, 1].\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.DenoiseSpectral","page":"Matrix denoising","title":"PortfolioOptimiser.DenoiseSpectral","text":"@kwdef mutable struct DenoiseSpectral{T1, T2, T3, T4} <: AbstractDenoise\n    detone::Bool = false\n    mkt_comp::Integer = 1\n    kernel = AverageShiftedHistograms.Kernels.gaussian\n    m::Integer = 10\n    n::Integer = 1000\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the parameters for using the spectral type in denoise! [1, Chapter 2]. This type performs an eigendecomposition of the original correlation matrix, sets the eigenvalues that are below the noise significance threshold to zero, and reconstructs the correlation matrix using the modified values.\n\nParameters\n\ndetone:\ntrue: take only the largest mkt_comp eigenvalues from the correlation matrix.\n\nwarning: Warning\nRemoving eigenvalues from the matrix may make it singular.\n\nmkt_comp: the number of largest eigenvalues to keep from the correlation matrix.\nkernel: kernel for fitting the average shifted histograms from AverageShiftedHistograms.jl Kernel Functions.\nm: number of adjacent histograms to smooth over AverageShiftedHistograms.ash.\nn: number of points used when creating the range of values to which the average shifted histogram is to be fitted AverageShiftedHistograms.ash.\nargs: arguments for Optim.optimize\nkwargs: keyword arguments for Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.NoDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.NoDenoise","text":"struct NoDenoise <: AbstractDenoise end\n\nApply no denoising in denoise!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.denoise!-Tuple{PortfolioOptimiser.AbstractDenoise, PortfolioOptimiser.AbstractPosdefFix, AbstractMatrix, Real}","page":"Matrix denoising","title":"PortfolioOptimiser.denoise!","text":"denoise!(ce::AbstractDenoise, posdef::AbstractPosdefFix, X::AbstractMatrix, q::Real)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MatrixDenoising/#Private","page":"Matrix denoising","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MatrixDenoising/#PortfolioOptimiser.AbstractDenoise","page":"Matrix denoising","title":"PortfolioOptimiser.AbstractDenoise","text":"abstract type AbstractDenoise end\n\nAbstract type for subtyping denoising types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#Ordered-Weight-Arrays","page":"Ordered Weight Arrays","title":"Ordered Weight Arrays","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#Public","page":"Ordered Weight Arrays","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.CRRA","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.CRRA","text":"@kwdef mutable struct CRRA{T1 <: Real} <: OWATypes\n    g::T1 = 0.5\nend\n\nNormalised Constant Relative Risk Aversion Coefficients.\n\nParameters\n\ng: Risk aversion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MaxEntropy","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MaxEntropy","text":"@kwdef mutable struct MaxEntropy{T1 <: Real, T2 <: AbstractDict} <: OWATypes\n    max_phi::T1 = 0.5\n    solvers::T2 = Dict()\nend\n\nMaximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSqDist","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSqDist","text":"@kwdef mutable struct MinSqDist{T1 <: Real} <: OWAJTypes\n    max_phi::T1 = 0.5\nend\n\nMinimum Square Distance. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.MinSumSq","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.MinSumSq","text":"@kwdef mutable struct MinSumSq{T1 <: Real} <: OWAJTypes\n    max_phi::T1 = 0.5\nend\n\nMinimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n\nParameters\n\nmax_phi: Maximum weight constraint of the L-moments.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_cvar","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_cvar","text":"owa_cvar(T::Integer; alpha::Real = 0.05)\n\nCalculate the OWA weights corresponding to the Critical Value at Risk (CVaR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_cvarrg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_cvarrg","text":"owa_cvarrg(T::Integer; alpha::Real = 0.05, beta::Real = alpha)\n\nCompute the OWA weights for the CVaR Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_gmd-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_gmd","text":"owa_gmd(T::Integer)\n\nComputes the Gini Mean Difference (GMD) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n[OWA]: Cajas, Dany, OWA Portfolio Optimization: A Disciplined Convex Programming Framework (December 18, 2021). Available at SSRN: https://ssrn.com/abstract=3988927 or http://dx.doi.org/10.2139/ssrn.3988927\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment","text":"owa_l_moment(T::Integer; k::Integer = 2)\n\nCalculates the OWA weights of the k'th linear moment (L-moment) of a returns series [12].\n\nInputs\n\nk: order of the L-moment.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_l_moment_crm-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_l_moment_crm","text":"owa_l_moment_crm(T::Integer; k::Integer = 2, type::Symbol = :SD, g::Real = 0.5,\n                 max_phi::Real = 0.5, solvers = Dict())\n\nCompute the OWA weights for the convex risk measure considering higher order L-moments [12].\n\nInputs\n\nk: order of the L-moment, k ≥ 2.\ntype: type for computing the weights used to combine L-moments higher than 2, used in OWATypes.\n:CRRA: Normalised Constant Relative Risk Aversion Coefficients.\n:E: Maximum Entropy. Solver must support MOI.RelativeEntropyCone and MOI.NormOneCone.\n:SS: Minimum Sum of Squares. Solver must support MOI.SecondOrderCone.\n:SD: Minimum Square Distance. Solver must support MOI.SecondOrderCone.\ng: the risk aversion coefficient.\nmax_phi: maximum weight constraint of the L-moments.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_rg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_rg","text":"owa_rg(T::Integer)\n\nCompute the OWA weights for the Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_tg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_tg","text":"owa_tg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100)\n\nCompute the OWA weights for the Tail Gini of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_tgrg-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_tgrg","text":"owa_tgrg(T::Integer; alpha_i::Real = 0.0001, alpha::Real = 0.05, a_sim::Integer = 100,\n         beta_i::Real = alpha_i, beta::Real = alpha, b_sim::Integer = a_sim)\n\nCompute the OWA weights for the Tail Gini Range of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wcvar-Tuple{Integer, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wcvar","text":"owa_wcvar(T::Integer, alphas::AbstractVector{<:Real}, weights::AbstractVector{<:Real})\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of each CVaR model, where N is the number of models, each .\nweights: N×1 vector of weights of each CVaR model, where N is the number of models.\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wcvarrg","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wcvarrg","text":"owa_wcvarrg(T::Integer, alphas::AbstractVector{<:Real}, weights_a::AbstractVector{<:Real};\n            betas::AbstractVector{<:Real} = alphas,\n            weights_b::AbstractVector{<:Real} = weights_b)\n\nCompute the OWA weights for the Weighted Conditional Value at Risk (WCVaR) of a returns series [OWA].\n\nInputs\n\nalphas: N×1 vector of significance levels of the losses for each CVaR model, where N is the number of losses models, each .\nweights_a: N×1 vector of weights of the losses for each CVaR model, where N is the number of losses models.\nbetas: M×1 vector of significance levels of the gains for each CVaR model, where M is the number of gains models, each .\nweights_b: M×1 vector of weights of the gains for each CVaR model, where M is the number of gains models.\n\nOutputs\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.owa_wr-Tuple{Integer}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.owa_wr","text":"owa_wr(T::Integer)\n\nCompute the OWA weights for the Worst Realisation (WR) of a returns series [OWA].\n\nInputs\n\nOutputs\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#Private","page":"Ordered Weight Arrays","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.OWAJTypes","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.OWAJTypes","text":"abstract type OWAJTypes <: OWATypes end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.OWATypes","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.OWATypes","text":"abstract type OWATypes end\n\nAbstract type for subtyping Ordered Weight Array (OWA) types for computing the weights used to combine L-moments higher than 2 [12] in owa_l_moment_crm.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.crra_weights-Tuple{AbstractMatrix{<:Real}, Integer, Real}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.crra_weights","text":"crra_weights(weights::AbstractMatrix{<:Real}, k::Integer, g::Real)\n\nInternal function for computing the Normalized Constant Relative Risk Aversion coefficients.\n\nInputs\n\nweights: T×(k-1) matrix where T is the number of observations and k the order of the L-moments to combine, the i'th column contains the weights for the (i+1)'th L-moment.\nk: the maximum order of the L-moments.\ng: the risk aversion coefficient.\n\nOutputs\n\nw: T×1 ordered weight vector of the combined L-moments.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/OWA/#PortfolioOptimiser.optimise_JuMP_model-Tuple{Any, Any}","page":"Ordered Weight Arrays","title":"PortfolioOptimiser.optimise_JuMP_model","text":"optimise_JuMP_model(model, solvers)\n\nInternal function to optimise an OWA JuMP model.\n\nInputs\n\nmodel: JuMP model.\n\nOutputs\n\nterm_status: JuMP termination status.\nsolvers_tried: Dictionary that contains a dictionary of failed optimisations. Dict(key => Dict(...)), where key is the solver key used for the iteration of solver that failed.\nIf an MOI call fails on a model:\nDict(:jump_error => jump_error): JuMP error code.\nIf the optimiser fails to optimise the model satisfactorily:\nDict(:objective_val => JuMP.objective_value(model), :term_status => term_status, :params => haskey(val, :params) ? val[:params] : missing), where val is the value of the dictionary corresponding to key.\n\n\n\n\n\n","category":"method"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/risk_measure_examples/#Risk-Measures","page":"Risk Measures","title":"Risk Measures","text":"","category":"section"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"This file contains the examples in the docstrings as runnable code.","category":"page"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"using PortfolioOptimiser, HiGHS, Clarabel, Pajarito, JuMP, StatsBase\n\n# Randomly generated normally distributed returns.\nret = [0.670643    1.94045   -0.0896267   0.851535    -0.268234\n       1.33575    -0.541003   2.28744    -0.157588    -1.45177\n       -1.91694    -0.167745   0.920495    0.00677243  -1.29112\n       0.123141    1.59841   -0.185076    2.58911     -0.250747\n       1.92782     1.01679    1.12107     1.09731     -0.99954\n       2.07114    -0.513216  -0.532891    0.917748    -0.0346682\n       -1.37424    -1.35272   -0.628216   -2.76234     -0.112378\n       1.3831      1.14021   -0.577472    0.224504     1.28137\n       -0.0577619  -0.10658   -0.637011    1.70933      1.84176\n       1.6319      2.05059   -0.21469    -0.640715     1.39879];\n\n# Instantiate portfolio instance.\nport = Portfolio(; ret = ret, assets = [:A, :B, :C, :D, :E],\n                 solvers = PortOptSolver(; name = :PClGL,\n                                         solver = optimizer_with_attributes(Pajarito.Optimizer,\n                                                                            \"verbose\" => false,\n                                                                            \"oa_solver\" => optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                                                     MOI.Silent() => true),\n                                                                            \"conic_solver\" => optimizer_with_attributes(Clarabel.Optimizer,\n                                                                                                                        \"verbose\" => false,\n                                                                                                                        \"max_step_fraction\" => 0.75))));\n\n# Compute asset statistics.\nasset_statistics!(port)\n# Clusterise assets (for hierarchical optimisations).\ncluster_assets!(port)","category":"page"},{"location":"examples/risk_measure_examples/#Variance,-[Variance](@ref)","page":"Risk Measures","title":"Variance, Variance","text":"","category":"section"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"# If `sigma` is not `nothing` it must be a square matrix. This works at instantiation and runtime.\ntry\n    Variance(; sigma = [1 0 0;\n                        0 2 3])\ncatch err\n    println(err)\nend\n\ntry\n    rm = Variance(;)\n    rm.sigma = [1 0 0;\n                0 2 3]\ncatch err\n    println(err)\nend\n\n# Default formulation.\nrm = Variance()\nw1 = optimise!(port, Trad(; rm = rm, str_names = true))\nr1 = expected_risk(port; rm = rm)\n# As a functor, we need to provide the covariance matrix to the risk measure directly.\nrm.sigma = port.cov\nisapprox(r1, rm(w1.weights))\n# The value of :variance_risk is consistent with the risk calculation.\nisapprox(r1, value(port.model[:variance_risk]))\n# The [`SecondOrderCone`](https://jump.dev/JuMP.jl/stable/tutorials/conic/tips_and_tricks/#Second-Order-Cone) constraint.\nport.model[:constr_dev_soc]\n# The variance risk.\nport.model[:variance_risk]\n# Variance risk is a [`QuadExpr`](https://jump.dev/JuMP.jl/stable/api/JuMP/#QuadExpr)\ntypeof(port.model[:variance_risk])\n\n# Incompatible with [`NOC`](@ref)\nw2 = optimise!(port, NOC(; rm = rm, str_names = true))\n\n# Quadratic formulation.\nrm = Variance(; formulation = Quad())\nw3 = optimise!(port, Trad(; rm = rm, str_names = true))\nport.model[:constr_dev_soc]\nport.model[:variance_risk]\n# Variance risk is a [`QuadExpr`](https://jump.dev/JuMP.jl/stable/api/JuMP/#QuadExpr)\ntypeof(port.model[:variance_risk])\n\n# Incompatible with [`NOC`](@ref)\nw4 = optimise!(port, NOC(; rm = rm, str_names = true))\n\n# If either `network_adj` or `cluster_adj` field of the [`Portfolio`](@ref) instance is [`SDP`](@ref), the formulation has no effect because this constraint type requires a [`PSDCone`](https://jump.dev/JuMP.jl/stable/tutorials/conic/tips_and_tricks/#Positive-Semidefinite-Cone) formulation of the variance.\n\nA = connection_matrix(port)\nB = cluster_matrix(port)\n\nport.cluster_adj = SDP(; A = B)\n\nrm = Variance()\nw5 = optimise!(port, Trad(; rm = rm, str_names = true))\nr5 = expected_risk(port; rm = rm)\nport.model[:constr_M_PSD]\nport.model[:variance_risk]\ntypeof(port.model[:variance_risk])\n\n# Compatible with [`NOC`](@ref)\nw6 = optimise!(port, NOC(; rm = rm, str_names = true))\n# The risk of the [`NOC`](@ref) optimisation is higher than the optimal value.\nr6 = expected_risk(port, :NOC; rm = rm)\nr5 <= r6\n\n# No adjacency constraints.\nport.cluster_adj = NoAdj()\n\n# Default formulation, with a variance upper bound of 10, standard deviaion of sqrt(10) = 3.1622776601683795.\nrm = Variance(; settings = RMSettings(; ub = 10))\nw7 = optimise!(port, Trad(; rm = rm, str_names = true))\n# dev <= sqrt(10)\nport.model[:dev_ub]\n\n# Quadratic formulation, with a variance upper bound of 10, standard deviaion of sqrt(10) = 3.1622776601683795.\nrm = Variance(; formulation = Quad(), settings = RMSettings(; ub = 10))\nw8 = optimise!(port, Trad(; rm = rm, str_names = true))\n# dev <= sqrt(10)\nport.model[:dev_ub]\n\n# We use an SDP constraint, this time on the network adjacency, to show that the formulation and risk upper bound change accordingly.\nport.network_adj = SDP(; A = A)\nrm = Variance(; formulation = Quad(), settings = RMSettings(; ub = 10))\nw9 = optimise!(port, Trad(; rm = rm, str_names = true))\nport.model[:constr_M_PSD]\nport.model[:variance_risk]\ntypeof(port.model[:variance_risk])\n# variance_risk <= 10\nport.model[:variance_risk_ub]\n\n# No adjacency constraints.\nport.network_adj = NoAdj()\n\n# Optimisations which use [`expected_risk`](@ref) to compute the risk have no [`JuMP`](https://github.com/jump-dev/JuMP.jl) model, therefore the formulation has no effect.\nw10 = optimise!(port, HRP(; rm = rm))","category":"page"},{"location":"examples/risk_measure_examples/#Standard-Deviation,-[SD](@ref)","page":"Risk Measures","title":"Standard Deviation, SD","text":"","category":"section"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"# If `sigma` is not `nothing` it must be a square matrix. This works at instantiation and runtime.\ntry\n    SD(; sigma = [1 0 0;\n                  0 2 3])\ncatch err\n    println(err)\nend\n\ntry\n    rm = SD(;)\n    rm.sigma = [1 0 0;\n                0 2 3]\ncatch err\n    println(err)\nend\n\n# Setting the standard deviation upper bound to 10 (it's so high it has no effect on the optimisation).\nrm = SD(; settings = RMSettings(; ub = 10))\nw1 = optimise!(port, Trad(; rm = rm, str_names = true))\nr1 = expected_risk(port; rm = rm)\n# As a functor, we need to provide the covariance matrix to the risk measure directly.\nrm.sigma = port.cov\nisapprox(r1, rm(w1.weights))\n# The value of :sd_risk is consistent with the risk calculation.\nisapprox(r1, value(port.model[:sd_risk]))\n# The [`SecondOrderCone`](https://jump.dev/JuMP.jl/stable/tutorials/conic/tips_and_tricks/#Second-Order-Cone) constraint.\nport.model[:constr_sd_risk_soc]\n# The variance risk.\nport.model[:sd_risk]\n# Variance risk is a [`VariableRef`](https://jump.dev/JuMP.jl/stable/api/JuMP/#VariableRef)\ntypeof(port.model[:sd_risk])\n# sd_risk <= 10\nport.model[:sd_risk_ub]\n\n# Optimisations which use [`expected_risk`](@ref) to compute the risk have no [`JuMP`](https://github.com/jump-dev/JuMP.jl) model.\nw2 = optimise!(port, HRP(; rm = rm))","category":"page"},{"location":"examples/risk_measure_examples/#Mean-Absolute-Deviation,-[MAD](@ref)","page":"Risk Measures","title":"Mean Absolute Deviation, MAD","text":"","category":"section"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"# Setting the mean absolute deviation upper bound to 10 (it's so high it has no effect on the optimisation).\nrm = MAD(; settings = RMSettings(; ub = 10))\nw1 = optimise!(port, Trad(; rm = rm, str_names = true))\nr1 = expected_risk(port; rm = rm)\n# As a functor.\nisapprox(r1, rm(port.returns, w1.weights))\n# The value of :mad_risk is consistent with the risk calculation.\nisapprox(r1, value(port.model[:mad_risk]))\n# MAD risk is a [`AffExpr`](https://jump.dev/JuMP.jl/stable/api/JuMP/#AffExpr)\ntypeof(port.model[:mad_risk])\n# mad_risk <= 10\nport.model[:mad_risk_ub]\n# `w` has no effect on the optimisation, but can lead to inconsistent values between the optimisation and functor.\new1 = eweights(1:size(port.returns, 1), 0.5; scale = true)\nrm = MAD(; w = ew1)\nw2 = optimise!(port, Trad(; rm = rm, str_names = true))\n# No effect int he optimisation.\nisequal(w1.weights, w2.weights)\n# Risk is not consistent with the one in `:mad_risk`, because `w` is not used in the optimisation.\nr2 = expected_risk(port; rm = rm)\nisapprox(r2, value(port.model[:mad_risk]))\n# In order to make them consistent, we can compute the value of `mu` using `w`.\nasset_statistics!(port; mu_type = MuSimple(; w = ew1))\nw3 = optimise!(port, Trad(; rm = rm, str_names = true))\nisapprox(w1.weights, w3.weights)\nr3 = expected_risk(port; rm = rm)\nisapprox(r3, value(port.model[:mad_risk]))\n# Alternatively we can provide this value of `mu` to the risk measure, which takes precedence over the value in `port`. We reset the asset statistics.\nrm = MAD(; mu = port.mu)\n# Reset the asset statistics to show that the value in `rm` takes precedence.\nasset_statistics!(port)\nw4 = optimise!(port, Trad(; rm = rm, str_names = true))\nr4 = expected_risk(port; rm = rm)\nisapprox(r4, value(port.model[:mad_risk]))\n# Using the value of `mu` leads to the same results as using the `w` used to compute it.\nisapprox(w3.weights, w4.weights)\nisapprox(r3, r4)\n# We can use a different weights vector for the expected value of the absolute deviations.\new2 = eweights(1:size(port.returns, 1), 0.7; scale = true)\nrm = MAD(; we = ew2)\nw5 = optimise!(port, Trad(; rm = rm, str_names = true))\nr5 = expected_risk(port; rm = rm)\nisapprox(r5, value(port.model[:mad_risk]))\n# We can use both.\nasset_statistics!(port; mu_type = MuSimple(; w = ew1))\nrm = MAD(; mu = port.mu, we = ew2)\nw6 = optimise!(port, Trad(; rm = rm, str_names = true))\nr6 = expected_risk(port; rm = rm)\nisapprox(r6, value(port.model[:mad_risk]))\n\n# Hierarchical optimisation\nasset_statistics!(port)\nrm = MAD()\nw6 = optimise!(port, HRP(; rm = rm))\nr6 = expected_risk(port; rm = rm)\n# Using `w`.\nrm = MAD(; w = ew1)\nw7 = optimise!(port, HRP(; rm = rm))\nr7 = expected_risk(port; rm = rm)\n# Using `mu` isntead.\nasset_statistics!(port; mu_type = MuSimple(; w = ew1))\nrm = MAD(; mu = port.mu)\nw8 = optimise!(port, HRP(; rm = rm))\nr8 = expected_risk(port; rm = rm)","category":"page"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"","category":"page"},{"location":"examples/risk_measure_examples/","page":"Risk Measures","title":"Risk Measures","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Optimisation/OptimisationGetZ/#Entropic-and-relativistic-moments","page":"Entropic and relativistic moments","title":"Entropic and relativistic moments","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/#Public","page":"Entropic and relativistic moments","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z-Tuple{Portfolio, Union{RiskMeasure, AbstractVector}}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z","text":"get_z(port::Portfolio, rm::Union{AbstractVector, <:RiskMeasure})\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#PortfolioOptimiser.get_z_from_model-Tuple{JuMP.Model, EVaR}","page":"Entropic and relativistic moments","title":"PortfolioOptimiser.get_z_from_model","text":"get_z_from_model(model::JuMP.Model, ::Union{EVaR, EDaR, RLVaR, RLDaR})\nget_z_from_model(model::JuMP.Model, ::Union{AbstractVector{<:EVaR}, EDaRAbstractVecto{<: ,} AbstractVector{<:RLVaR}, AbstractVector{<:RLDaR}})\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationGetZ/#Private","page":"Entropic and relativistic moments","title":"Private","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#Weight-constraints","page":"Weight constraints","title":"Weight constraints","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#Public","page":"Weight constraints","title":"Public","text":"","category":"section"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.asset_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.asset_constraints","text":"asset_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the linear constraint matrix A and vector B:\n\nmathbfA bmw geq bmB.\n\nInputs\n\nconstraints: Nc×10 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nSubset: whole class.\nAll Assets: all assets.\nAll Subsets: all asset classes.\nEach Asset in Subset: specific assets in a class.\nSet: (String) if Type is Subset, All Subsets or Each Asset in Subset, specifies the asset class set.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nRelative_Type: (String) specifies to what the constraint is relative:\nEmpty string: nothing.\nAsset: other asset.\nSubset: other class.\nRelative_Set: (String) if Relative_Type is Subset, specifies the name of the set of asset classes.\nRelative_Position: (String) name of the asset or asset class of the relative constraint.\nFactor: (<:Real) the factor of the relative constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nA: Nc×Na matrix of constraints where  and .\nB: Nc×1 vector of constraints where .\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\", \"FCN\",\n                                   \"TKO\", \"ZOO\", \"ZVO\", \"ZX\", \"ZZA\", \"ZZB\", \"ZZC\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\", \"Equity\", \"Equity\",\n                                     \"Equity\", \"Fixed Income\", \"Fixed Income\", \"Equity\",\n                                     \"Fixed Income\", \"Equity\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\", \"Financial\",\n                                     \"Entertainment\", \"Treasury\", \"Financial\", \"Financial\",\n                                     \"Entertainment\", \"Technology\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true, true, true, true,\n                                      true, true, true, true, true, true],\n                        \"Type\" => [\"Subset\", \"All Subsets\", \"Asset\", \"Asset\", \"Subset\",\n                                   \"All Assets\", \"Each Asset in Subset\", \"Asset\",\n                                   \"All Assets\", \"All Assets\", \"Subset\", \"All Subsets\",\n                                   \"All Subsets\", \"Each Asset in Subset\",\n                                   \"Each Asset in Subset\"],\n                        \"Set\" => [\"Class 1\", \"Class 1\", \"\", \"\", \"Class 2\", \"\", \"Class 1\",\n                                  \"Class 1\", \"Class 2\", \"\", \"Class 1\", \"Class 2\", \"Class 2\",\n                                  \"Class 2\", \"Class 1\"],\n                        \"Position\" => [\"Equity\", \"Fixed Income\", \"BAC\", \"WFC\", \"Financial\",\n                                       \"\", \"Equity\", \"FCN\", \"TKO\", \"ZOO\", \"Fixed Income\",\n                                       \"Treasury\", \"Entertainment\", \"Treasury\", \"Equity\"],\n                        \"Sign\" => [\"<=\", \"<=\", \"<=\", \"<=\", \">=\", \">=\", \">=\", \"<=\", \">=\",\n                                   \"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\"],\n                        \"Weight\" => [0.6, 0.5, 0.1, \"\", \"\", 0.02, \"\", \"\", \"\", \"\", \"\", \"\",\n                                     \"\", 0.27, \"\"],\n                        \"Relative_Type\" => [\"\", \"\", \"\", \"Asset\", \"Subset\", \"\", \"Asset\",\n                                            \"Subset\", \"Asset\", \"Subset\", \"Asset\", \"Asset\",\n                                            \"Subset\", \"\", \"Subset\"],\n                        \"Relative_Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"\", \"\", \"Class 1\", \"\",\n                                           \"Class 2\", \"\", \"Class 2\", \"Class 2\", \"\",\n                                           \"Class 2\"],\n                        \"Relative_Position\" => [\"\", \"\", \"\", \"FB\", \"Fixed Income\", \"\", \"TLT\",\n                                                \"Equity\", \"NTFX\", \"Financial\", \"WFC\", \"ZOO\",\n                                                \"Entertainment\", \"\", \"Entertainment\"],\n                        \"Factor\" => [\"\", \"\", \"\", 1.2, 0.5, \"\", 0.4, 0.7, 0.21, 0.11, 0.13,\n                                     -0.17, 0.23, \"\", -0.31])\nA, B = asset_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.calc_hc_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.calc_hc_constraints","text":"calc_hc_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\nCreate the upper and lower bounds constraints for hierarchical risk parity portfolios.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nType: (String) specifies the object(s) to which a constraint applies:\nAsset: specific asset.\nAll Assets: all assets.\nEach Asset in Subset: specific assets in a class.\nPosition: (String) name of the asset or asset class to which the constraint applies.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nWeight: (<:Real) value of the constraint.\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets.\n\nOutputs\n\nw_min: Na×1 vector of the lower bounds for asset weights.\nw_max: Na×1 vector of the upper bounds for asset weights.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true, true, true],\n                        \"Type\" => [\"Asset\", \"Asset\", \"All Assets\", \"All Assets\",\n                                   \"Each Asset in Subset\", \"Each Asset in Subset\"],\n                        \"Set\" => [\"\", \"\", \"\", \"\", \"Class 1\", \"Class 2\"],\n                        \"Position\" => [\"BAC\", \"FB\", \"\", \"\", \"Fixed Income\", \"Financial\"],\n                        \"Sign\" => [\">=\", \"<=\", \"<=\", \">=\", \"<=\", \"<=\"],\n                        \"Weight\" => [0.02, 0.085, 0.09, 0.01, 0.07, 0.06])\nw_min, w_max = calc_hc_constraints(constraints, asset_sets)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.calc_rb_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.calc_rb_constraints","text":"calc_rb_constraints(asset_sets::DataFrame; type::Symbol = :Asset,\n                    class_col::Union{String, Symbol, Nothing} = nothing)\n\nConstructs risk contribution constraint vector for the risk parity optimisation (:RB and :RRB types of PortTypes).\n\nInputs\n\nasset_sets: Na×D DataFrame where  and D the number of columns.\nAsset: list of assets, this is the only mandatory column.\nSubsequent columns specify the asset class sets. They are only used if type == :Subset.\nclass_col: index of set of classes from asset_sets to use in when type == :Subset.\n\nOutputs\n\nrw: risk contribution constraint vector.\n\nExamples\n\nasset_sets = DataFrame(\"Asset\" => [\"FB\", \"GOOGL\", \"NTFX\", \"BAC\", \"WFC\", \"TLT\", \"SHV\"],\n                       \"Class 1\" => [\"Equity\", \"Equity\", \"Equity\", \"Equity\", \"Equity\",\n                                     \"Fixed Income\", \"Fixed Income\"],\n                       \"Class 2\" => [\"Technology\", \"Technology\", \"Technology\", \"Financial\",\n                                     \"Financial\", \"Treasury\", \"Treasury\"])\n\nrw_a = calc_rb_constraints(asset_sets, :Asset)\nrw_c = calc_rb_constraints(asset_sets, :Subset, \"Class 2\")\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.factor_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.factor_constraints","text":"factor_constraints(constraints::DataFrame, loadings::DataFrame)\n\nCreate the factor constraints matrix C and vector D:\n\nmathbfC bmw geq bmD.\n\nInputs\n\nconstraints: Nc×4 Dataframe, where . The required columns are:\nEnabled: (Bool) indicates if the constraint is enabled.\nFactor: (String) name of the constraint's factor.\nSign: (String) specifies whether the constraint is a lower or upper bound:\n>=: lower bound.\n<=: upper bound.\nValue: (<:Real) the upper or lower bound of the factor's value.\nRelative_Factor: (String) factor to which the constraint is relative.\nloadings: Nl×Nf loadings DataFrame, where Nl is the number of data points, and .\n\nOutputs\n\nC: Nc×Nf matrix of constraints where  and .\nD: Nc×1 vector of constraints where .\n\nExamples\n\nloadings = DataFrame(\"const\" => [0.0004, 0.0002, 0.0000, 0.0006, 0.0001, 0.0003, -0.0003],\n                     \"MTUM\" => [0.1916, 1.0061, 0.8695, 1.9996, 0.0000, 0.0000, 0.0000],\n                     \"QUAL\" => [0.0000, 2.0129, 1.4301, 0.0000, 0.0000, 0.0000, 0.0000],\n                     \"SIZE\" => [0.0000, 0.0000, 0.0000, 0.4717, 0.0000, -0.1857, 0.0000],\n                     \"USMV\" => [-0.7838, -1.6439, -1.0176, -1.4407, 0.0055, 0.5781, 0.0000],\n                     \"VLUE\" => [1.4772, -0.7590, -0.4090, 0.0000, -0.0054, -0.4844, 0.9435])\nconstraints = DataFrame(\"Enabled\" => [true, true, true, true],\n                        \"Factor\" => [\"MTUM\", \"USMV\", \"VLUE\", \"const\"],\n                        \"Sign\" => [\"<=\", \"<=\", \">=\", \">=\"],\n                        \"Value\" => [0.9, -1.2, 0.3, -0.1],\n                        \"Relative_Factor\" => [\"USMV\", \"\", \"\", \"SIZE\"])\nC, D = factor_constraints(constraints, loadings)\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#PortfolioOptimiser.turnover_constraints-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Weight constraints","title":"PortfolioOptimiser.turnover_constraints","text":"turnover_constraints(constraints::DataFrame, asset_sets::DataFrame)\n\n\"Asset\"\n\"All Assets\"\n\"Each Asset in Subset\"\n\n\n\n\n\n","category":"method"},{"location":"Constraints/WeightConstraints/#Private","page":"Weight constraints","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Finalisation-functions","page":"Finalisation functions","title":"Finalisation functions","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Public","page":"Finalisation functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationFinalisation/#Private","page":"Finalisation functions","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures4-1/#Dispersion","page":"Dispersion","title":"Dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures4-1/","page":"Dispersion","title":"Dispersion","text":"These measure the spread of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures4-1/#PortfolioOptimiser.TCM","page":"Dispersion","title":"PortfolioOptimiser.TCM","text":"\n\n\n\n","category":"type"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/#Example-1:-Mean-Risk-Optimisation","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/#1.-Download-data.","page":"Example 1: Mean Risk Optimisation","title":"1. Download data.","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/#2.-Estimating-Mean-Risk-Portfolios","page":"Example 1: Mean Risk Optimisation","title":"2. Estimating Mean Risk Portfolios","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/#2.1.-Optimising-portfolio","page":"Example 1: Mean Risk Optimisation","title":"2.1. Optimising portfolio","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"For API details and options available see: Portfolio, PortOptSolver, PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, asset_statistics!, RiskMeasure, PortfolioOptimiser.ObjectiveFunction, PortfolioOptimiser.OptimType.","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices,\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n\n# Compute relevant statistics.\n# Expected returns and covariance estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\n\n# Only compute `mu` and `cov`.\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\n# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = MinRisk() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj)\n\n# Optimise portfolio.\nw1 = optimise!(port, type)\npretty_table(w1; formatters = fmt2)","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/#2.2.-Plotting-portfolio-composition.","page":"Example 1: Mean Risk Optimisation","title":"2.2. Plotting portfolio composition.","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"plot_bar(port)","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/#2.3.-Efficient-frontier","page":"Example 1: Mean Risk Optimisation","title":"2.3. Efficient frontier","text":"","category":"section"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"points = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt2)","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"Plot frontier.","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"plot_frontier(port; rm = rm)","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"Plot frontier area.","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"plot_frontier_area(port; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"","category":"page"},{"location":"examples/1_Mean_Risk_Optimisation/","page":"Example 1: Mean Risk Optimisation","title":"Example 1: Mean Risk Optimisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-2/#Specifics","page":"Specifics","title":"Specifics","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/","page":"Specifics","title":"Specifics","text":"This section details types, structures, and constants that play a supporting role in defining specific risk measures.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-2/#[RMOWA](@ref)","page":"Specifics","title":"RMOWA","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/","page":"Specifics","title":"Specifics","text":"Certain risk measures make use of Ordered Weight Array formulations in optimisations which use JuMP models. PortfolioOptimiser implements two formulations.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-2/","page":"Specifics","title":"Specifics","text":"An exact but expensive formulation.\nAn approximate, tunable one based on PowerCone constraints.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-2/","page":"Specifics","title":"Specifics","text":"We therefore provide a structure for dispatching the exact method, and a structure for tuning and dispatching the approximate one.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.OWAFormulation","page":"Specifics","title":"PortfolioOptimiser.OWAFormulation","text":"abstract type OWAFormulation end\n\nAbstract type for subtyping Ordered Weight Array formulations in optimisations which use JuMP models.\n\nSee also: OWAExact, OWAApprox, RiskMeasureOWA.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.OWAExact","page":"Specifics","title":"PortfolioOptimiser.OWAExact","text":"struct OWAExact <: OWAFormulation end\n\nType for dispatching the exact formulation of Ordered Weight Array risk measures.\n\nSee also: OWAApprox, RiskMeasureOWA.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.OWAApprox","page":"Specifics","title":"PortfolioOptimiser.OWAApprox","text":"mutable struct OWAApprox{T1 <: AbstractVector{<:Real}} <: OWAFormulation\n\nType for dispatching and tuning the approximate formulation of Ordered Weight Array risk measures.\n\nSee also: OWAExact, RiskMeasureOWA.\n\nKeyword Arguments\n\np::T1 = Float64[2, 3, 4, 10, 50]: vector of the p-norm orders to be used in the approximation.\n\nBehaviour\n\nUses PowerCone constraints.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#[Variance](@ref)-and-[SVariance](@ref)","page":"Specifics","title":"Variance & SVariance","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.VarianceFormulation","page":"Specifics","title":"PortfolioOptimiser.VarianceFormulation","text":"abstract type VarianceFormulation end\n\nAbstract type for implementing various formulations of the Variance and SVariance in optimisations which use JuMP models.\n\nVariance\n\nIf either network_adj or cluster_adj property of the Portfolio instance is SDP, the formulation has no effect because this constraint type requires a PSDCone formulation of the variance.\n\nSee also: Variance, Quad, SOC, Portfolio, SDP.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.Quad","page":"Specifics","title":"PortfolioOptimiser.Quad","text":"struct Quad <: VarianceFormulation end\n\nExplicit quadratic formulation for the Variance and SVariance as an optimisation model.\n\nSee also: VarianceFormulation, SOC, RSOC, Variance, SVariance.\n\nGeneral Behaviour\n\nNo additional variables or constraints introduced.\nPerformance may degrade for large portfolios.\n\nVariance\n\nbeginalign\nundersetbmwmathrmopt qquad bmw^intercal mathbfSigma bmw\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfSigma: is the N×N asset covariance matrix.\n\nBehaviour\n\nProduces a QuadExpr risk expression variance_risk = dot(w, sigma, w).\n\nExamples\n\nSVariance\n\nbeginalign\nundersetbmwmathrmopt qquad dfracbmy cdot bmyT-1nonumber\ntextrmst qquad bmy geq bm0nonumber\n               qquad (mathbfX - bmmu^intercal) bmw geq -bmy\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfX: is the T×N matrix of asset returns.\nbmmu: is the N×1 vector of expected returns.\nbmw: is the N×1 vector of asset weights.\nbmy: is the T×1 vector of deviations from the expected portfolio return that meets the minimum return threshold.\n\nBehaviour\n\nProduces a QuadExpr risk expression svariance_risk = dot(svariance, svariance)/(T-1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.SOC","page":"Specifics","title":"PortfolioOptimiser.SOC","text":"struct SOC <: VarianceFormulation end\n\nSecond-Order Cone (SOC) formulation for the Variance and SVariance. Formulates the quadratic variance/semi variance expression using a SecondOrderCone cone constraint.\n\nSee also: VarianceFormulation, Quad, RSOC, Variance, SVariance.\n\nGeneral Behaviour\n\nUses SecondOrderCone constraints.\nOften more numerically stable than direct quadratic formulation.\nBetter scaling properties for large portfolios.\nCompatible with specialised conic solvers.\nParticularly effective for large-scale problems.\n\nVariance\n\nbeginalign\nundersetbmwmathrmopt qquad sigma^2nonumber\ntextrmst qquad leftlVert mathbfG bmw rightrVert_2 leq sigma\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfG: is a suitable factorisation of the N×N covariance matrix, such as the square root matrix, or the Cholesky factorisation.\nsigma^2: is the portfolio variance.\nlVert cdot rVert_2: is the L-2 norm, which is modelled as an SecondOrderCone.\n\nBehaviour\n\nProduces a QuadExpr risk expression variance_risk = dev^2.\n\nExamples\n\nSVariance\n\nbeginalign\nundersetbmwmathrmopt qquad dfracv^2T-1nonumber\ntextrmst qquad bmy geq bm0nonumber\n               qquad (mathbfX - bmmu^intercal) bmw geq -bmynonumber\n               qquad (v bmy) in mathcalK_textrmsoc\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfX: is the T×N matrix of asset returns.\nbmmu: is the N×1 vector of expected returns.\nbmw: is the N×1 vector of asset weights.\nbmy: is the T×1 vector of deviations from the expected portfolio return that meets the minimum return threshold.\n\nBehaviour\n\nProduces a QuadExpr risk expression svariance_risk = sdev^2/(T-1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.RSOC","page":"Specifics","title":"PortfolioOptimiser.RSOC","text":"struct RSOC <: VarianceFormulation end\n\nRotated Second-Order Cone (RSOC) formulation for the Variance and SVariance. Formulates the quadratic variance/semi variance expression using a RotatedSecondOrderCone constraint.\n\nSee also: VarianceFormulation, Quad, SOC, Variance, SVariance.\n\nGeneral Behaviour\n\nUses SecondOrderCone constraints.\nUses RotatedSecondOrderCone constraints.\nCompatible with specialised conic solvers.\nPerformance may degrade for large portfolios.\n\nVariance\n\nbeginalign\nundersetbmwmathrmopt qquad dfracvT-1nonumber\ntextrmst qquad bmy = (mathbfX - bmmu^intercal) bmwnonumber\n               qquad (v 05 bmy) in mathcalK_textrmrsoc\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nbmv: is the portfolio variance.\nT: is the number of observations.\nbmy: is the T×1 vector of deviations from the expected portfolio return.\nbmmu: is the N×1 vector of expected asset returns.\nmathcalK_textrmrsoc: is the RotatedSecondOrderCone. Which in this formulation represents the sum of squares of a vector.\n\nBehaviour\n\nProduces a QuadExpr risk expression svariance_risk = tvariance/(T-1).\n\nwarning: Warning\nUsing w to compute the Variance risk of a portfolio optimised via an optimisation which uses JuMP, you have to ensure that the value of mu used by the optimisation is consistent with the value of w–-i.e. it was computed with MuSimple using w. Otherwise, the calculation will be inconsistent with the value of :svariance_risk. Alternatively, use the value of mu in both.\n\nExamples\n\nSVariance\n\nbeginalign\nundersetbmwmathrmopt qquad dfracvT-1nonumber\ntextrmst qquad bmy geq bm0nonumber\n               qquad (mathbfX - bmmu^intercal) bmw geq -bmynonumber\n               qquad (v 05 bmy) in mathcalK_textrmrsoc\nendalign\n\nWhere:\n\nbmw: is the N×1 vector of asset weights.\nmathbfX: is the T×N matrix of asset returns.\nbmmu: is the N×1 vector of expected returns.\nbmw: is the N×1 vector of asset weights.\nbmy: is the T×1 vector of deviations from the expected portfolio return that meets the minimum return threshold.\n\nBehaviour\n\nProduces a QuadExpr risk expression svariance_risk = tsvariance/(T-1).\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-2/#[RMMu](@ref)","page":"Specifics","title":"RMMu","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.calc_ret_mu","page":"Specifics","title":"PortfolioOptimiser.calc_ret_mu","text":"calc_ret_mu(x::AbstractVector, w::AbstractVector, rm::RMMu)\n\nComputes the mean portfolio return for rm.\n\nIf isnothing(rm.mu) || isempty(rm.mu), computes the mean return from x.\nIf isnothing(rm.w): computes the unweighted mean.\nElse: computes the weighted mean.\nElse: computes the mean return as dot(rm.mu, w).\n\nSee also: RMMu.\n\nPositional Arguments\n\nx: T×1 vector of portfolio returns.\nw: N×1 vector of asset weights.\nrm: RMMu risk measure.\n\nReturns\n\nmu::Real: portfolio mean return.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures1-2/#[RMTarget](@ref)","page":"Specifics","title":"RMTarget","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.calc_target_ret_mu","page":"Specifics","title":"PortfolioOptimiser.calc_target_ret_mu","text":"calc_target_ret_mu(x::AbstractVector, w::AbstractVector, rm::RMTarget)\n\nComputes the minimum acceptable portfolio return target for rm. Only returns equal to or below this value are accounted for in the calculation.\n\nIf isnothing(rm.target) || isa(rm.target, AbstractVector) && isempty(rm.target), computes the mean acceptable return from x via calc_ret_mu.\nElse: returns rm.target.\n\nSee also: RMTarget.\n\nPositional Arguments\n\nx: T×1 vector of portfolio returns.\nw: N×1 vector of asset weights.\nrm: RMTarget risk measure.\n\nReturns\n\ntarget::Real: minimum acceptable return target.\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures1-2/#[RMSolvers](@ref)","page":"Specifics","title":"RMSolvers","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.ERM","page":"Specifics","title":"PortfolioOptimiser.ERM","text":"ERM(x::AbstractVector{<:Real}, z::Real = 1.0, α::Real = 0.05)\n\nComputes the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX z alpha) = z ln left(dfracM_bmXleft(z^-1right)alpha right)\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nz: is the entropic moment.\nM_bmXleft(tright): is the moment generating function of bmX.\nalpha: is the significance parameter, alpha in (01).\n\nPositional Arguments\n\nx::AbstractVector: T×1 vector of portfolio returns.\nz::Real = 1.0: entropic moment.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n\n\n\n\nERM(x::AbstractVector{<:Real},\n         solvers::Union{PortOptSolver, <:AbstractVector{PortOptSolver}},\n         alpha::Real = 0.05)\n\nComputes the Entropic Risk Measure.\n\nbeginalign\nmathrmERM(bmX alpha) = \n    begincases\n        undersetz t uinf  t + z lnleft(dfrac1alpha Tright)\n        mathrmst  z geq sumlimits_i=1^T u_inonumber\n         (-X_i-t z u_i) in mathcalK_exp  forall  i=1dots T\n    endcases\n= undersetz0infleft z ln left(dfracM_bmXleft(z^-1right)alpha right)right\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance parameter, alpha in (01).\nz: is the entropic moment.\nt and bmu: are auxiliary variables for modelling the moment generating function.\nT: is the number of observations.\nX_i: is the i-th entry of the portfolio returns vector.\nM_bmXleft(tright): is the moment generating function of bmX.\nmathcalK_mathrmexp: is the ExponentialCone.\n\nSee also: EVaR, EDaR, EDaR_r, expected_risk.\n\nInputs\n\nx::AbstractVector: T×1 vector of portfolio returns.\nsolvers::Union{PortOptSolver, <:AbstractVector{PortOptSolver}}: instance or AbstractVector of PortOptSolver which supports ExponentialCone constraints.\nα::Real = 0.05: significance level, α ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα is not validated because this is an internal function. It should have been validated by EVaR, EDaR, or EDaR_r.\n\nOutputs\n\ner::Real: entropic risk.\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"RiskMeasures/RiskMeasures1-2/#PortfolioOptimiser.RRM","page":"Specifics","title":"PortfolioOptimiser.RRM","text":"RRM(x::AbstractVector, solvers::AbstractDict, α::Real = 0.05, κ::Real = 0.3)\n\nComputes the Relativistic Risk Measure.\n\nbeginalign\nmathrmRRM(Xalphakappa) = left\n    beginalign\n        undersetz t psi theta  varepsilon omegatextinf  t + z ln_kappa left(dfrac1alpha Tright) + sumlimits_i=1^T left(psi_i + theta_i  right) nonumber\n        mathrmst  -X  - t + varepsilon + omega leq 0 nonumber\n        z geq 0 \n        left( zleft(dfrac1+kappa2kapparight) psi_ileft(dfrac1+kappakapparight) varepsilon_i right) in mathcalP_3^1(1+kappa) kappa(1+kappa)nonumber\n        left( omega_ileft(dfrac11-kapparight) theta_ileft(dfrac1kapparight) -z left(dfrac12kapparight) right) in mathcalP_3^1-kappa kappanonumber\n        forall  i=1dots T nonumber\n    endalign\nright\nendalign\n\nWhere:\n\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance parameter, alpha in (01).\nkappa: is the relativistic deformation parameter, kappa in (01).\nz: is the relativistic moment.\nt, psi, theta, varepsilon, and omega: are auxiliary variables for modelling the relativistic deformation of the moment generating function.\nT: is the number of observations.\nmathcalP_3^c 1-c: is the PowerCone parametrised by c in (01).\n\nSee also: RLVaR, RLDaR, RLDaR_r, expected_risk.\n\nInputs\n\nx::AbstractVector: T×1 vector of portfolio returns.\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}}: instance or AbstractVector of PortOptSolver which supports ExponentialCone constraints.\nα::Real = 0.05: significance level, α ∈ (0, 1).\nκ::Real = 0.3: relativistic deformation parameter, κ ∈ (0, 1).\n\nBehaviour\n\nIf no valid solution is found returns NaN.\n\nwarning: Warning\nα and κ are not validated because this is an internal function. They should have been validated by RLVaR, RLDaR, or RLDaR_r.\n\nOutputs\n\nrlr::Real: relativistic risk.\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#Example-2:-Mean-Risk-Optimisation-with-Linear-Asset-Weight-Constraints","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#1.-Download-data.","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"1. Download data.","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#2.-Estimating-Mean-Risk-Portfolios","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"2. Estimating Mean Risk Portfolios","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#2.1.-Optimising-portfolio","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"2.1. Optimising portfolio","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"For API details and options available see: Portfolio, PortOptSolver, PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, asset_statistics!, RiskMeasure, PortfolioOptimiser.ObjectiveFunction, PortfolioOptimiser.OptimType.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices,\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n\n# Compute relevant statistics.\n# Expected returns and covariance estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\n\n# Only compute `mu` and `cov`.\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\n# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = MinRisk() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj)\n\n# Optimise portfolio.\nw1 = optimise!(port, type)\npretty_table(w1; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#2.2.-Plotting-portfolio-composition.","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"2.2. Plotting portfolio composition.","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#3.-Asset-and-asset-set-constraints","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"3. Asset and asset set constraints","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#3.1.-Creating-the-constraints","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"3.1. Creating the constraints","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"The function asset_constraints takes in two dataframes, one defining the asset sets, and another defining the constraints and turns them into a matrix and vector which sets the constraints as mathbfA bmx = bmb.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"asset_sets = DataFrame(;\n                       Asset = [\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\",\n                                \"COST\", \"CSCO\", \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\",\n                                \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\", \"NFLX\", \"NVDA\", \"ORLY\",\n                                \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\", \"VRTX\"],\n                       Sector = [\"Technology\", \"Technology\", \"Technology\", \"Health Care\",\n                                 \"Consumer Discretionary\", \"Consumer Discretionary\",\n                                 \"Telecommunications\", \"Consumer Discretionary\",\n                                 \"Telecommunications\", \"Health Care\", \"Technology\",\n                                 \"Technology\", \"Industrials\", \"Health Care\", \"Industrials\",\n                                 \"Consumer Discretionary\", \"Technology\", \"Health Care\",\n                                 \"Technology\", \"Consumer Discretionary\", \"Technology\",\n                                 \"Consumer Discretionary\", \"Technology\", \"Technology\",\n                                 \"Consumer Discretionary\", \"Telecommunications\",\n                                 \"Telecommunications\", \"Consumer Discretionary\",\n                                 \"Technology\", \"Health Care\"],\n                       Industry = [\"Computer Manufacturing\", \"Semiconductors\",\n                                   \"EDP Services\",\n                                   \"Biotechnology: Biological Products (No Diagnostic Substances)\",\n                                   \"Catalog/Specialty Distribution\",\n                                   \"Transportation Services\",\n                                   \"Cable & Other Pay Television Services\",\n                                   \"Department/Specialty Retail Stores\",\n                                   \"Computer Communications Equipment\",\n                                   \"Biotechnology: Biological Products (No Diagnostic Substances)\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Aerospace\", \"Industrial Specialties\", \"Major Chemicals\",\n                                   \"Hotels/Resorts\",\n                                   \"Computer Software: Programming Data Processing\",\n                                   \"Biotechnology: Pharmaceutical Preparations\",\n                                   \"Computer Software: Prepackaged Software\",\n                                   \"Consumer Electronics/Video Chains\", \"Semiconductors\",\n                                   \"Auto & Home Supply Stores\",\n                                   \"Computer peripheral equipment\",\n                                   \"Radio And Television Broadcasting And Communications Equipment\",\n                                   \"Restaurants\", \"Telecommunications Equipment\",\n                                   \"Telecommunications Equipment\", \"Auto Manufacturing\",\n                                   \"Semiconductors\",\n                                   \"Biotechnology: Pharmaceutical Preparations\"])\npretty_table(asset_sets)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"We will create different sets of constraints because it makes demonstrations easier.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"It's also worth noting that constraints may make problems infeasable, for example constraining all N assets to have weights greater than 1/(N-1), or it may be impossible to simultaneously satisfy multiple constraints, for example constraining all assets to have weights greater than or equal to 0.1, and requiring one asset to have a weight smaller than or equal to 0.05.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Constrain individual assets.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"constraints_1 = DataFrame(; Enabled = [true, true, true, true, true, true],\n                          Type = [\"Asset\", \"Asset\", \"Asset\", \"Asset\", \"Asset\", \"Asset\"],\n                          Set = [\"\", \"\", \"\", \"\", \"\", \"\"],\n                          Position = [\"COST\", \"AAPL\", \"ADP\", \"T\", \"GILD\", \"GOOG\"],\n                          Sign = [\"<=\", \">=\", \"<=\", \">=\", \"<=\", \">=\"],\n                          Weight = [0.13, 0.04, \"\", \"\", \"\", \"\"],\n                          Relative_Type = [\"\", \"\", \"Asset\", \"Asset\", \"Subset\", \"Subset\"],\n                          Relative_Set = [\"\", \"\", \"\", \"\", \"Sector\", \"Industry\"],\n                          Relative_Position = [\"\", \"\", \"MAR\", \"MRK\", \"Telecommunications\",\n                                               \"Telecommunications Equipment\"],\n                          Factor = [\"\", \"\", 2, 0.7, 0.3, 1])\npretty_table(constraints_1)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"A1, B1 = asset_constraints(constraints_1, asset_sets)\n\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A1\nport.b_ineq = B1\n\nw2 = optimise!(port, type)\npretty_table(w2; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Constrain all assets.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"constraints_2 = DataFrame(; Enabled = [true, true, true, true, true, true],\n                          Type = [\"All Assets\", \"All Assets\", \"All Assets\", \"All Assets\",\n                                  \"All Assets\", \"All Assets\"],\n                          Set = [\"\", \"\", \"\", \"\", \"\", \"\"],\n                          Position = [\"\", \"\", \"\", \"\", \"\", \"\"],\n                          Sign = [\">=\", \"<=\", \">=\", \"<=\", \">=\", \"<=\"],\n                          Weight = [0.01, 0.2, \"\", \"\", \"\", \"\"],\n                          Relative_Type = [\"\", \"\", \"Subset\", \"Subset\", \"Asset\", \"Asset\"],\n                          Relative_Set = [\"\", \"\", \"Sector\", \"Industry\", \"\", \"\"],\n                          Relative_Position = [\"\", \"\", \"Consumer Discretionary\",\n                                               \"Biotechnology: Pharmaceutical Preparations\",\n                                               \"TMUS\", \"META\"],\n                          Factor = [\"\", \"\", 0.1, 2.1, 0.5, 1.3])\npretty_table(constraints_2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"A2, B2 = asset_constraints(constraints_2, asset_sets)\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A2\nport.b_ineq = B2\n\nw3 = optimise!(port, type)\npretty_table(w3; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Constrain asset sets.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"constraints_3 = DataFrame(; Enabled = [true, true, true, true, true, true],\n                          Type = [\"Subset\", \"Subset\", \"Subset\", \"Subset\", \"Subset\",\n                                  \"Subset\"],\n                          Set = [\"Sector\", \"Sector\", \"Sector\", \"Industry\", \"Industry\",\n                                 \"Industry\"],\n                          Position = [\"Technology\", \"Consumer Discretionary\", \"Health Care\",\n                                      \"Semiconductors\",\n                                      \"Biotechnology: Pharmaceutical Preparations\",\n                                      \"Biotechnology: Biological Products (No Diagnostic Substances)\"],\n                          Sign = [\">=\", \"<=\", \"<=\", \">=\", \"<=\", \">=\"],\n                          Weight = [0.13, 0.25, \"\", \"\", \"\", \"\"],\n                          Relative_Type = [\"\", \"\", \"Asset\", \"Asset\", \"Subset\", \"Subset\"],\n                          Relative_Set = [\"\", \"\", \"\", \"\", \"Sector\", \"Industry\"],\n                          Relative_Position = [\"\", \"\", \"MAR\", \"MRK\", \"Telecommunications\",\n                                               \"Telecommunications Equipment\"],\n                          Factor = [\"\", \"\", 2, 0.7, 0.1, 0.3])\npretty_table(constraints_3)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"A3, B3 = asset_constraints(constraints_3, asset_sets)\n\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A3\nport.b_ineq = B3\n\nw4 = optimise!(port, type)\npretty_table(w4; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Constrain all asset subsets.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"constraints_4 = DataFrame(; Enabled = [true, true, true],\n                          Type = [\"All Subsets\", \"All Subsets\", \"All Subsets\"],\n                          Set = [\"Industry\", \"Industry\", \"Sector\"], Position = [\"\", \"\", \"\"],\n                          Sign = [\">=\", \">=\", \"<=\"], Weight = [0.01, \"\", \"\"],\n                          Relative_Type = [\"\", \"Asset\", \"Subset\"],\n                          Relative_Set = [\"\", \"\", \"Industry\"],\n                          Relative_Position = [\"\", \"T\", \"Semiconductors\"],\n                          Factor = [\"\", 0.7, 1.3])\npretty_table(constraints_4)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"A4, B4 = asset_constraints(constraints_4, asset_sets)\n\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A4\nport.b_ineq = B4\n\nw5 = optimise!(port, type)\npretty_table(w5; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Constrain each asset in subset.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"constraints_5 = DataFrame(; Enabled = [true, true, true],\n                          Type = [\"Each Asset in Subset\", \"Each Asset in Subset\",\n                                  \"Each Asset in Subset\"],\n                          Set = [\"Sector\", \"Industry\", \"Sector\"],\n                          Position = [\"Telecommunications\",\n                                      \"Biotechnology: Biological Products (No Diagnostic Substances)\",\n                                      \"Consumer Discretionary\"], Sign = [\">=\", \">=\", \"<=\"],\n                          Weight = [0.03, \"\", \"\"], Relative_Type = [\"\", \"Asset\", \"Subset\"],\n                          Relative_Set = [\"\", \"\", \"Industry\"],\n                          Relative_Position = [\"\", \"T\", \"Semiconductors\"],\n                          Factor = [\"\", 0.7, 1.3])\npretty_table(constraints_5)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"A5, B5 = asset_constraints(constraints_5, asset_sets)\n\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A5\nport.b_ineq = B5\n\nw6 = optimise!(port, type)\npretty_table(w6; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_bar(port)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/#4.-Efficient-Frontier","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"4. Efficient Frontier","text":"","category":"section"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"It's possible to compute the efficient frontier with constraints. It will be different to the vanilla one in the previous tutorial because the constraints will be applied to every optimisation.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"port.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A2\nport.b_ineq = B2\n\npoints = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt2)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Plot frontier.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_frontier(port; rm = rm)","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"Plot frontier area.","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"plot_frontier_area(port; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"","category":"page"},{"location":"examples/2_Mean_Risk_Optimisation_Linear_Asset_Weight_Constraints/","page":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","title":"Example 2: Mean Risk Optimisation with Linear Asset Weight Constraints","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Optimisation/OptimisationReturns/#Returns","page":"Returns","title":"Returns","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/#Public","page":"Returns","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationReturns/#Private","page":"Returns","title":"Private","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#Example-7:-Near-Optimal-Centering-(NOC)-Mean-Risk-Optimisation","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#1.-Download-data.","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"1. Download data.","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#2.-Estimating-NOC-Mean-Risk-Portfolios","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"2. Estimating NOC Mean Risk Portfolios","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#2.1.-Optimising-portfolio","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"2.1. Optimising portfolio","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"NOC optimisations are only compatible with optimisations whose risk measures are AffExpr because QuadExpr are not strictly convex.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"For API details and options available see: Portfolio, PortOptSolver, PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, asset_statistics!, RiskMeasure, PortfolioOptimiser.ObjectiveFunction, PortfolioOptimiser.OptimType, NOC.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices,\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         check_sol = (allow_local = true,\n                                                      allow_almost = true),\n                                         params = Dict(\"verbose\" => false,\n                                                       \"max_step_fraction\" => 0.65)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n\n# Compute relevant statistics.\n# Expected returns and covariance estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\n\n# Only compute `mu` and `cov`.\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"The Near Optimal Centering (NOC) formulation has the curious property that maximising the risk-adjusted ratio will not, in fact, maximise the risk-adjusted ratio. It finds the analytical centre of the neighbourhood around a point on the efficient frontier, which in this case is the point which maximises the risk-adjusted return ratio. This makes it possible to create near-optimal portfolios with higher risk-adjusted return ratios. Such portfolios are not the centre of the analytic region of the portfolio with the highest risk-adjusted return ratio, they are the centre of a different analytic region around a different point of the efficient frontier. It's possible that such points can have higher risk-adjusted return ratios.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"In fact, the NOC portfolio which maximises the risk-adjusted return ratio, is the point of minimum risk of a region of the NOC efficient frontier with relatively high risk-adjusted returns.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"By defining larger analytic regions (using fewer bins), the more portfolios will exist with greater risk-adjusted return ratios than the canonical NOC maximum risk-adjusted return ratio portfolio.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"bins → ∞: the NOC portfolio converges to the optimal portfolio.\nbins → 0: the NOC portfolio converges to the equal weight portfolio.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"You can verify for yourself by changing the value of bins above and re-running the script. Note how the maximum risk-adjusted return portfolio migrates further down the NOC frontier as bins decreases, and how there are more portfolios with higher risk-adjusted return rations.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\nbins = 20 ## Number of bins for defining the analytic region.\n# `NOC` optimisation corresponds to the near optimal mean risk optimisation.\ntype = NOC(; rm = rm, obj = obj, bins = bins)\n\n# Optimise portfolio.\nw1 = optimise!(port, type)\npretty_table(w1; formatters = fmt2)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#2.2.-Plotting-portfolio-composition.","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"2.2. Plotting portfolio composition.","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"plot_bar(port, :NOC)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/#2.3.-Efficient-frontier","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"2.3. Efficient frontier","text":"","category":"section"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"points = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt2)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"Plot frontier.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"plot_frontier(port, :NOC; rm = rm)","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"Plot frontier area.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"plot_frontier_area(port, :NOC; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"We want to see how the canonical maximum risk-adjusted return ratio portfolio stacks up against other portfolios with greater risk-adjusted return ratios. We can do so using the frontier variable.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"Frist, we check if the frontier contains the portfolio which maximises the risk-adjusted return ratio (the optimisation can fail in efficient_frontier! so we should always check if it succeeded), there is a flag :sharpe which is true if the optimisation succeeded. The maximum risk-adjusted ratio optimisation is performed last, so its statistics and weights will correspond to the last ones in their respective containers.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"We will display them at the start to make it easier to see the behaviour described in 2.1. We annualise the risk, return, and risk-adjusted return ratio to make comparisons easier.","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"# Check if the maximum risk-adjusted return ratio optimisation succeeded\nif frontier[:sharpe]\n    # Optimisations can fail in [`efficient_frontier!`](@ref) so we need to find out how many actually succeeded.\n    N = length(frontier[:sharpes])\n    # Find all points in the efficient frontier with an actual sharpe ratio higher than the canonical one.\n    idx = findall(frontier[:sharpes] .> frontier[:sharpes][end])\n    # Add the index of the max risk-adjusted return ratio portfolio at the start.\n    idx = [N; idx]\n    # Display the anualised returns and risks of the canonical max risk-adjusted return ratio portfolio (the first in the table) as well as all others whose ratios are greater. The first row contains the canonical portfolio.\n    pretty_table(DataFrame(:idx => idx, :rets => frontier[:rets][idx] * 252,\n                           :risks => frontier[:risks][idx] * sqrt(252),\n                           :sharpes => frontier[:sharpes][idx] * sqrt(252));\n                 formatters = fmt2)\n    # Display their weights. The first column displays the canonical portfolio.\n    pretty_table(frontier[:weights][!, [1; (idx .+ 1)]]; formatters = fmt2)\nend","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"","category":"page"},{"location":"examples/7_Near_Optimal_Centering_Mean_Risk_Optimisation/","page":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","title":"Example 7: Near Optimal Centering (NOC) Mean Risk Optimisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ParameterEstimation/CovCorKurtSkew/#Covariance,-correlation,-cokurtosis-and-coskewness","page":"Covariance, correlation, cokurtosis and coskewness","title":"Covariance, correlation, cokurtosis and coskewness","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#Public","page":"Covariance, correlation, cokurtosis and coskewness","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorKendall","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorKendall","text":"@kwdef mutable struct CorKendall <: CorRank\n    absolute::Bool = false\nend\n\nKendall type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corkendall(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorSpearman","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorSpearman","text":"@kwdef mutable struct CorSpearman <: CorRank\n    absolute::Bool = false\nend\n\nSpearman type correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(corspearman(X)).\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovDistance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovDistance","text":"mutable struct CovDistance <: PortfolioOptimiserCovCor\n    distance::Distances.Metric\n    dist_args::Tuple\n    dist_kwargs::NamedTuple\n    mean_w1::Union{<:AbstractWeights, Nothing}\n    mean_w2::Union{<:AbstractWeights, Nothing}\n    mean_w3::Union{<:AbstractWeights, Nothing}\nend\n\nDistance covariance and correlation matrix estimator.\n\nParameters\n\ndistance: distance metric from Distances.jl.\ndist_args: args for the Distances.pairwise function of Distances.jl.\ndist_kwargs: kwargs for the Distances.pairwise function of Distances.jl.\nmean_w1: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its rows (dims = 1).\nmean_w2: optional T×1 vector of weights for computing the mean of the pairwise distance matrices along its columns (dims = 2).\nmean_w3: optional T×1 vector of weights for computing the mean of the entirety of the pairwise distance matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovFull","text":"@kwdef mutable struct CovFull <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nFull Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber0","text":"@kwdef mutable struct CovGerber0{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber1","text":"@kwdef mutable struct CovGerber1{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber2","text":"@kwdef mutable struct CovGerber2{T1 <: Real} <: CovGerberBasic\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nGerber type 2 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nOnly used when normalise == true:\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Gerber type 2 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB0","text":"@kwdef mutable struct CovGerberSB0{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification with vote counting of the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB1","text":"@kwdef mutable struct CovGerberSB1{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification with vote counting of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification with vote counting of the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB2","text":"mutable struct CovGerberSB2{T1, T2, T3, T4, T5} <: CovSB\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovLTD","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovLTD","text":"mutable struct CovLTD <: PortfolioOptimiserCovCor\n    alpha::Real\n    ve::StatsBase.CovarianceEstimator\n    w::Union{<:AbstractWeights, Nothing}\nend\n\nLower tail dependence correlation and covariance matrix estimator.\n\nParameters\n\nalpha: significance level of the lower tail dependence, alpha ∈ (0, 1).\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovMutualInfo","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovMutualInfo","text":"@kwdef mutable struct CovMutualInfo <: PortfolioOptimiserCovCor\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nMutual information correlation matrix estimator.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\nOnly used when computing covariance matrices:\nve: variance estimator StatsBase.CovarianceEstimator.\nw: optional T×1 vector of weights for computing the variance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB0","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB0","text":"@kwdef mutable struct CovSB0{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 0 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification of the Gerber type 0 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB1","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB1","text":"@kwdef mutable struct CovSB1{T1, T2, T3, T4, T5} <: CovSB\n    normalise::Bool = false\n    threshold::T1 = 0.5\n    c1::T2 = 0.5\n    c2::T3 = 0.5\n    c3::T4 = 4.0\n    n::T5 = 2.0\n    ve::StatsBase.CovarianceEstimator = SimpleVariance()\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    posdef::AbstractPosdefFix = PosdefNearest()\nend\n\nSmyth-Broby modification of the Gerber type 1 covariance and correlation matrices.\n\nParameters\n\nnormalise:\nif true: Z-normalise the data before applying the Gerber criteria.\nthreshold: Gerber significance threshold, threshold ∈ (0, 1).\nc1: confusion zone threshold (c_1 in the paper), c1 ∈ (0, 1].\nc2: indecision zone threshold (c_2 in the paper), c2 ∈ (0, 1].\nc3: large co-movement threshold (4 in the paper).\nn: exponent of the regularisation term (n = 2 in the paper).\nve: variance estimator StatsBase.CovarianceEstimator.\nstd_w: optional T×1 vector of weights for computing the variance.\nmean_w: optional T×1 vector of weights for computing the mean.\nposdef: type for fixing the Smyth-Broby modification of the Gerber type 1 correaltion matrix AbstractPosdefFix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB2","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB2","text":"CovSB2{T1, T2, T3, T4, T5} <: CovSB\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSemi","text":"@kwdef mutable struct CovSemi <: CorPearson\n    absolute::Bool = false\n    ce::StatsBase.CovarianceEstimator = StatsBase.SimpleCovariance(; corrected = true)\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSemi Pearson-type covariance and correlation estimator.\n\nParameters\n\nabsolute:\nif true: compute an absolute correlation, abs.(cor(X)).\nce: covariance estimator.\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nw: optional T×1 vector of weights for computing the covariance.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtFull","text":"@kwdef mutable struct KurtFull <: KurtEstimator\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nFull cokurtosis estimator.\n\nParameters\n\nposdef: type for fixing non a positive definite cokurtosis matrix AbstractPosdefFix.\ndenoise: type for denoising the cokurtosis matrix AbstractDenoise.\nlogo: type for computing the LoGo cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtSemi","text":"@kwdef mutable struct KurtSemi <: KurtEstimator\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\nposdef: type for fixing non a positive definite semi cokurtosis matrix AbstractPosdefFix.\ndenoise: type for denoising the semi cokurtosis matrix AbstractDenoise.\nlogo: type for computing the LoGo semi cokurtosis matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortCovCor","text":"@kwdef mutable struct PortCovCor <: PortfolioOptimiserCovCor\n    ce::CovarianceEstimator = CovFull(;)\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    denoise::AbstractDenoise = NoDenoise(;)\n    logo::AbstractLoGo = NoLoGo(;)\nend\n\nPortfolioOptimiser covariance and correlation estimator.\n\nParameters\n\nce: covariance estimator.\nposdef: type for fixing the portfolio covariance or correlation matrix AbstractPosdefFix.\ndenoise: type for denoising the portfolio covariance or correlation matrix AbstractDenoise.\nlogo: type for computing the LoGo portfolio covariance or correlation matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SimpleVariance","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SimpleVariance","text":"@kwdef mutable struct SimpleVariance <: StatsBase.CovarianceEstimator\n    corrected::Bool = true\nend\n\nSimple variance estimator.\n\nParameters\n\ncorrected:\nif true: correct the bias dividing by N-1 instead of N.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewFull","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewFull","text":"struct SkewFull <: SkewEstimator end\n\nFull cokurtosis estimator.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewSemi","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewSemi","text":"@kwdef mutable struct SkewSemi <: SkewEstimator\nend\n\nSemi cokurtosis estimator.\n\nParameters\n\ntarget: minimum return threshold for classifying downside returns.\nif isa(target, Real): apply the same target to all assets.\nif isa(target, AbstractVector): apply individual target to each asset.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewFull, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(::SkewFull, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.coskew-Tuple{SkewSemi, AbstractMatrix, AbstractVector}","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.coskew","text":"coskew(se::SkewSemi, X::AbstractMatrix, mu::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/CovCorKurtSkew/#Private","page":"Covariance, correlation, cokurtosis and coskewness","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PosdefFixCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PosdefFixCovCor","text":"const PosdefFixCovCor = Union{<:CovGerber, PortCovCor}\n\nCovariance and correlation estimators that support positive definite fixes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.AbstractCustomMtxProcess","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.AbstractCustomMtxProcess","text":"    abstract type AbstractCustomMtxProcess end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorPearson","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorPearson","text":"abstract type CorPearson <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Pearson type covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CorRank","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CorRank","text":"abstract type CorRank <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping rank based covariance estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerber","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerber","text":"abstract type CovGerber <: PortfolioOptimiserCovCor end\n\nAbstract type for subtyping Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberBasic","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberBasic","text":"abstract type CovGerberBasic <: CovGerber end\n\nAbstract type for subtyping the original Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovGerberSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovGerberSB","text":"abstract type CovSB <: CovGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications with vote counting of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.CovSB","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.CovSB","text":"abstract type CovSB <: CovGerber end\n\nAbstract type for subtyping the Smyth-Broby modifications of Gerber type covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.KurtEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.KurtEstimator","text":"abstract type KurtEstimator end\n\nAbstract type for subtyping cokurtosis estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.PortfolioOptimiserCovCor","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.PortfolioOptimiserCovCor","text":"abstract type PortfolioOptimiserCovCor <: StatsBase.CovarianceEstimator end\n\nAbstract type for subtyping portfolio covariance and correlation estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/CovCorKurtSkew/#PortfolioOptimiser.SkewEstimator","page":"Covariance, correlation, cokurtosis and coskewness","title":"PortfolioOptimiser.SkewEstimator","text":"abstract type SkewEstimator end\n\nAbstract type for subtyping coskew estimators.\n\n\n\n\n\n","category":"type"},{"location":"PlotsExtension/#Plots-extension","page":"Plots Extension","title":"Plots extension","text":"","category":"section"},{"location":"PlotsExtension/#Public","page":"Plots Extension","title":"Public","text":"","category":"section"},{"location":"PlotsExtension/#Private","page":"Plots Extension","title":"Private","text":"","category":"section"},{"location":"PlotsExtension/#PortfolioOptimiser.plot_returns-NTuple{4, Any}","page":"Plots Extension","title":"PortfolioOptimiser.plot_returns","text":"plot_returns(timestamps, assets, returns, weights; per_asset = false, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#Example-4:-Mean-Risk-Optimisation-with-Factor-Models-with-Linear-Factor-Constraints","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#1.-Download-data.","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"1. Download data.","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP, GLM\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v, digits=5))\" : v\n    end\nend;\nfmt3 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=4)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n# Factor tickers.\nfactors = sort!([\"MTUM\", \"QUAL\", \"SIZE\", \"USMV\", \"VLUE\", \"LRGF\", \"INTF\", \"GLOF\", \"EFAV\",\n                 \"EEMV\"])\n\ntickers = [assets; factors]\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(tickers; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(tickers))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#2.-Estimating-Mean-Risk-Portfolios","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"2. Estimating Mean Risk Portfolios","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#2.1.-Factor-and-asset-statistics","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"2.1. Factor and asset statistics","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"In order to use factor models, we need to estimate how the factors and assets are related. The relationships are summarised by the loadings matrix, which is obtained via regression. For this basic tutorial we will use the defaults.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, FactorType, asset_statistics!, factor_statistics!.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices[Symbol.(assets)], f_prices = prices[Symbol.(factors)],\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n# Compute relevant statistics.\n# Expected returns, covariance estimation and factor estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\nfactor_type = FactorType()\n\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nfactor_statistics!(port; factor_type = factor_type, cov_type = cov_type, mu_type = mu_type)\n\n# Show the loadings matrix.\npretty_table(port.loadings; formatters = fmt2)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#2.2.-Optimise-Portfolios","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"2.2. Optimise Portfolios","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\nclass = FM()\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj, class = class)\n# Classic portfolio.\nw1 = optimise!(port, type)\n# Factor model portfolio.\npretty_table(w1; formatters = fmt3)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#3.-Factor-constraints","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"3. Factor constraints","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#3.1.-Creating-the-constraints","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"3.1. Creating the constraints","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"The function factor_constraints takes in two dataframes, one defining the constraints, and the loadings matrix and turns them into a matrix and vector which sets the constraints as mathbfA bmx = bmb.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"First lets check out the loadings matrix in order to create feasable constraints.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"pretty_table(describe(port.loadings); formatters = fmt3)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"Constrain factors.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"constraints = DataFrame(; Enabled = [true, true, true, true],\n                        Factor = [\"SIZE\", \"QUAL\", \"USMV\", \"MTUM\"],\n                        Sign = [\">=\", \">=\", \"<=\", \">=\"], Value = [0.2, 0.6, -0.7, 0.45],\n                        Relative_Factor = [\"\", \"LRGF\", \"\", \"\"])\npretty_table(constraints)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"Create linear constraint matrix and vector and optimise with these constraints.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"A1, B1 = factor_constraints(constraints, port.loadings)\n\n# Clear the arrays because the code asserts the dimensions.\nport.a_ineq = Matrix(undef, 0, 0)\nport.b_ineq = Vector(undef, 0)\nport.a_ineq = A1\nport.b_ineq = B1\n\nw2 = optimise!(port, type)\npretty_table(w2; formatters = fmt3)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"In order to verify that the constraints have been held, we can perform a regression.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"# Add constant term.\nX = [ones(size(port.fm_returns, 1)) port.f_returns]\n# Portfolio returns according to the factor model.\ny = port.fm_returns * w2.weights\n# Generalised linear model linking the portfolio returns to the factors in X.\nres = GLM.lm(X, y)\n# Generate dataframe with the factors and their regression coefficients.\ndf = DataFrame(; :factors => [\"const\"; factors], :coefs => coef(res))\npretty_table(df; formatters = fmt3)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"We can see that the constraints hold.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"Factor Constraint Value\nSIZE SIZE >= 0.2 0.395261 >= 0.2\nQUAL LRGF - QUAL >= 0.6 1.106847 - 0.506847 = 0.6 >= 0.6\nUSMV USMV <= -0.7 -0.75905 <= -0.7\nMTUM MTUM >= 0.45 0.45 >= 0.45","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/#3.2.-Efficient-Frontier","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"3.2. Efficient Frontier","text":"","category":"section"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"We can plot the efficient frontier for the factor model. Which will look different factor model one because the constraints will have to be satisfied at every point.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"points = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt3)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"Plot frontier.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"plot_frontier(port; rm = rm)","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"Plot frontier area.","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"plot_frontier_area(port; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"","category":"page"},{"location":"examples/4_Mean_Risk_Optimisation_Factor_Models_Linear_Factor_Constraints/","page":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","title":"Example 4: Mean Risk Optimisation with Factor Models with Linear Factor Constraints","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-4/#Drawdown","page":"Drawdown","title":"Drawdown","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/","page":"Drawdown","title":"Drawdown","text":"These measure the drops in portfolio value from local maxima to subsequent local minima.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-4/#Maximum-Drawdown-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Maximum Drawdown of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.MDD","page":"Drawdown","title":"PortfolioOptimiser.MDD","text":"struct MDD <: RiskMeasure\n\nMeasures and computes the portfolio Maximum Drawdown of uncompounded cumulative returns (MDD). It measures the largest peak-to-trough decline. Best used in combination with other risk measures. The risk-adjusted return ratio of this risk measure is commonly known as the Calmar ratio.\n\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmMDD_a(bmX) = maxmathrmDD_a(bmX)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX) is the Drawdown of uncompounded cumulative returns as defined in DaR.\nbmX: is the T×1 vector of portfolio returns.\n\nSee also: RiskMeasure, RMSettings, Portfolio, DaR, CDaR, EDaR, RLDaR, DaR_r, CDaR_r, EDaR_r, RLDaR_r, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): risk measure configuration settings.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe MDD is defined as an AffExpr with the key, :mdd_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :mdd_risk_ub.\n\nFunctor\n\n(mdd::MDD)(x::AbstractVector): computes the MDD of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-4/#Average-Drawdown-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Average Drawdown of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.ADD","page":"Drawdown","title":"PortfolioOptimiser.ADD","text":"struct ADD <: RiskMeasure\n\nMeasures and computes the portfolio Average (Expected) Drawdown of uncompounded cumulative returns (ADD). This is a generalisation to accomodate the use of weighted means.\n\nbeginalign\nmathrmADD_a(bmX) = mathbbElleft(mathrmDD_a(bmX j)forall j=1ldotsTright)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\nT: is the number of observations.\nbmX: is the T×1 vector of portfolio returns.\n\nSee also: RiskMeasure, RMSettings, Portfolio, DaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nw::Union{<:AbstractWeights, Nothing} = nothing: optional T×1 vector of weights for computing the expected value of the returns vector.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe ADD is defined as an AffExpr with the key, :add_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :add_risk_ub.\n\nFunctor\n\n(add::ADD)(x::AbstractVector): computes the ADD of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-4/#Ulcer-Index-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Ulcer Index of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.UCI","page":"Drawdown","title":"PortfolioOptimiser.UCI","text":"mutable struct UCI <: RiskMeasure\n\nMeasures and computes the portfolio Ulcer Index of uncompounded cumulative returns (UCI). It is the normalised L2-norm of the portfolio drawdowns of uncompounded cumulative returns.\n\nbeginalign\nmathrmUCI_a(bmX) = left(dfrac1T sumlimits_j=0^T mathrmDD_a(bmX j)^2right)^12\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\nbmX: is the T×1 vector of portfolio returns.\n\nSee also: RiskMeasure, RMSettings, Portfolio, DaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe UCI is defined as an AffExpr with the key, :uci_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :uci_risk_ub.\n\nFunctor\n\n(uci::UCI)(x::AbstractVector): computes the UCI of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-4/#Conditional-Drawdown-at-Risk-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Conditional Drawdown at Risk of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.CDaR","page":"Drawdown","title":"PortfolioOptimiser.CDaR","text":"mutable struct CDaR{T1 <: Real} <: RiskMeasure\n\nMeasures and computes the portfolio Conditional Drawdown at Risk of uncompounded cumulative returns (CDaR). It is the weighted average of all drawdowns up to the Drawdown at Risk, which is the threshold below or equal to which are the worst alpha % of portfolio drawdowns.\n\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmCDaR_a(bmX alpha) = mathrmDaR_a(bmX alpha) + dfrac1alpha T sumlimits_j=0^T maxleft(mathrmDD_a(bmX j) - mathrmDaR_a(bmX alpha) 0 right)\nendalign\n\nWhere:\n\nmathrmDD_a(bmX j) is the Drawdown of uncompounded cumulative returns at time j as defined in DaR.\nmathrmDaR_a(bmX alpha) is the Drawdown at Risk of uncompounded cumulative returns as defined in DaR.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\nT: is the number of observations.\n\nSee also: RiskMeasure, RMSettings, Portfolio, DaR, MDD, EDaR, RLDaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe CDaR is defined as an AffExpr with the key, :cdar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :cdar_risk_ub.\n\nFunctor\n\n(cdar::CDaR)(x::AbstractVector): computes the CDaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-4/#Entropic-Drawdown-at-Risk-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Entropic Drawdown at Risk of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.EDaR","page":"Drawdown","title":"PortfolioOptimiser.EDaR","text":"mutable struct EDaR{T1 <: Real} <: RiskMeasureSolvers\n\nMeasures and computes the portfolio Entropic Drawdown at Risk of uncompounded cumulative returns (EDaR). It is the upper bound of the Chernoff inequality for the DaR and CDaR.\n\nUses ExponentialCone constraints.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\n\nbeginalign\nmathrmEDaR_a(bmXalpha) = undersetz  0inf leftmathrmERM(mathrmDD_a(bmX) z alpha)right\nendalign\n\nWhere:\n\nmathrmERM(mathrmDD_a(bmX) z alpha) is the Entropic Risk Measure as defined in ERM, using the Drawdown of uncompounded cumulative returns as defined in DaR.\nz: is the entropic drawdown at risk.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\n\nSee also: RiskMeasureSolvers, RMSettings, Portfolio, DaR, MDD, CDaR, RLDaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}} = nothing: optional abstract dictionary containing the solvers, their settings, solution criteria, and other arguments.\nIf isnothing(solvers): it takes its value from the solvers property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe EDaR is defined as an AffExpr with the key, :edar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :edar_risk_ub.\n\nFunctor\n\n(edar::EDaR)(x::AbstractVector): computes the EDaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-4/#Relativistic-Drawdown-at-Risk-of-Uncompounded-Cumulative-Returns","page":"Drawdown","title":"Relativistic Drawdown at Risk of Uncompounded Cumulative Returns","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-4/#PortfolioOptimiser.RLDaR","page":"Drawdown","title":"PortfolioOptimiser.RLDaR","text":"mutable struct RLDaR{T1 <: Real, T2 <: Real} <: RiskMeasureSolvers\n\nMeasures and computes the portfolio Relativistic Drawdown at Risk of uncompounded cumulative returns (RLDaR). It is a generalisation of the EDaR.\n\nUses PowerCone constraints.\nmathrmDaR(bmX alpha) leq mathrmCDaR(bmX alpha) leq mathrmEDaR(bmX alpha) leq mathrmRLDaR(bmX alpha kappa) leq mathrmMDD(bmX).\nlimlimits_kappa to 0 mathrmRLDaR(bmX alpha kappa) approx mathrmEDaR(bmX alpha)\nlimlimits_kappa to 1 mathrmRLDaR(bmX alpha kappa) approx mathrmMDD(bmX)\n\nbeginalign\nmathrmRLDaR_a(bmX alpha kappa) = mathrmRRM(mathrmDD_a(bmX) alpha kappa)\nendalign\n\nWhere:\n\nmathrmRRM(mathrmDD_a(bmX) alpha kappa) is the Relativistic Risk Measure as defined in RRM, using the Drawdown of uncompounded cumulative returns as defined in DaR.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level.\nkappa: is the relativistic deformation parameter.\n\nSee also: RiskMeasureSolvers, RMSettings, Portfolio, VaR, WR, CVaR, EVaR, expected_risk, optimise!, set_rm.\n\nKeyword Arguments\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\nkappa::T1 = 0.3: relativistic deformation level, kappa ∈ (0, 1).\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}} = nothing: optional abstract dictionary containing the solvers, their settings, solution criteria, and other arguments.\nIf isnothing(solvers): it takes its value from the solvers property of the instance of Portfolio.\n\nBehaviour in optimisations which take risk measures and use JuMP models\n\nThe RLDaR is defined as an AffExpr with the key, :rldar_risk.\nIf it exists, the upper bound is defined via the portfolio variance with the key, :rldar_risk_ub.\n\nFunctor\n\n(rldar::RLDaR)(x::AbstractVector): computes the RLDaR of a T×1 vector of portfolio returns x.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#Asset-allocation","page":"Asset allocation","title":"Asset allocation","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#Public","page":"Asset allocation","title":"Public","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.LP","page":"Asset allocation","title":"PortfolioOptimiser.LP","text":"struct LP <: AllocationType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.allocate!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Asset allocation","title":"PortfolioOptimiser.allocate!","text":"allocate!(port::AbstractPortfolio;\n                   type::Symbol = isa(port, Portfolio) ? :Trad : :HRP,\n                   type::AllocationType = LP(), latest_prices = port.latest_prices,\n                   investment::Real = 1e6, \n                   string_names::Bool = false)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/AssetAllocation/#Private","page":"Asset allocation","title":"Private","text":"","category":"section"},{"location":"Optimisation/AssetAllocation/#PortfolioOptimiser.roundmult-Tuple{Any, Any, Vararg{Any}}","page":"Asset allocation","title":"PortfolioOptimiser.roundmult","text":"roundmult(val, prec [, args...] [; kwargs...])\n\nRound a number to a multiple of prec. Uses the same defaults and has the same args and kwargs of the built-in Base.round.\n\nEquivalent to:\n\nround(div(val, prec) * prec, args...; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Regression","page":"Regression","title":"Regression","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#Public","page":"Regression","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AIC","page":"Regression","title":"PortfolioOptimiser.AIC","text":"struct AIC <: MinValStepwiseRegressionCriteria end\n\nAkaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AICC","page":"Regression","title":"PortfolioOptimiser.AICC","text":"struct AICC <: MinValStepwiseRegressionCriteria end\n\nCorrected Akaike's Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.AdjRSq","page":"Regression","title":"PortfolioOptimiser.AdjRSq","text":"struct AdjRSq <: MaxValStepwiseRegressionCriteria end\n\nAdjusted R² for a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BIC","page":"Regression","title":"PortfolioOptimiser.BIC","text":"struct BIC <: MinValStepwiseRegressionCriteria end\n\nBayesian Information Criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.BReg","page":"Regression","title":"PortfolioOptimiser.BReg","text":"@kwdef mutable struct BReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nBackward stepwise regression. Starts by assuming all features are significant and uses criterion to remove the worst performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FReg","page":"Regression","title":"PortfolioOptimiser.FReg","text":"@kwdef mutable struct FReg <: StepwiseRegression\n    criterion::StepwiseRegressionCriteria = PVal(;)\nend\n\nForward stepwise regression. Starts by assuming no factor is significant and uses criterion to add the best performing one each iteration.\n\nParameters\n\ncriterion: criterion for feature selection.\nisa(criterion, PVal): when no asset meets the selecion criterion, the list of significant features can be empty, in such cases the best factor is added to the list.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.FactorType","page":"Regression","title":"PortfolioOptimiser.FactorType","text":"@kwdef mutable struct FactorType\n    error::Bool = true\n    B::Union{Nothing, DataFrame} = nothing\n    type::RegressionType = FReg(;)\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    var_w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCAReg","page":"Regression","title":"PortfolioOptimiser.PCAReg","text":"@kwdef mutable struct PCAReg <: DimensionReductionRegression\n    ve::StatsBase.CovarianceEstimator = SimpleVariance(;)\n    std_w::Union{<:AbstractWeights, Nothing} = nothing\n    mean_w::Union{<:AbstractWeights, Nothing} = nothing\n    target::DimensionReductionTarget = PCATarget(;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PCATarget","page":"Regression","title":"PortfolioOptimiser.PCATarget","text":"@kwdef mutable struct PCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PPCATarget","page":"Regression","title":"PortfolioOptimiser.PPCATarget","text":"@kwdef mutable struct PPCATarget <: DimensionReductionTarget\n    kwargs::NamedTuple = (;)\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.PVal","page":"Regression","title":"PortfolioOptimiser.PVal","text":"@kwdef mutable struct PVal{T1 <: Real} <: StepwiseRegressionCriteria\n    threshold::T1 = 0.05\nend\n\nP-value as feature selection criterion.\n\nParameters\n\nthreshold: threshold for classifying significant p-values. Only features whose p-values are lower than threshold are considered significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RSq","page":"Regression","title":"PortfolioOptimiser.RSq","text":"struct RSq <: MaxValStepwiseRegressionCriteria end\n\nR² of a linear model criterion.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.loadings_matrix","page":"Regression","title":"PortfolioOptimiser.loadings_matrix","text":"loadings_matrix(x::DataFrame, y::DataFrame, type::RegressionType = FReg())\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.regression-Tuple{PCAReg, DataFrames.DataFrame, DataFrames.DataFrame}","page":"Regression","title":"PortfolioOptimiser.regression","text":"regression(type::PCAReg, x::DataFrame, y::DataFrame)\n\nDescription\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Regression/#Private","page":"Regression","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionRegression","page":"Regression","title":"PortfolioOptimiser.DimensionReductionRegression","text":"abstract type DimensionReductionRegression <: RegressionType end\n\nAbstract type for subtyping dimensionality reduction regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.DimensionReductionTarget","page":"Regression","title":"PortfolioOptimiser.DimensionReductionTarget","text":"abstract type DimensionReductionTarget end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MaxValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MaxValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where larger values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.MinValStepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.MinValStepwiseRegressionCriteria","text":"abstract type MinValStepwiseRegressionCriteria <: StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria where smaller values are more significant.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.RegressionType","page":"Regression","title":"PortfolioOptimiser.RegressionType","text":"abstract type RegressionType end\n\nAbstract type for subtyping regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegression","page":"Regression","title":"PortfolioOptimiser.StepwiseRegression","text":"abstract type StepwiseRegression <: RegressionType end\n\nAbstract type for subtyping stepwise regression types for computing the loadings matrix in loadings_matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Regression/#PortfolioOptimiser.StepwiseRegressionCriteria","page":"Regression","title":"PortfolioOptimiser.StepwiseRegressionCriteria","text":"abstract type StepwiseRegressionCriteria end\n\nAbstract type for subtyping selection criteria for selecting significant features when using StepwiseRegression types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#Expected-returns","page":"Expected returns","title":"Expected returns","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#Public","page":"Expected returns","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.GM","page":"Expected returns","title":"PortfolioOptimiser.GM","text":"struct GM <: MeanTarget end\n\nGrand mean target.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MSE","page":"Expected returns","title":"PortfolioOptimiser.MSE","text":"struct MSE <: MeanTarget end\n\nMean square error of sample mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBOP","page":"Expected returns","title":"PortfolioOptimiser.MuBOP","text":"@kwdef mutable struct MuBOP <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBodnar-Okhrin-Parolya [8] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuBS","page":"Expected returns","title":"PortfolioOptimiser.MuBS","text":"@kwdef mutable struct MuBS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nBayes-Stein [9] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuEquil","page":"Expected returns","title":"PortfolioOptimiser.MuEquil","text":"mutable struct MuEquil{T1} <: MeanSigmaEstimator\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuJS","page":"Expected returns","title":"PortfolioOptimiser.MuJS","text":"@kwdef mutable struct MuJS <: MeanSigmaEstimator\n    target::MeanTarget = GM()\n    w::Union{<:AbstractWeights, Nothing} = nothing\n    sigma::Union{<:AbstractMatrix, Nothing} = nothing\nend\n\nJames-Stein [10, 11] expected returns vector estimator.\n\nParameters\n\ntarget: correction target for the estimator.\nw: optional T×1 vector of weights for computing the simple expected returns vector.\nsigma: value of the covariance matrix used for correcting the simple expected returns vector.\nif computing with asset_statistics! and isnothing(sigma): use the covariance matrix computed by .\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MuSimple","page":"Expected returns","title":"PortfolioOptimiser.MuSimple","text":"@kwdef mutable struct MuSimple <: MeanEstimator\n    w::Union{<:AbstractWeights, Nothing} = nothing\nend\n\nSimple expected returns vector estimator.\n\nParameters\n\nw: optional T×1 vector of weights for computing the expected returns vector.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.VW","page":"Expected returns","title":"PortfolioOptimiser.VW","text":"struct VW <: MeanTarget end\n\nVolatility-weighted grand mean.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.target_mean-Tuple{GM, AbstractVector, AbstractMatrix, Any, Integer, Integer}","page":"Expected returns","title":"PortfolioOptimiser.target_mean","text":"target_mean(::GM, mu::AbstractVector, sigma::AbstractMatrix, inv_sigma, T::Integer,\n                     N::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/MeanEstimators/#Private","page":"Expected returns","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanEstimator","text":"abstract type MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanSigmaEstimator","page":"Expected returns","title":"PortfolioOptimiser.MeanSigmaEstimator","text":"abstract type MeanSigmaEstimator <: MeanEstimator end\n\nAbstract type for subtyping expected returns vectors estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/MeanEstimators/#PortfolioOptimiser.MeanTarget","page":"Expected returns","title":"PortfolioOptimiser.MeanTarget","text":"abstract type MeanTarget end\n\nAbstract type for subtyping correction targets of expected returns estimators that use covariance matrices for their corrections.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Worst-case-mean-variance-sets","page":"Worst case mean variance sets","title":"Worst case mean variance sets","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#Public","page":"Worst case mean variance sets","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.ArchWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.ArchWC","text":"@kwdef mutable struct ArchWC{T1 <: Integer, T2 <: Integer, T3 <: Real} <: WorstCaseType\n    bootstrap::WorstCaseArchType = StationaryBS()\n    n_sim::T1 = 3_000\n    block_size::T2 = 3\n    q::T3 = 0.05\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.CircularBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.CircularBS","text":"struct CircularBS <: WorstCaseArchType end\n\nCircular block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.DeltaWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.DeltaWC","text":"@kwdef mutable struct DeltaWC{T1 <: Real, T2 <: Real} <: WorstCaseType\n    dcov::T1 = 0.1\n    dmu::T2 = 0.1\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KGeneralWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KGeneralWC","text":"struct KGeneralWC <: WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.KNormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.KNormalWC","text":"struct KNormalWC <: WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.MovingBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.MovingBS","text":"struct MovingBS <: WorstCaseArchType end\n\nMoving block bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NormalWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NormalWC","text":"@kwdef mutable struct NormalWC{T1 <: Integer, T2 <: Real} <: WorstCaseType\n    n_sim::T1 = 3_000\n    q::T2 = 0.05\n    rng::AbstractRNG = Random.default_rng()\n    seed::Union{<:Integer, Nothing} = nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.StationaryBS","page":"Worst case mean variance sets","title":"PortfolioOptimiser.StationaryBS","text":"struct StationaryBS <: WorstCaseArchType end\n\nStationary bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCType","text":"@kwdef mutable struct WCType\n    cov_type::PortfolioOptimiserCovCor = PortCovCor(;)\n    mu_type::MeanEstimator = MuSimple(;)\n    box::WorstCaseType = NormalWC(;)\n    ellipse::WorstCaseType = NormalWC(;)\n    k_sigma::Union{<:Real, WorstCaseKType} = KNormalWC(;)\n    k_mu::Union{<:Real, WorstCaseKType} = KNormalWC(;)\n    posdef::AbstractPosdefFix = PosdefNearest(;)\n    diagonal::Bool = false\nend\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseSet","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseSet","text":"abstract type WorstCaseSet end\n\nAbstract type for subtyping worst case mean variance set types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Box","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Box","text":"struct Box <: WCSetMuSigma end\n\nBox sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.Ellipse","page":"Worst case mean variance sets","title":"PortfolioOptimiser.Ellipse","text":"struct Ellipse <: WCSetMuSigma end\n\nElliptical sets for worst case mean variance optimisation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.NoWC","page":"Worst case mean variance sets","title":"PortfolioOptimiser.NoWC","text":"@kwdef mutable struct NoWC <: WorstCaseSet\n    formulation::VarianceFormulation = SOC()\nend\n\nUse no set for worst case mean variance optimisation.\n\nParameters\n\nformulation: quadratic expression formulation of SD risk measure to use VarianceFormulation.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#Private","page":"Worst case mean variance sets","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCSetMuSigma","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCSetMuSigma","text":"\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WCSetMu","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WCSetMu","text":"\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseArchType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseArchType","text":"abstract type WorstCaseArchType <: WorstCaseType end\n\nAbstract type for subtyping types for computing worst case mean variance for bootstrapping with arch.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseKType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseKType","text":"abstract type WorstCaseKType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/WorstCase/#PortfolioOptimiser.WorstCaseType","page":"Worst case mean variance sets","title":"PortfolioOptimiser.WorstCaseType","text":"abstract type WorstCaseType end\n\nAbstract type for subtyping types for computing worst case mean variance sets.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#Optimisation-kinds","page":"Optimisation kinds","title":"Optimisation kinds","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#Public","page":"Optimisation kinds","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.BasicRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.BasicRRB","text":"struct BasicRRB <: RRBVersion end\n\nBasic relaxed risk budget optimisation version.\n\nSee also: RRBVersion, RRB.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HERC","page":"Optimisation kinds","title":"PortfolioOptimiser.HERC","text":"struct HERC <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HRP","page":"Optimisation kinds","title":"PortfolioOptimiser.HRP","text":"struct HRP <: HCOptimType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NCO","page":"Optimisation kinds","title":"PortfolioOptimiser.NCO","text":"mutable struct NCO <: HCOptimType\n    internal::NCOArgs\n    external::NCOArgs\n    finaliser::HCOptWeightFinaliser\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.NOC","page":"Optimisation kinds","title":"PortfolioOptimiser.NOC","text":"mutable struct NOC{T1, T2, T3, T4, T5, T6, T7, T8} <: OptimType\n\nNear optimal centering optimisation type. This type of optimisation defines a near-optimal convex region around a point in the efficient frontier, and finds the portfolio which best fits the analytic centre of the region.\n\nSee also: OptimType, RiskMeasure, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nflag::Bool = true:\nbins::T1 = 20.0 where T1 <: Real:\nw_opt::T2 = Vector{Float64}(undef, 0) where T2 <: AbstractVector{<:Real}: Vector of weights of the efficient frontier portfolio.\nw_min::T3 = Vector{Float64}(undef, 0) where T3 <: AbstractVector{<:Real}: Vector of weights of the minimal risk portfolio.\nw_max::T4 = Vector{Float64}(undef, 0) where T4 <: AbstractVector{<:Real}: Vector of weights of the maxumal return portfolio.\nw_opt_ini::T6 = Vector{Float64}(undef, 0) where T6 <: AbstractVector{<:Real}: The initial weights of the efficient frontier portfolio optimisation.\nIrrelevant if the solver does not support them.\nw_min_ini::T6 = Vector{Float64}(undef, 0) where T6 <: AbstractVector{<:Real}: The initial weights of the minimum risk optimisation.\nIrrelevant if the solver does not support them.\nw_max_ini::T7 = Vector{Float64}(undef, 0) where T7 <: AbstractVector{<:Real}: The initial weights of the maximum return optimisation.\nIrrelevant if the solver does not support them.\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nobj::ObjectiveFunction = MinRisk():\nkelly::RetType = NoKelly():\nclass::PortClass = Classic():\nw_ini::T8 = Vector{Float64}(undef, 0) where T8 <: AbstractVector{<:Real}: The initial weights for the optimisation of the near optimal centering portfolio.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RB","page":"Optimisation kinds","title":"PortfolioOptimiser.RB","text":"mutable struct RB{T1} <: OptimType\n\nRisk budget optimisation type. Allows the user to specify a risk budget vector specifying the maximum risk contribution per asset or factor. The asset weights are then optimised to meet the risk budget per asset/factor as optimally as possible.\n\nSee also: OptimType, RiskMeasure, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\nExamples\n\n# Default constructor.\nopt_type = RB()\n\n# Single risk measure.\nopt_type = RB(; rm = SD())\n\n# Multiple risk measures.\nopt_type = RB(; rm = [Variance(), CVaR(; alpha = 0.15)])\n\n# Incorrect use of multiple risk measures of the same type.\n# This will produce a JuMP registration error when optimise! is called.\nopt_type = RB(; rm = [CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures of the same type.\nopt_type = RB(; rm = [[CVaR(), CVaR(; alpha = 0.2)]])\n\n# Incorrect use of multiple risk measures, some of the same type.\n# This will produce a JuMP registration error regarding the CVaR\n# risk measure when optimise! is called.\nopt_type = RB(; rm = [MAD(), CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures, some of the same type.\nopt_type = RB(; rm = [MAD(), [CVaR(), CVaR(; alpha = 0.2)]])\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RRB","text":"mutable struct RRB{T1} <: OptimType\n\nThe relaxed risk budget optimisation only applies to the variance risk measure.\n\nSee also: OptimType, RRBVersion, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nversion::RRBVersion = BasicRRB(): Relaxed risk budget optimisation version.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegPenRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RegPenRRB","text":"mutable struct RegPenRRB{T1} <: RRBVersion\n\nRelaxed risk budget optimisation version with regularisation and penalty.\n\nSee also: RRBVersion, RRB.\n\nKeyword Parameters\n\npenalty::Real = 1.0: The penalty to be used.\n\nExamples\n\n# Default constructor.\nrrb_ver = RegPenRRB()\n\n# Custom penalty.\nrrb_ver = RegPenRRB(; penalty = 0.5)\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RegRRB","page":"Optimisation kinds","title":"PortfolioOptimiser.RegRRB","text":"struct RegRRB <: RRBVersion end\n\nRelaxed risk budget optimisation version with regularisation.\n\nSee also: RRBVersion, RRB.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarLogSumExp","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarLogSumExp","text":"mutable struct ScalarLogSumExp{T1 <: Real} <: AbstractScalarisation end\n\nScalarises the risk measures as the logsumexp of the weighted risk measures.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = frac1gamma log left( sum_i = 1^N exp(gamma r_i w_i) right)\nendalign\n\nWhere:\n\nr is the scalarised risk.\nr_i is the i-th risk measure.\nw_i is the weight of the i-th risk measure.\ngamma is a parameter that controls the shape of the scalarisation.\n\nKeyword Parameters\n\ngamma::Real = 1.0: gamma > 0. As gamma → 0, the scalarisation approaches ScalarSum. As gamma → Inf, the scalarisation approaches ScalarMax.\n\nExamples\n\n# Default constructor.\nscalariser = ScalarLogSumExp()\n\n# Approximate ScalarSum()\nscalariser = ScalarLogSumExp(; gamma = 1e-6)\n\n# Approximate ScalarMax()\nscalariser = ScalarLogSumExp(; gamma = 1e6)\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarMax","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarMax","text":"struct ScalarMax <: AbstractScalarisation end\n\nScalarises the risk measures by taking the maximum of them.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = max left( bmr odot bmw right)\nendalign\n\nWhere:\n\nr is the scalarised risk.\nbmr is the vector of risk measures.\nbmw is the corresponding vector of risk measure weights.\nodot is the Hadamard (element-wise) multiplication.\n\nExamples\n\nscalariser = ScalarMax()\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.ScalarSum","page":"Optimisation kinds","title":"PortfolioOptimiser.ScalarSum","text":"struct ScalarSum <: AbstractScalarisation end\n\nScalarises the risk measures as a weighted sum.\n\nSee also: AbstractScalarisation.\n\nbeginalign\n    r = bmr cdot bmw\nendalign\n\nWhere:\n\nr is the scalarised risk.\nbmr is the vector of risk measures.\nbmw is the corresponding vector of risk measure weights\ncdot is the dot product.\n\nExamples\n\nscalariser = ScalarSum()\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.SchurHRP","page":"Optimisation kinds","title":"PortfolioOptimiser.SchurHRP","text":"mutable struct SchurHRP <: HCOptimType\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.Trad","page":"Optimisation kinds","title":"PortfolioOptimiser.Trad","text":"mutable struct Trad{T1} <: OptimType\n\nTraditional optimisation type.\n\nSee also: OptimType, RiskMeasure, ObjectiveFunction, RetType, PortClass, CustomConstraint, CustomObjective, AbstractScalarisation.\n\nKeyword Parameters\n\nrm::Union{AbstractVector, <:RiskMeasure} = Variance(): The risk measure(s) to be used.\nIf multiple instances of the same risk measure are used, they must be grouped in a single vector wrapped in another vector, see examples.\nobj::ObjectiveFunction = MinRisk(): The objective function to be used.\nkelly::RetType = NoKelly(): The Kelly criterion to be used.\nclass::PortClass = Classic(): The portfolio class to be used.\nw_ini::T1 = Vector{Float64}(undef, 0) where T1 <: AbstractVector: The initial weights for the optimisation.\nIrrelevant if the solver does not support them.\ncustom_constr::CustomConstraint = NoCustomConstraint(): Add custom constraints to the optimisation problem.\ncustom_obj::CustomObjective = NoCustomObjective(): Add custom terms to the objective function.\nscalarisation::AbstractScalarisation = ScalarSum(): The scalarisation function to be used.\nOnly relevant when multiple risk measures are used.\nstr_names::Bool = false: Whether to use string names in the JuMP model.\n\nExamples\n\n# Default constructor.\nopt_type = Trad()\n\n# Single risk measure.\nopt_type = Trad(; rm = SD())\n\n# Multiple risk measures.\nopt_type = Trad(; rm = [Variance(), CVaR(; alpha = 0.15)])\n\n# Incorrect use of multiple risk measures of the same type.\n# This will produce a JuMP registration error when optimise! is called.\nopt_type = Trad(; rm = [CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures of the same type.\nopt_type = Trad(; rm = [[CVaR(), CVaR(; alpha = 0.2)]])\n\n# Incorrect use of multiple risk measures, some of the same type.\n# This will produce a JuMP registration error regarding the CVaR\n# risk measure when optimise! is called.\nopt_type = Trad(; rm = [MAD(), CVaR(), CVaR(; alpha = 0.2)])\n\n# Correct use of multiple risk measures, some of the same type.\nopt_type = Trad(; rm = [MAD(), [CVaR(), CVaR(; alpha = 0.2)]])\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.efficient_frontier!","page":"Optimisation kinds","title":"PortfolioOptimiser.efficient_frontier!","text":"efficient_frontier!(port::Portfolio, type::Union{Trad, NOC, NCO} = Trad();\n                             w_min_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             w_max_ini::AbstractVector = Vector{Float64}(undef, 0),\n                             points::Integer = 20, rf::Real = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.optimise!-Tuple{Portfolio, Trad}","page":"Optimisation kinds","title":"PortfolioOptimiser.optimise!","text":"optimise!(port::Portfolio, type::OptimType)\n\n\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#Private","page":"Optimisation kinds","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractOptimType","text":"abstract type AbstractOptimType end\n\nAbstract type for the different types of optimisations.\n\nSee also: OptimType and HCOptimType.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.AbstractScalarisation","page":"Optimisation kinds","title":"PortfolioOptimiser.AbstractScalarisation","text":"abstract type AbstractScalarisation end\n\nAbstract type for scalarisation functions used when simultaneously optimising for multiple risk measures.\n\nSee also: ScalarSum, ScalarMax, ScalarLogSumExp.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.HCOptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.HCOptimType","text":"abstract type HCOptimType <: AbstractOptimType end\n\nAbstract type for hierarchical optimisations.\n\nSee also: AbstractOptimType, OptimType, HRP, SchurHRP, HERC, NCO.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.OptimType","page":"Optimisation kinds","title":"PortfolioOptimiser.OptimType","text":"abstract type OptimType <: AbstractOptimType end\n\nAbstract type for optimisations that are not hierarchical.\n\nSee also: AbstractOptimType, HCOptimType, Trad, RB, RRB, NOC.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.RRBVersion","page":"Optimisation kinds","title":"PortfolioOptimiser.RRBVersion","text":"abstract type RRBVersion end\n\nAbstract type for the different versions of the relaxed risk budget optimisation.\n\nSee also: RRB, BasicRRB, RegRRB, RegPenRRB.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.set_custom_hc_rm!-Tuple","page":"Optimisation kinds","title":"PortfolioOptimiser.set_custom_hc_rm!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.unset_custom_hc_rm!-Tuple","page":"Optimisation kinds","title":"PortfolioOptimiser.unset_custom_hc_rm!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.post_modify_inter_port!-Tuple{PortfolioOptimiser.NoNCOModify, Vararg{Any, 4}}","page":"Optimisation kinds","title":"PortfolioOptimiser.post_modify_inter_port!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.post_modify_intra_port!-Tuple{PortfolioOptimiser.NoNCOModify, Vararg{Any, 8}}","page":"Optimisation kinds","title":"PortfolioOptimiser.post_modify_intra_port!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.pre_modify_inter_port!-Tuple{PortfolioOptimiser.NoNCOModify, Vararg{Any, 4}}","page":"Optimisation kinds","title":"PortfolioOptimiser.pre_modify_inter_port!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.pre_modify_intra_port!-Tuple{PortfolioOptimiser.NoNCOModify, Vararg{Any, 8}}","page":"Optimisation kinds","title":"PortfolioOptimiser.pre_modify_intra_port!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.reset_inter_port!-Tuple{PortfolioOptimiser.NoNCOModify, Nothing, PortfolioOptimiser.NoNCOModify, Nothing, Vararg{Any, 4}}","page":"Optimisation kinds","title":"PortfolioOptimiser.reset_inter_port!","text":"\n\n\n\n","category":"method"},{"location":"Optimisation/OptimisationKinds/#PortfolioOptimiser.reset_intra_port!-Tuple{PortfolioOptimiser.NoNCOModify, Nothing, PortfolioOptimiser.NoNCOModify, Nothing, Vararg{Any, 8}}","page":"Optimisation kinds","title":"PortfolioOptimiser.reset_intra_port!","text":"\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskValue/#Risk-value","page":"Risk value","title":"Risk value","text":"","category":"section"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"Despite the fact that HCRiskMeasure are only compatible with , it is possible to compute the value of every risk measure for a given returns matrix and vector of weights.","category":"page"},{"location":"RiskMeasures/RiskValue/","page":"Risk value","title":"Risk value","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskValue/#PortfolioOptimiser.expected_risk","page":"Risk value","title":"PortfolioOptimiser.expected_risk","text":"expected_risk(::Equal, w::AbstractVector; delta::Real = 0, kwargs...)\n\nDescription\n\nCompute the risk as the inverse of the length of w.\n\nInputs\n\nPositional\n\nequal::Equal: risk measure.\nw::AbstractVector: N×1 vector of asset weights.\n\nNamed\n\ndelta::Real: is a displacement, used in risk_contribution and factor_risk_contribution.\n\nOutputs\n\nequal::Real: Equal Risk.\n\nExamples\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the equal risk measure\nequal_rm = Equal()\nequal_risk = expected_risk(equal_rm, w)\n\n\n\n\n\nexpected_risk(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n          type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n          rm::AbstractRiskMeasure = SD())\n\nCompute the risk for an AbstractRiskMeasure for a portfolio.\n\nInputs\n\nport: portfolio.\nX: T×N returns matrix.\ntype: optimisation type used to retrieve the weights vector from port.optimal[type].\nrm: rism measure.\n\nOutputs\n\nr: risk.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClustOpt","page":"Clustering","title":"PortfolioOptimiser.ClustOpt","text":"@kwdef mutable struct ClustOpt{T1 <: Integer, T2 <: Integer}\n    branchorder::Symbol = :optimal\n    k_type::NumClusterType = TwoDiff()\n    k::T1 = 0\n    max_k::T2 = 0\nend\n\nDefines the options for processing clustering results in an instance of Clustering.Hclust.\n\nParameters\n\nbranchorder: parameter for ordering a dendrogram's branches accepted by Clustering.jl.\nk_type: type subtyping NumClusterType for computing the number of clusters.\nk:\nif iszero(k): use k_type for computing the number of clusters.\nelse: directly provide the number of clusters.\nmax_k: maximum number of clusters, capped to ⌈sqrt(N)⌉.\nif 0: defaults to ⌈sqrt(N)⌉.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClusterNode","page":"Clustering","title":"PortfolioOptimiser.ClusterNode","text":"struct ClusterNode{tid, tl, tr, td, tcnt}\n    id::tid\n    left::tl\n    right::tr\n    height::td\n    level::tcnt\n\n    function ClusterNode(id, left::Union{ClusterNode, Nothing} = nothing,\n                         right::Union{ClusterNode, Nothing} = nothing, height::Real = 0.0,\n                         level::Int = 1)\n        ilevel = isnothing(left) ? level : (left.level + right.level)\n\n        return new{typeof(id), typeof(left), typeof(right), typeof(height), typeof(level)}(id,\n                                                                                         left,\n                                                                                         right,\n                                                                                         height,\n                                                                                         ilevel)\n    end\nend\n\nStructure for definining a cluster node. This is used for turning a clustering result into a tree, is_leaf, pre_order, to_tree.\n\nParameters\n\nid: node ID.\nleft: node to the left.\nright: node to the right.\nheight: node height.\nlevel: node level.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHT","page":"Clustering","title":"PortfolioOptimiser.DBHT","text":"mutable struct DBHT <: ClustAlg\n    distance::DistType\n    similarity::DBHTSimilarity\n    root_type::DBHTRootType\nend\n\nDefines the parameters for computing DBHTs [4].\n\nParameters\n\ndistance: type for computing the distance matrix from correlation ones DistType.\nsimilarity: type for computing the similarity matrix from the correlation and/or distance ones DBHTSimilarity, dbht_similarity.\nroot_type: type for choosing clique roots DBHTRootType.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTExp","page":"Clustering","title":"PortfolioOptimiser.DBHTExp","text":"struct DBHTExp <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise exponential decay of the dissimilarity matrix in dbht_similarity.\n\nbeginalign\nS_ij = exp(-D_ij)\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTMaxDist","page":"Clustering","title":"PortfolioOptimiser.DBHTMaxDist","text":"struct DBHTMaxDist <: DBHTSimilarity end\n\nDefines the similarity matrix for use in PMFG_T2s as the element-wise squared distance from the maximum value of the dissimilarity matrix dbht_similarity.\n\nbeginalign\nS_ij = leftlceil (max mathbfD)^2 rightrceil - D_ij ^ 2\nendalign\n\nWhere:\n\nS_ij is the (ij)-th entry in the similarity matrix.\nD_ij is the (ij)-th entry in the distance matrix.\nmathbfD is the distance matrix.\n\n\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.EqualDBHT","page":"Clustering","title":"PortfolioOptimiser.EqualDBHT","text":"struct EqualDBHT <: DBHTRootType end\n\nCreate a clique's root from its adjacency tree in CliqueRoot.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HAC","page":"Clustering","title":"PortfolioOptimiser.HAC","text":"@kwdef mutable struct HAC <: ClustAlg\n    linkage::Symbol = :ward\nend\n\nUse a hierarchical clustering algorithm from Clustering.jl.\n\nParameters\n\nlinkage: linkage type supported by hclust.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.StdSilhouette","page":"Clustering","title":"PortfolioOptimiser.StdSilhouette","text":"@kwdef mutable struct StdSilhouette <: NumClusterType\n    metric::Union{Distances.SemiMetric, Nothing} = nothing\nend\n\nUse the standardised silhouette score for computing the number of clusters in calc_k_clusters.\n\nParameters\n\nmetric: metric for computing the silhouettes.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.TwoDiff","page":"Clustering","title":"PortfolioOptimiser.TwoDiff","text":"struct TwoDiff <: NumClusterType end\n\nUse the two difference gap statistic for computing the number of clusters in calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.UniqueDBHT","page":"Clustering","title":"PortfolioOptimiser.UniqueDBHT","text":"struct UniqueDBHT <: DBHTRootType end\n\nCreate a unique root for a clique in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.calc_k_clusters-Tuple{ClustOpt, AbstractMatrix, Any}","page":"Clustering","title":"PortfolioOptimiser.calc_k_clusters","text":"calc_k_clusters(clust_opt::ClustOpt, dist::AbstractMatrix, clustering)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTExp, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTExp, S, D)\n\nComputes the DBHTExp similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.dbht_similarity-Tuple{DBHTMaxDist, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.dbht_similarity","text":"dbht_similarity(::DBHTMaxDist, S, D)\n\nComputes the DBHTMaxDist similarity matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.is_leaf-Tuple{ClusterNode}","page":"Clustering","title":"PortfolioOptimiser.is_leaf","text":"is_leaf(a::ClusterNode)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.pre_order","page":"Clustering","title":"PortfolioOptimiser.pre_order","text":"pre_order(a::ClusterNode, func::Function = x -> x.id)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.to_tree-Tuple{Clustering.Hclust}","page":"Clustering","title":"PortfolioOptimiser.to_tree","text":"to_tree(a::Hclust)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTs-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DBHTs","text":"DBHTs(D::AbstractMatrix{<:Real}, S::AbstractMatrix{<:Real}; branchorder::Symbol = :optimal,\n      type::Symbol = :Unique)\n\nPerform Direct Bubble Hierarchical Tree clustering, a deterministic clustering algorithm [4]. This version uses a graph-theoretic filtering technique called Triangulated Maximally Filtered Graph (TMFG).\n\nArguments\n\nD: N×N dissimilarity matrix, e.g. a distance matrix.\nS: N×N non-negative similarity matrix, examples include:\nmathbfS = mathbfC + lvert min mathbfC rvert.\nmathbfS = lceilmax left(mathbfD^odot 2right)rceil - mathbfD^odot 2.\nmathbfS = exp odot (-mathbfD).\nWhere mathbfC is the correlation matrix, mathbfD the dissimilarity matrix D, and odot the Hadamard (elementwise) operator.\nbranchorder: parameter for ordering the final dendrogram's branches accepted by Clustering.jl.\ntype: type for finding the root of a Direct Bubble Hierarchical Clustering Tree in case there is more than one candidate DBHTRootType.\n:Unique: create a unique root.\n:Equal: the root is created from the candidate's adjacency tree.\n\nOutputs\n\nT8: N×1 cluster membership vector.\nRpm: N×N adjacency matrix of the Planar Maximally Filtered Graph (PMFG).\nAdjv: Bubble cluster membership matrix from BubbleCluster8s.\nDpm: N×N shortest path length matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\nZ_hclust: Z matrix in Clustering.Hclust format.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.J_LoGo-Tuple{Any, Any, Any}","page":"Clustering","title":"PortfolioOptimiser.J_LoGo","text":"J_LoGo(sigma, separators, cliques)\n\nCompute the sparse inverse covariance from a clique tree and separators [6].\n\nInputs\n\nsigma: N×N covariance matrix.\nseparators: list of 3-cliques that are not triangular faces.\ncliques: list of all 4-cliques.\n\nOutputs\n\njlogo: J_LoGo covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.PMFG_T2s","page":"Clustering","title":"PortfolioOptimiser.PMFG_T2s","text":"PMFG_T2s(W::AbstractMatrix{<:Real}, nargout::Integer = 3)\n\nConstructs a Triangulated Maximally Filtered Graph (TMFG) starting from a tetrahedron and recursively inserting vertices inside existing triangles (T2 move) in order to approximate a Maximal Planar Graph with the largest total weight, aka Planar Maximally Filtered Graph (PMFG). All weights are non-negative [7].\n\nArguments\n\nW: N×N matrix of non-negative weights.\nnargout: number of output arguments, the same arguments are always returne, this only controls whether some arguments are empty or not.\n\nOutputs\n\nA: adjacency matrix of the PMFG with weights.\ntri: list of triangles (triangular faces).\nclique3: list of 3-cliques taht are not triangular faces, all 3-cliques are given by [tri; clique3].\ncliques: list of all 4-cliques, if nargout <= 3, this will be returned as an empty array.\ncliqueTree: 4-cliques tree structure (adjacency matrix), if nargout <= 4, it is returned as an empty array.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.ClustAlg","page":"Clustering","title":"PortfolioOptimiser.ClustAlg","text":"abstract type ClustAlg end\n\nAbstract type for subtyping hierarchical clustering types.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTRootType","page":"Clustering","title":"PortfolioOptimiser.DBHTRootType","text":"abstract type DBHTRootType end\n\nAbstract type for subtyping types creating roots of cliques in CliqueRoot [5].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DBHTSimilarity","page":"Clustering","title":"PortfolioOptimiser.DBHTSimilarity","text":"abstract type DBHTSimilarity end\n\nAbstract type for subtyping types for defining functions for computing similarity matrices from used in DBHT clustering PMFG_T2s [4, 7].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.NumClusterType","page":"Clustering","title":"PortfolioOptimiser.NumClusterType","text":"abstract type NumClusterType end\n\nAbstract type for subtyping types for determining the number of clusters in a Clustering.Hclust when calling calc_k_clusters.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.AdjCliq-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.AdjCliq","text":"AdjCliq(A::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real},\n        CliqRoot::AbstractVector{<:Real})\n\nFind adjacent clique to the root candidates.\n\nInputs\n\nA: N×N adjacency matrix.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nCliqRoot: Nc×1 vector of root cliques.\n\nOutputs\n\nAdj: Nc×Nc adjacency matrix of the cliques with the root cliques.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleCluster8s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleCluster8s","text":"BubbleCluster8s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                Hb::AbstractMatrix{<:Real}, Mb::AbstractMatrix{<:Real},\n                Mv::AbstractMatrix{<:Real}, CliqList::AbstractMatrix{<:Real})\n\nObtains non-discrete and discrete clusterings from the bubble topology of the Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nHb: undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nAdjv: N×Nk cluster membership matrix for vertices for non-discrete clustering via the bubble topology. Adjv[n, k] = 1 indicates cluster membership of vertex n to the k'th non-discrete cluster.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleHierarchy-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleHierarchy","text":"BubbleHierarchy(Pred::AbstractVector{<:Real}, Sb::AbstractVector{<:Real})\n\nBuild the bubble hierarchy.\n\nInputs\n\nPred: Nc×1 vector of predicted hierarchies.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\nOutputs\n\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BubbleMember-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BubbleMember","text":"BubbleMember(Rpm::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n             Mc::AbstractMatrix{<:Real})\n\nAssigns each vertex in the to a specific bubble.\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\nMc: Matrix of the bubbles which coincide with the cluster.\n\nOutputs\n\nMvv: Matrix of the vertices belonging to the bubble.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.BuildHierarchy-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.BuildHierarchy","text":"BuildHierarchy(M::AbstractMatrix{<:Real})\n\nBuilds the predicted hierarchy.\n\nInputs\n\nM: N×Nc matrix of nodes and 3-cliques.\n\nOutputs\n\nPred: Nc×1 vector of predicted hierarchies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqHierarchyTree2s","page":"Clustering","title":"PortfolioOptimiser.CliqHierarchyTree2s","text":"CliqHierarchyTree2s(Apm::AbstractMatrix{<:Real}, type::Symbol = :Unique)\n\nLooks for 3-cliques of a Maximal Planar Graph (MPG), then construct a hierarchy of the cliques with the definition of \"inside\" a clique being a subgraph of smaller size when the entire graph is made disjoint by removing the clique [5].\n\nInputs\n\nApm: N×N adjacency matrix of an MPG.\ntype: type for finding the root of the graph DBHTRootType. Uses Voronoi tesselation between tiling triangles.\nUniqueDBHT(): create a unique root.\nEqualDBHT(): the root is created from the candidate's adjacency tree.\n\nOutputs\n\nH1: Nc×Nc adjacency matrix for 3-clique hierarchical tree where Nc is the number of 3-cliques.\nH2: Nb×Nb adjacency matrix for the bubble hierarchical tree where Nb is the number of bubbles.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\nSb: Nc×1 vector. Sb[n] = 1 indicates 3-clique n is separating.\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.CliqueRoot-Tuple{UniqueDBHT, Any, Any, Any, Vararg{Any}}","page":"Clustering","title":"PortfolioOptimiser.CliqueRoot","text":"CliqueRoot(::UniqueDBHT, Root, Pred, Nc, args...)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DendroConstruct-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Union{Real, AbstractVector{<:Real}}}","page":"Clustering","title":"PortfolioOptimiser.DendroConstruct","text":"DendroConstruct(Zi::AbstractMatrix{<:Real}, LabelVec1::AbstractVector{<:Real},\n                LabelVec2::AbstractVector{<:Real},\n                LinkageDist::Union{<:Real, AbstractVector{<:Real}})\n\nConstruct the linkage matrix by continuially adding rows to the matrix.\n\nInputs\n\nZi: Linkage matrix at iteration i in the same format as the output from Matlab.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: Linkage matrix at iteration i + 1 in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.DirectHb-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.DirectHb","text":"DirectHb(Rpm::AbstractMatrix{<:Real}, Hb::AbstractMatrix{<:Real},\n         Mb::AbstractMatrix{<:Real}, Mv::AbstractMatrix{<:Real},\n         CliqList::AbstractMatrix{<:Real})\n\nComputes the directions on each separating 3-clique of a Maximal Planar Graph (MPH), hence computes the Directed Bubble Hierarchy Tree (DBHT).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the Planar Maximally Filtered Graph (MPFG).\nHb: Undirected bubble tree of the PMFG.\nMb: Nc×Nb bubble membership matrix for 3-cliques. Mb[n, bi] = 1 indicated that 3-clique n belongs to bubble bi.\nMv: N×Nb bubble membership matrix for vertices.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\nOutputs\n\nHc: Nb×Nb unweighted directed adjacency matrix of the DBHT. Hc[i, j]=1 indicates a directed edge from bubble i to bubble j.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.FindDisjoint-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.FindDisjoint","text":"FindDisjoint(Adj::AbstractMatrix{<:Real}, Cliq::AbstractVector{<:Real})\n\nFinds disjointed cliques in adjacency matrix.\n\nInputs\n\nAdj: N×N adjacency matrix.\nCliq: 3×1 vector of 3-cliques.\n\nOutputs\n\nT: N×1 vector containing the adjacency number of each node.\nIndxNot: N×1 vector of nodes with no adjacencies.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.HierarchyConstruct4s-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.HierarchyConstruct4s","text":"HierarchyConstruct4s(Rpm::AbstractMatrix{<:Real}, Dpm::AbstractMatrix{<:Real},\n                     Tc::AbstractVector{<:Real}, Mv::AbstractMatrix{<:Real})\n\nConstructs the intra- and inter-cluster hierarchy by utilizing Bubble Hierarchy structure of a Maximal Planar graph, in this a Planar Maximally Filtered Graph (PMFG).\n\nInputs\n\nRpm: N×N sparse weighted adjacency matrix of the PMFG.\nDpm: N×N shortest path lengths matrix of the PMFG.\nTc: N×1 cluster membership vector. Tc[n] = k indicates cluster membership of vertex n to the k'th discrete cluster.\nMv: N×Nb bubble membership matrix. Mv[n, bi] = 1 means vertex n is a vertex of bubble bi.\n\nOutputs\n\nZ: (N-1)×3 linkage matrix in the same format as the output from Matlab.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.LinkageFunction-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.LinkageFunction","text":"LinkageFunction(d::AbstractMatrix{<:Real}, labelvec::AbstractVector{<:Real})\n\nLooks for the pair of clusters with the best linkage.\n\nInputs\n\nd: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nlabelvec: label vector for the vertices in the bubble.\n\nOutputs\n\nPairLink: pair of links with the best linkage.\ndvu: value of the best linkage.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.breadth-Tuple{AbstractMatrix{<:Real}, Integer}","page":"Clustering","title":"PortfolioOptimiser.breadth","text":"breadth(CIJ::AbstractMatrix{<:Real}, source::Integer)\n\nBreadth-first search.\n\nInputs\n\nCIJ: binary (directed/undirected) connection matrix.\nsource: source vertex.\n\nOutputs\n\ndistance: distance between source and i'th vertex (0 for source vertex).\nbranch: vertex that precedes i in the breadth-first search tree (-1 for source vertex).\n\nnote: Note\nBreadth-first search tree does not contain all paths (or all shortest paths), but allows the determination of at least one path with minimum distace. The entire graph is explored, starting from source vertex source.    # ColoursOriginal written by: Olaf Sporns, Indiana University, 2002/2007/2008\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.build_link_and_dendro-Tuple{AbstractRange, AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, Real, AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.build_link_and_dendro","text":"build_link_and_dendro(rg::AbstractRange, dpm::AbstractMatrix{<:Real},\n                       LabelVec::AbstractVector{<:Real}, LabelVec1::AbstractVector{<:Real},\n                       LabelVec2::AbstractVector{<:Real}, V::AbstractVector{<:Real},\n                       nc::Real, Z::AbstractMatrix{<:Real})\n\nComputes iterates over the vertices to construct the linkage matrix iteration by iteration.\n\nInputs\n\nrg: range of indices of the vertices in a bubble.\ndpm: Nv×Nv distance matrix for a list of vertices assigned to a bubble.\nLabelVec: vector labels of all vertices.\nLabelVec1: label vector for the vertices in the bubble for the previous valid iteration.\nLabelVec2: label vector for the vertices in the bubble for the trial iteration.\n\nOutputs\n\nZ: updated linkage matrix in the same format as the output from Matlab.\nnc: updated inverse of the linkage distance.\nLabelVec1: updated LabelVec1 for the next iteration.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.clique3-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.clique3","text":"clique3(A::AbstractMatrix{<:Real})\n\nComputes the list of 3-cliques.\n\nInputs\n\nA: N×N adjacency matrix of a Maximal Planar Graph (MPG).\n\nOutputs\n\nK3: vector of vectors with the corresponding indices of candidate cliques.\nE: matrix with non-zero indices and entries of candidate cliques.\nCliqList: Nc×3 matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.distance_wei-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.distance_wei","text":"distance_wei(L::AbstractMatrix{<:Real})\n\nThe distance matrix contains lengths of shortest paths between all node pairs. An entry [u, v] represents the length of the shortest path from node u to node v. The average shortest path length is the characteristic path length of the network. The function uses Dijkstra's algorithm.\n\nInputs\n\nL: Directed/undirected connection-length matrix.\nLengths between disconnected nodes are set to Inf.\nLengths on the main diagonal are set to 0.\n\nnote: Note\nThe input matrix must be a connection-length matrix typically obtained via a mapping from weight to length. For instance, in a weighted correlation network, higher correlations are more naturally interpreted as shorter distances, and the input matrix should therefore be some inverse of the connectivity matrix, i.e. a distance matrix.The number of edges in the shortest weighted path may in general exceed the number of edges in the shortest binary paths (i.e. the shortest weighted paths computed on the binarised connectivity matrix), because the shortest weighted paths have the minimal weighted distance, not necessarily the minimal number of edges.\n\nOutputs\n\nD: distance (shortest weighted path) matrix.\nB: number of edged in the shortest weigthed path matrix.\n\nnote: Note\nBased on a Matlab implementation by:Mika Rubinov, UNSW/U Cambridge, 2007-2012.\nRick Betzel and Andrea Avena, IU, 2012\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/Clustering/#PortfolioOptimiser.turn_into_Hclust_merges-Tuple{AbstractMatrix{<:Real}}","page":"Clustering","title":"PortfolioOptimiser.turn_into_Hclust_merges","text":"turn_into_Hclust_merges(Z::AbstractMatrix{<:Real})\n\nTurns a Matlab-style linkage matrix to a useable format for Hclust.\n\nInputs\n\nZ: Matlab-style linkage matrix.\n\nOutputs\n\nZ: Hclust-style linkage matrix.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskMeasures1-1/#Generalities","page":"Generalities","title":"Generalities","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"This section details general types, structures, and constants that play a supporting role in defining risk measures.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/#Abstract-types","page":"Generalities","title":"Abstract types","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"PortfolioOptimiser's risk measures are implemented using Julia's type hierarchy. This makes it easy to add new ones by implementing the relevant types and methods.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"By properly subtyping and following the implementation instructions of each abstract type, it's possible to define risk measures that will be entirely compatible with current functionality, without the need for extending method definitions and/or subtyping any of the myriad of abstract types that allow users to define custom behaviour within the library.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.AbstractRiskMeasure","page":"Generalities","title":"PortfolioOptimiser.AbstractRiskMeasure","text":"abstract type AbstractRiskMeasure end\n\nSupertype for all risk measaures.\n\nSee also: RiskMeasure, HCRiskMeasure, NoOptRiskMeasure.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasure","page":"Generalities","title":"PortfolioOptimiser.RiskMeasure","text":"abstract type RiskMeasure <: AbstractRiskMeasure end\n\nSupertype for risk measures compatible with optimisations which accept risk measures.\n\nSee also: RiskMeasureSolvers, RiskMeasureSigma, RiskMeasureSkew, RiskMeasureOWA, RiskMeasureMu, RiskMeasureTarget, RMSettings, expected_risk, set_rm.\n\nImplementation\n\nTo ensure a risk measure can be used any of the above optimisation types, it must abide by a few rules.\n\nImplement: Base.iterate, Base.Symbol, Base.length, Base.getindex, and Base.view.\n\nstruct MyRiskMeasure <: RiskMeasure\n    # Properties of MyRiskMeasure\nend\n\nBase.iterate(S::MyRiskMeasure, state = 1) = state > 1 ? nothing : (S, state + 1)\nfunction Base.String(s::MyRiskMeasure)\n    return \"MyRiskMeasure\"\nend\nfunction Base.Symbol(::MyRiskMeasure)\n    return Symbol(\"MyRiskMeasure\")\nend\nfunction Base.length(::MyRiskMeasure)\n    return 1\nend\nfunction Base.getindex(S::MyRiskMeasure, ::Any)\n    return S\nend\nfunction Base.view(S::MyRiskMeasure, ::Any)\n    return S\nend\n\nInclude a settings::RMSettings property, RMSettings.\n\nstruct MyRiskMeasure <: RiskMeasure\n    # Properties of MyRiskMeasure\n    settings::RMSettings\nend\n\nImplement your measure's risk calculation method, expected_risk. This will let the library use the risk function everywhere it needs to.\n\nfunction expected_risk(my_risk::MyRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\nA scalar JuMP model implementation of set_rm. If appropriate, a vector equivalent.\n\n# The scalar function.\nfunction PortfolioOptimiser.set_rm(port, rm::MyRiskMeasure, type::Union{Trad, RB, NOC};\n                                   kwargs...)\n    # Get optimisation model.\n    model = port.model\n\n    ###\n    # Variables, constraints, expressions, etc.\n    ###\n\n    # Define the risk expression for MyRiskMeasure\n    @expression(model, MyRiskMeasure_risk, ...)\n\n    # Define the key name for the upper bound.\n    # The upper bound key will be `Symbol(\"MyRiskMeasure_risk_ub\")`\n    ub_key = \"MyRiskMeasure_risk\"\n\n    # Set the upper bound on MyRiskMeasure_risk. \n    # If isinf(rm.settings.ub), no upper bound will be set.\n    set_rm_risk_upper_bound(type, model, MyRiskMeasure_risk, rm.settings.ub, ub_key)\n\n    # Add the risk to the risk expression.\n    # If rm.settings.flag == true, MyRiskMeasure_risk will be added to the vector of risks.\n    # This means it will form part of the objective function when the objective function \n    # is MinRisk, Utility or Sharpe.\n    # If rm.settings.flag == false, MyRiskMeasure_risk will only be used as a risk \n    # constraint.\n    set_risk_expression(model, MyRiskMeasure_risk, rm.settings.scale, rm.settings.flag)\n\n    return nothing\nend\n\n# Vector equivalent if it's possible to provide multiple instances of MyRiskMeasure.\nfunction PortfolioOptimiser.set_rm(port, rms::AbstractVector{<:MyRiskMeasure},\n                                   type::Union{Trad, RB, NOC}; kwargs...)\n\n    # Get optimisation model.\n    model = port.model\n    count = length(rms)\n\n    ###\n    # Variables, constraints, expressions, that can be initialised beforehand etc.\n    ###\n\n    # Define the risk expression for MyRiskMeasure.\n    # It can also be defined in the iteration using the \n    # `model[key] = @expression(model, ..., ...) `\n    # construct, then reference the `model[key]` expression.\n    # Or use its anonymous version\n    # `key = @expression(model, ..., ...)` \n    # and reference the `key` expression.\n    @expression(model, MyRiskMeasure_risk[1:count], ...)\n\n    for (i, rm) ∈ pairs(rms)\n        ###\n        # Variables, constraints, expressions, that must be set during each iteration.\n        # If you want to register them in the model use:\n        # `model[constraint_key] = @constraint(model, ..., ...)`\n        # `model[expression_key] = @expression(model, ..., ...)`\n        # `model[variable_key] = @variable(model, ..., ...)`\n        # If you want them to be anonymous (i.e. not registered in the model) use:\n        # `constraint_key = @constraint(model, ..., ...)`\n        # `expression_key = @expression(model, ..., ...)`\n        # `variable_key = @variable(model, ..., ...)`\n        # If they were defined outside of the loop like MyRiskMeasure_risk \n        # but need to be modified then use:\n        # `add_to_expression!(MyRiskMeasure_risk[i], ...).`\n        ###\n\n        # Define the key name for the upper bound.\n        # The upper bound key will be `Symbol(\"MyRiskMeasure_risk_$(i)_ub\")`\n        ub_key = \"MyRiskMeasure_risk_$(i)\"\n\n        # Set the upper bound on MyRiskMeasure_risk[i]. \n        # If isinf(rm.settings.ub), no upper bound will be set.\n        set_rm_risk_upper_bound(type, model, MyRiskMeasure_risk[i], rm.settings.ub, ub_key)\n\n        # Add the risk to the risk expression.\n        # If rm.settings.flag == true, MyRiskMeasure_risk[i] will be added to the vector of\n        # risks. This means it will form part of the objective function when the objective \n        # function is MinRisk, Utility or Sharpe.\n        # If rm.settings.flag == false, MyRiskMeasure_risk[i] will only be used as a risk \n        # constraint.\n        set_risk_expression(model, MyRiskMeasure_risk[i], rm.settings.scale,\n                            rm.settings.flag)\n    end\n\n    return nothing\nend\n\nIf a risk measure is to be compatible with hierarchical optimisations that take risk measures as parameters, and it contains a properties which can/must be indexed/computed per asset, like a vector or matrix, it must implement set_custom_hc_rm! and unset_custom_hc_rm! which dispatches on the custom risk measure.\n\nstruct MyRiskMeasure{T1, T2, T3} <: RiskMeasure\n    # Properties containing asset information (computable or indexable).\n    indexable_vector::Vector{T1}\n    indexable_matrix::Matrix{T1}\n    computable_vector::Vector{T1}\n    computable_matrix::Matrix{T1}\n    computable_vector_args::T2\n    computable_matrix_args::T3\nend\n\n# We have some computable properties, so we need to define the function to do so.\nfunction compute_MyRiskMeasure_vec_mtx!(rm::MyRiskMeasure, args...)\n    # Compute vector and matrix\n    new_computable_vector = ...\n    new_computable_matrix = ...\n\n    rm.computable_vector = new_computable_vector\n    rm.computable_matrix = new_computable_matrix\n\n    return nothing\nend\n\n# port is the portfolio, sigma is the covariance matrix, cluster are the indices defining the cluster.\nfunction set_custom_hc_rm!(rm::MyRiskMeasure, port, sigma, cluster)\n    old_i_vector = rm.indexable_vector\n    old_i_matrix = rm.indexable_matrix\n    old_c_vector = rm.computable_vector\n    old_c_matrix = rm.computable_matrix\n\n    ###\n    ###\n    # These can be placed inside if statements that condition the indexing\n    rm.indexable_vector = rm.indexable_vector[cluster]\n    rm.indexable_matrix = rm.indexable_matrix[cluster, cluster]\n    ###\n    ###\n\n    compute_MyRiskMeasure_vec_mtx!(rm, port, sigma, cluster)\n\n    return Tuple(old_i_vector, old_i_matrix, old_c_vector, old_c_matrix)\nend\nfunction unset_custom_hc_rm!(rm::MyRiskMeasure, old_custom)\n    rm.indexable_vector = old_custom[1]\n    rm.indexable_matrix = old_custom[2]\n    rm.computable_vector = old_custom[3]\n    rm.computable_matrix = old_custom[4]\n\n    return nothing\nend\n\nSimilarly, if the risk measure is to be used in NCO optimisations, and it contains a properties which can/must be indexed/computed per asset, like a vector or matrix, it must implement pre_modify_intra_port!, post_modify_intra_port!, reset_intra_port!, pre_modify_inter_port!, post_modify_inter_port!, reset_inter_port!, which dispatch on custom structures that. The functions can then check for the custom risk measure and modify it as in the previous bullet point. See the function's docstrings for explanations on their arguments and use.\n\n# Structures for dispatching on.\nstruct MyPreModify <: AbstractNCOModify\n    # Custom properties.\nend\nstruct MyPostModify <: AbstractNCOModify\n    # Custom properties.\nend\n\n# Procedures for computing or modifying risk measures for the internal optimisations.\n# Each cluster is treated as a single portfolio.\nfunction pre_modify_intra_port!(pre_modify::MyPreModify, intra_port, internal_args, i,\n                                cluster, cidx, idx_sq, Nc, special_rm_idx)\n    # Modify intra-cluster portfolio pre computation of statistics.\n    return pre_mod_output\nend\nfunction post_modify_intra_port!(post_modify::MyPostModify, intra_port, internal_args, i,\n                                 cluster, cidx, idx_sq, Nc, special_rm_idx)\n    # Modify intra-cluster portfolio post computation of statistics.\n    return post_mod_output\nend\nfunction reset_intra_port!(pre_modify::MyPreModify, pre_mod_output,\n                           post_modify::MyPostModify, post_mod_output, intra_port,\n                           internal_args, i, cluster, cidx, idx_sq, Nc, special_rm_idx)\n    # Reset any changes done to the optimisation arguments.\n    return nothing\nend\n\n# Procedures for computing or modifying risk measures for the external optimisation.\n# Each cluster is turned into a synthetic asset and a portfolio optimisation is\n# performed on them.\nfunction pre_modify_inter_port!(pre_modify::MyPreModify, inter_port, wi, external_args,\n                                special_rm_idx)\n    # Modify inter-cluster portfolio pre computation of statistics.\n    return pre_mod_output\nend\nfunction post_modify_inter_port!(post_modify::MyPostModify, inter_port, wi, external_args,\n                                 special_rm_idx)\n    # Modify inter-cluster portfolio post computation of statistics.\n    return post_mod_output\nend\nfunction reset_inter_port!(pre_modify::MyPreModify, pre_mod_output,\n                           post_modify::MyPostModify, post_mod_output, inter_port, wi,\n                           external_args, special_rm_idx)\n    # Reset any changes done to the optimisation arguments.\n    return nothing\nend\n\n# The NCO optimisation type would then be defined like so.\ntype = NCO(;\n           internal = NCOArgs(; type = Trad(; rm = MyRiskMeasure()),\n                              pre_modify = MyPreModify(), post_modify = MyPostModify()),\n           # In case the external optimisation is to use something different.\n           external = ...)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.HCRiskMeasure","page":"Generalities","title":"PortfolioOptimiser.HCRiskMeasure","text":"abstract type HCRiskMeasure <: AbstractRiskMeasure end\n\nSupertype for risk measures compatible with optimisations which accept risk measures and do not use JuMP models.\n\nSee also: HCRiskMeasureSolvers, HCRiskMeasureMu, HCRiskMeasureTarget, HCRMSettings, expected_risk.\n\nImplementation\n\nTo ensure a risk measure can be used by the above optimisation types, it must abide by a few rules.\n\nImplement: Base.iterate, Base.Symbol, Base.length, Base.getindex, and Base.view.\n\nstruct MyHCRiskMeasure <: HCRiskMeasure\n    # Properties of MyHCRiskMeasure\nend\n\nBase.iterate(S::MyHCRiskMeasure, state = 1) = state > 1 ? nothing : (S, state + 1)\nfunction Base.String(s::MyHCRiskMeasure)\n    return \"MyHCRiskMeasure\"\nend\nfunction Base.Symbol(::MyHCRiskMeasure)\n    return Symbol(\"MyHCRiskMeasure\")\nend\nfunction Base.length(::MyHCRiskMeasure)\n    return 1\nend\nfunction Base.getindex(S::MyHCRiskMeasure, ::Any)\n    return S\nend\nfunction Base.view(S::MyHCRiskMeasure, ::Any)\n    return S\nend\n\nInclude a settings::HCRMSettings property, HCRMSettings.\n\nstruct MyHCRiskMeasure <: HCRiskMeasure\n    # Properties of MyHCRiskMeasure\n    settings::HCRMSettings\nend\n\nImplement your measure's risk calculation method, expected_risk. This will let the library use the risk function everywhere it needs to.\n\nfunction expected_risk(my_risk::MyHCRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\nIf a risk measure is to be compatible with hierarchical optimisations that take risk measures as parameters, and it contains a properties which can/must be indexed/computed per asset, like a vector or matrix, it must implement set_custom_hc_rm! and unset_custom_hc_rm! which dispatches on the custom risk measure.\n\nstruct MyHCRiskMeasure{T1, T2, T3} <: HCRiskMeasure\n    # Properties containing asset information (computable or indexable).\n    indexable_vector::Vector{T1}\n    indexable_matrix::Matrix{T1}\n    computable_vector::Vector{T1}\n    computable_matrix::Matrix{T1}\n    computable_vector_args::T2\n    computable_matrix_args::T3\nend\n\n# We have some computable properties, so we need to define the function to do so.\nfunction compute_MyRiskMeasure_vec_mtx!(rm::MyHCRiskMeasure, args...)\n    # Compute vector and matrix\n    new_computable_vector = ...\n    new_computable_matrix = ...\n\n    rm.computable_vector = new_computable_vector\n    rm.computable_matrix = new_computable_matrix\n\n    return nothing\nend\n\n# port is the portfolio, sigma is the covariance matrix, cluster are the indices defining the cluster.\nfunction set_custom_hc_rm!(rm::MyHCRiskMeasure, port, sigma, cluster)\n    old_i_vector = rm.indexable_vector\n    old_i_matrix = rm.indexable_matrix\n    old_c_vector = rm.computable_vector\n    old_c_matrix = rm.computable_matrix\n\n    ###\n    ###\n    # These can be placed inside if statements that condition the indexing\n    rm.indexable_vector = rm.indexable_vector[cluster]\n    rm.indexable_matrix = rm.indexable_matrix[cluster, cluster]\n    ###\n    ###\n\n    compute_MyRiskMeasure_vec_mtx!(rm, port, sigma, cluster)\n\n    return Tuple(old_i_vector, old_i_matrix, old_c_vector, old_c_matrix)\nend\nfunction unset_custom_hc_rm!(rm::MyHCRiskMeasure, old_custom)\n    rm.indexable_vector = old_custom[1]\n    rm.indexable_matrix = old_custom[2]\n    rm.computable_vector = old_custom[3]\n    rm.computable_matrix = old_custom[4]\n\n    return nothing\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.NoOptRiskMeasure","page":"Generalities","title":"PortfolioOptimiser.NoOptRiskMeasure","text":"abstract type NoOptRiskMeasure <: AbstractRiskMeasure end\n\nAbstract type for risk measures that cannot be used in optimisations but can be used as performance measurements via expected_risk. This can be for two reasons:\n\nThey can be negative, therefore unsuitable for optimisations that accept risk measures and do not use JuMP models.\nThey have no known optimisation formulation, therefore unsuitable for optimisations that accept risk measures and use JuMP models.\n\nSee also: expected_risk.\n\nImplementation\n\nImplement: expected_risk for the type. This will let the library use the risk function everywhere it needs to.\n\nstruct MyNoOptRiskMeasure <: NoOptRiskMeasure\n    # Properties of MyNoOptRiskMeasure\nend\n\nfunction expected_risk(my_risk::MyNoOptRiskMeasure, w::AbstractVector; kwargs...)\n    # Risk measure calculation\nend\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureSigma","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureSigma","text":"abstract type RiskMeasureSigma <: RiskMeasure end\n\nAbstract type for subtyping RiskMeasure which can use an N×N covariance matrix.\n\nSee also: RiskMeasure, Variance, SD, WCVariance.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nsigma::Union{<:AbstractMatrix, Nothing}: property to store an N×N covariance matrix.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureMu","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureMu","text":"abstract type RiskMeasureMu <: RiskMeasure end\n\nAbstract type for subtyping RiskMeasure which can use a T×1 AbstractWeights vector for computing the weighted mean, and an N×1 expected returns vector.\n\nSee also: RiskMeasure, RiskMeasureTarget, MAD, SSD, SVariance, Kurt, SKurt.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nmu::Union{<:AbstractVector, Nothing}: property to store an N×1 expected returns vector.\nw::Union{<:AbstractWeights, Nothing}: property to store a T×1 AbstractWeights vector for computing the weighted mean.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.HCRiskMeasureMu","page":"Generalities","title":"PortfolioOptimiser.HCRiskMeasureMu","text":"abstract type HCRiskMeasureMu <: RiskMeasure end\n\nAbstract type for subtyping HCRiskMeasure which can use a T×1 AbstractWeights vector for computing the weighted mean, and an N×1 expected returns vector.\n\nSee also: HCRiskMeasure, FTCM.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nmu::Union{<:AbstractVector, Nothing}: property to store an N×1 expected returns vector.\nw::Union{<:AbstractWeights, Nothing}: property to store a T×1 AbstractWeights vector for computing the weighted mean.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.NoOptRiskMeasureMu","page":"Generalities","title":"PortfolioOptimiser.NoOptRiskMeasureMu","text":"abstract type NoOptRiskMeasureMu <: RiskMeasure end\n\nAbstract type for subtyping NoOptRiskMeasure which can use a T×1 AbstractWeights vector for computing the weighted mean, and an N×1 expected returns vector.\n\nSee also: NoOptRiskMeasure, TCM.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nw::Union{<:AbstractWeights, Nothing}: property to store a T×1 AbstractWeights vector for computing the weighted mean.\nmu::Union{<:AbstractVector, Nothing}: property to store an N×1 expected returns vector.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureTarget","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureTarget","text":"abstract type RiskMeasureTarget <: RiskMeasureMu end\n\nAbstract type for subtyping RiskMeasure which can use a scalar or an N×1 vector specifying the minimum return threshold for classifying downside returns, a T×1 AbstractWeights vector for computing the weighted mean, and an N×1 expected returns vector.\n\nSee also: RiskMeasure, FLPM, SSD, SVariance.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\ntarget::Union{<:Real, <:AbstractVector{<:Real}, Nothing}: scalar or N×1 minimum return threshold for classifying downside returns. Only returns equal to or below this value are considered in the calculation. Must be in the same frequency as the returns.\nw::Union{<:AbstractWeights, Nothing}: property to store a T×1 AbstractWeights vector for computing the weighted mean.\nmu::Union{<:AbstractVector, Nothing}: property to store an N×1 expected returns vector.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.HCRiskMeasureTarget","page":"Generalities","title":"PortfolioOptimiser.HCRiskMeasureTarget","text":"abstract type HCRiskMeasureTarget <: RiskMeasureMu end\n\nAbstract type for subtyping HCRiskMeasure which can use a scalar or N×1 vector specifying the minimum return threshold for classifying downside returns, a T×1 AbstractWeights vector for computing the weighted mean, and an N×1 expected returns vector.\n\nSee also: HCRiskMeasure, TLPM, FTLPM.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\ntarget::Union{<:Real, <:AbstractVector{<:Real}, Nothing}: scalar or N×1 minimum return threshold for classifying downside returns. Only returns equal to or below this value are considered in the calculation. Must be in the same frequency as the returns.\nw::Union{<:AbstractWeights, Nothing}: property to store a T×1 AbstractWeights vector for computing the weighted mean.\nmu::Union{<:AbstractVector, Nothing}: property to store an N×1 expected returns vector.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureSolvers","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureSolvers","text":"abstract type RiskMeasureSolvers <: RiskMeasure end\n\nAbstract type for subtyping RiskMeasure for which computing the risk requires solving an optimisation model.\n\nSee also: RiskMeasure, EVaR, EDaR, RLVaR, RLDaR.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}}: (optional) instance or AbstractVector of PortOptSolver.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.HCRiskMeasureSolvers","page":"Generalities","title":"PortfolioOptimiser.HCRiskMeasureSolvers","text":"abstract type HCRiskMeasureSolvers <: HCRiskMeasure end\n\nAbstract type for subtyping HCRiskMeasure for which computing the risk requires solving an optimisation model.\n\nSee also: HCRiskMeasure, EDaR_r, RLDaR_r.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nsolvers::Union{Nothing, PortOptSolver, <:AbstractVector{PortOptSolver}}: (optional) instance or AbstractVector of PortOptSolver.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureOWA","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureOWA","text":"abstract type RiskMeasureOWA <: RiskMeasure end\n\nAbstract type for subtyping RiskMeasure which is implemented via an Ordered Weight Array formulation.\n\nSee also: RiskMeasure, GMD, TG, TGRG, OWA.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nformulation::OWAFormulation: property to store the formulation dispatch type.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RiskMeasureSkew","page":"Generalities","title":"PortfolioOptimiser.RiskMeasureSkew","text":"abstract type RiskMeasureSkew <: RiskMeasure end\n\nAbstract type for subtyping RiskMeasure which can use an N×N² coskew matrix and N×N matrix that stores the sum of the symmetric negative spectral slices of the coskewness.\n\nSee also: RiskMeasure, NQSkew, NQSSkew.\n\nImplementation\n\nConcrete subtypes must contain the following properties:\nskew::Union{<:AbstractMatrix, Nothing}: property to store an N×N² coskew matrix.\nV::Union{<:AbstractMatrix, Nothing}: property to store an N×N matrix that stores the sum of the symmetric negative spectral slices of the coskewness.\nIdeally perform any necessary validation checks at instantiation and setproperty!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#Constants","page":"Generalities","title":"Constants","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"It is useful to group risk measures by their properties as well as their types. By defining constants which group various risk measure types with certain characteristics, we can facilitate their use in the many different optimisation types offered by PortfolioOptimiser. This makes adding new features easier and simplifies the definition of customised behaviour.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMSolvers","page":"Generalities","title":"PortfolioOptimiser.RMSolvers","text":"const RMSolvers = Union{RiskMeasureSolvers, HCRiskMeasureSolvers}\n\nRisk measures that use solvers.\n\nSee also: RiskMeasureSolvers, HCRiskMeasureSolvers.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMSigma","page":"Generalities","title":"PortfolioOptimiser.RMSigma","text":"const RMSigma = Union{RiskMeasureSigma}\n\nRisk measures that use sigma.\n\nSee also: RiskMeasureSigma.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMSkew","page":"Generalities","title":"PortfolioOptimiser.RMSkew","text":"const RMSkew = Union{RiskMeasureSkew}\n\nRisk measures that use skew and V.\n\nSee also: RiskMeasureSkew.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMOWA","page":"Generalities","title":"PortfolioOptimiser.RMOWA","text":"const RMOWA = Union{RiskMeasureOWA}\n\nRisk measures that use Ordered Weight Array formulations.\n\nSee also: RiskMeasureOWA.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMMu","page":"Generalities","title":"PortfolioOptimiser.RMMu","text":"const RMMu = Union{RiskMeasureMu, HCRiskMeasureMu, NoOptRiskMeasureMu}\n\nRisk measures that use mu and w.\n\nSee also: RiskMeasureMu, HCRiskMeasureMu, NoOptRiskMeasureMu, calc_ret_mu.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMTarget","page":"Generalities","title":"PortfolioOptimiser.RMTarget","text":"const RMTarget = Union{RiskMeasureTarget, HCRiskMeasureTarget}\n\nRisk measures that use target, mu and w.\n\nSee also: RiskMeasureTarget, HCRiskMeasureTarget, calc_target_ret_mu.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#Settings","page":"Generalities","title":"Settings","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"Portfolio Optimisation has typically limited itself to using a single risk measure. However, some risk measures can/must use internal parameters in order to compute the risk. There is nothing preventing us from using multiple measures simultaneously, or even multiple instances of the same risk measure with different hyperparameters. This can be achieved via multiple objective optimisation (not currently supported, but may in the future), or a scalarisation procedure PortfolioOptimiser.AbstractScalarisation. Each instance's contribution to the overall risk expression is tunable via a weight parameter (called scale for disambiguation purposes).","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"For risk measures that can be used in optimisations using JuMP models, we must also provide a way to define their upper bound, and whether or not they should be included in the risk expression or used only for setting a risk upper bound.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/","page":"Generalities","title":"Generalities","text":"For these purposes, we have two special structures that need to be included in risk measures that are to be used in optimisations. The choice of which one to use depends on what optimisation types the risk measure is meant to be compatible with.","category":"page"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.AbstractRMSettings","page":"Generalities","title":"PortfolioOptimiser.AbstractRMSettings","text":"abstract type AbstractRMSettings end\n\nAbstract type for subtyping risk measure settings.\n\nSee also: RMSettings, HCRMSettings.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.RMSettings","page":"Generalities","title":"PortfolioOptimiser.RMSettings","text":"mutable struct RMSettings{T1 <: Real, T2 <: Real} <: AbstractRMSettings\n\nConfiguration settings for concrete subtypes of RiskMeasure. Having this property makes it possible for a risk measure to be used in any optimisation types that take risk measures as parameters.\n\nSee also: RiskMeasure, AbstractScalarisation, expected_risk.\n\nKeyword Arguments\n\nIn optimisations which take risk measures and use JuMP models\n\nflag::Bool = true:\nIf true: it is included in the optimisation's risk vector.\nIf false: it is not included in the optimisation's risk vector, used when you want to constrain the upper bound of a risk measure without having that risk measure appear in the MinRisk, Utility, or Sharpe objective measures.\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\nub::T2 = Inf: upper bound risk constraint.\n\nIn optimisations which take risk measures and do not use JuMP models\n\nflag::Bool = true: no effect, the risk cannot be bounded in these optimisations.\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\nub::T2 = Inf: no effect, the risk cannot be bounded in these optimisations.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures1-1/#PortfolioOptimiser.HCRMSettings","page":"Generalities","title":"PortfolioOptimiser.HCRMSettings","text":"mutable struct HCRMSettings{T1 <: Real} <: AbstractRMSettings\n\nConfiguration settings for concrete subtypes of HCRiskMeasure.\n\nSee also: HCRiskMeasure, AbstractScalarisation, expected_risk.\n\nKeyword Arguments\n\nscale::T1 = 1.0: weight parameter of the risk measure in the AbstractScalarisation method being used.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"#PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser","text":"","category":"section"},{"location":"#PortfolioOptimiser.PortfolioOptimiser","page":"Home","title":"PortfolioOptimiser.PortfolioOptimiser","text":"PortfolioOptimiser\n\nCategory Badge\nDocs (Image: Stable) (Image: Dev)\nExamples (Image: Binder)\nCI (Image: Tests) (Image: Documentation) (Image: Aqua)\nCoverage (Image: Codecov) (Image: Coveralls)\n\n\n\n\n\n","category":"module"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser is a library for portfolio optimisation. It offers a broad range of functionality, and is designed with ease of use, composability, extensibility, maintainability in mind. It does so by leveraging Julia's type system, multiple dispatch, and the principle of separation of concerns.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser takes a hands-off approach when it comes to solvers and solver settings. The built-in forumations are mostly conic in nature as these tend to yield more accurate solutions that are easier to solve. This means the choice of solver and its parameters are left to the user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library currently focues purely on optimisation and parameter estimation. There is currently no plan for backtesting, model selection, validation, or returns series generation. These may be implemented in the future as separate packages.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example shows how one can download the data and perform a simple optimisation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PortfolioOptimiser, TimeSeries, DataFrames, Clarabel, HiGHS, YFinance, Dates, JuMP\n\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Tickers of the assets we want to download.\nassets = sort!([\"SOUN\", \"RIVN\", \"GME\", \"AMC\", \"SOFI\", \"ENVX\", \"ANVS\", \"LUNR\", \"EOSE\", \"SMR\",\n                \"NVAX\", \"NKLA\", \"ACHR\", \"RKLB\", \"MARA\"])\n\n# Prices date range.\nDate_0 = \"2024-01-01\"\nDate_1 = \"2025-01-01\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\n\n# Convert vector of ordered dicts into a TimeArray.\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\n\n# Select only the adjusted close prices.\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\n\n# Rename the columns to the asset tickers.\nTimeSeries.rename!(prices, Symbol.(assets))\n\n# Generate the portfolio.\nportfolio = Portfolio(; prices = prices,\n                      # Continuous solvers.\n                      solvers = PortOptSolver(\n                                              # Key-value pair for the solver, solution acceptance \n                                              # criteria, model bridge argument, and solver attributes.\n                                              ; name = :Clarabel,\n                                              # Solver we wish to use.\n                                              solver = Clarabel.Optimizer,\n                                              # (Optional) Solution acceptance criteria.\n                                              check_sol = (allow_local = true,\n                                                           allow_almost = true),\n                                              # (Optional) Solver-specific attributes.\n                                              params = Dict(\"verbose\" => false,\n                                                            \"max_step_fraction\" => 0.75,\n                                                            \"tol_gap_abs\" => 1e-9,\n                                                            \"tol_gap_rel\" => 1e-9)),\n                      # Discrete solvers (for discrete allocation).\n                      alloc_solvers = PortOptSolver(\n                                                    # Key-value pair for the solver, solution acceptance \n                                                    # criteria, model bridge argument, and solver attributes.\n                                                    ; name = :HiGHS,\n                                                    # Solver we wish to use.\n                                                    solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                       MOI.Silent() => true),\n                                                    # (Optional) Solution acceptance criteria.\n                                                    check_sol = (allow_local = true,\n                                                                 allow_almost = true)))\n\n# Compute the asset statistics.\nasset_statistics!(portfolio)\n\n# Optimise the portfolio using the traditional Markowitz model with a conic formulation.\nw = optimise!(portfolio, Trad())\n\n# Discretely allocate 69420 dollars in shares of the assets.\nwd = allocate!(portfolio; investment = 69420)\n\n# Show discrete allocation with optimal allocation.\nwd.optimal_weights = w.weights\nDataFrames.rename!(wd, :weights => :allocated_weights)\nshow(wd)","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Non-hierarchical optimisation models\nTraditional, Trad.\nRisk Budgeting, RB.\nRelaxed Risk Budgetting (Variance only), RRB.\nNear Optimal Centering, NOC.\nHierarchical optimisation models\nHierarchical Risk Parity, HRP.\nHierarchical Risk Parity Schur Complement (Variance only), SchurHRP.\nHierarchical Equal Risk Parity, HERC.\nNested Clustered Optimisation, NCO.","category":"page"},{"location":"#Expected-returns-estimators","page":"Home","title":"Expected returns estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic (weighted and unweighted), MuSimple.\nEquilibrium, MuEquil.\nShringage with Grand Mean GM, Volatility Weighted VW, and Mean Square Error MSE targets:\nJames-Stein, MuJS.\nBayes-Stein, MuBS.\nBodnar-Okhrin-Parolya, MuBOP.","category":"page"},{"location":"#Covariance-estimators","page":"Home","title":"Covariance estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These utilise StatsBase's API to define covariance estimators. Which means PortfolioOptimiser is compatible with CovarianceEstimation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PortfolioOptimiser, PortCovCor.\nFull, CovFull.\nSemi, CovSemi.\nMutual Information, CovMutualInfo.\nDistance, CovDistance.\nLower Tail Dependence, CovLTD.\nGerber, CovGerber0, CovGerber1, CovGerber2.\nSmyth-Broby, CovSB0, CovSB1, CovSB2.\nSmyth-Broby-Gerber, CovGerberSB0, CovGerberSB1, CovGerberSB2.","category":"page"},{"location":"#Correlation-estimators","page":"Home","title":"Correlation estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These utilise StatsBase's API to define covariance estimators. Which means PortfolioOptimiser is compatible with CovarianceEstimation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All covariance estimators.\nSpearman, CorSpearman.\nKendall, CorKendall.","category":"page"},{"location":"#Distance-estimators","page":"Home","title":"Distance estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide distance and distance of distances estimators. Distance estimators have the prefix Dist, distance of distances have the prefix DistDist.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Canonical, DistCanonical, DistDistCanonical.\nMarcos López de Prado, DistMLP, DistDistMLP.\nGeneralised Marcos López de Prado, GenDistMLP, GenDistDistMLP.\nLog, DistLog, DistDistLog.\nDistance correlation, DistCor, DistDistCor.\nVariation of information, DistVarInfo, DistDistVarInfo.","category":"page"},{"location":"#Cokurtosis-estimators","page":"Home","title":"Cokurtosis estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full, KurtFull.\nSemi, KurtSemi.","category":"page"},{"location":"#Coskewness-estimators","page":"Home","title":"Coskewness estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full, SkewFull.\nSemi, SkewSemi.","category":"page"},{"location":"#Square-matrix-post-processing","page":"Home","title":"Square matrix post-processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fixing non-positive definite matrices, NoPosdef, PosdefNearest.\nMatrix denoising, NoDenoise, DenoiseFixed, DenoiseSpectral, DenoiseShrink.\nMatrix detoning, NoDetone, Detone.\nLocal-global sparsification of the matrix inverse, NoLoGo, LoGo.","category":"page"},{"location":"#Prior-estimators","page":"Home","title":"Prior estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Empirical, asset_statistics!.\nWorst-case uncertainty sets, wc_statistics!.\nFactor models, factor_statistics!.\nBlack-Litterman, black_litterman_statistics!.\nBlack-Litterman factor models, black_litterman_factor_statistics!.","category":"page"},{"location":"#Regression-models","page":"Home","title":"Regression models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward and Backward Regression, FReg, BReg, with criteria.\np-value threshold, PVal.\nAkaike's Information Criterion, AIC.\nCorrected Akaike's Information Criterion for small sample sizes, AICC.\nBayesian Information Criterion, BIC.\nR² of a linear model, RSq.\nadjusted R² for a linear model, AdjRSq.\nPrincipal Component-Based Regression, PCAReg, with targets.\nPCA target, PCATarget.\nProbabilistic PCA target, PPCATarget.","category":"page"},{"location":"#Worst-case-uncertainty-set-estimators","page":"Home","title":"Worst-case uncertainty set estimators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These are only for the covariance and expected returns.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Box and Elliptical sets, Box, Ellipse.\nAutoregressive Conditional Heteroskedasticity models, ArchWC, with bootstraps.\nStationary, StationaryBS.\nCircular, CircularBS.\nMoving, MovingBS.\nNormal, NormalWC.\nBox sets only.\nDelta, DeltaWC.\nElliptical set constraint error size estimation.\nNormal, KNormalWC.\nGeneral, KGeneralWC","category":"page"},{"location":"#Clustering","page":"Home","title":"Clustering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Bubble Hierarchy Trees, DBHT.\nHierarchical clustering, HAC.\nOptimal number of clusters.\nTwo-difference gap statistic, TwoDiff.\nStandardised silhouette scores, StdSilhouette.","category":"page"},{"location":"#Networks","page":"Home","title":"Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Triangular maximally filtered graphs (TMFG), TMFG.\nMinimum spanning trees (MST), MST.\nKruskal, KruskalTree.\nBoruvka, BoruvkaTree.\nPrim, PrimTree.\nCentrality measures.\nBetweenness, BetweennessCentrality.\nCloseness, ClosenessCentrality.\nDegree, DegreeCentrality.\nEigenvector, EigenvectorCentrality.\nKatz, KatzCentrality.\nPagerank, Pagerank.\nRadiality, RadialityCentrality.\nStress, StressCentrality.","category":"page"},{"location":"","page":"Home","title":"Home","text":"UP TO HERE","category":"page"},{"location":"#Black-Litterman-models","page":"Home","title":"Black Litterman models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Black Litterman, BLType.","category":"page"},{"location":"#Black-Litterman-factor-models","page":"Home","title":"Black Litterman factor models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Augmented Black Litterman, ABLType.\nBayesian Black Litterman, BBLType.","category":"page"},{"location":"#Linear-moments-(L-moments)","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Normalised constant relative risk aversion coefficients, CRRA.\nMaximum entropy, MaxEntropy.\nMinimum Sum of Squares, MinSumSq.\nMinimum Square Distance, MinSqDist.","category":"page"},{"location":"#Portfolio-optimisation","page":"Home","title":"Portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of Portfolio.","category":"page"},{"location":"#Traditional,-[Trad](@ref)","page":"Home","title":"Traditional, Trad","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation is the traditional efficient frontier optimisation.","category":"page"},{"location":"#Classes,-[PortClass](@ref)","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Objective-functions","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-measures","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, NQSkew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation (Sortino ratio), SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, NQSSkew.","category":"page"},{"location":"#Downside","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-2","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Worst-case-mean-variance","page":"Home","title":"Worst case mean variance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires worst case sets for the covariance and expected returns. The optimisation uses these sets to perform a mean variance optimisation.","category":"page"},{"location":"#Constraints-2","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected worst case standard deviation constraint.\nMinimum expected worst case return constraint.\nLinear weight constraints.\nConnected asset centrality constraints.\nAsset network constraints.\nLeverage constraints.\nMaximum number of assets constraint.\nMinimum number of effective assets constraint.\nTracking error (weights or returns) constraint.\nTurnover constraint.\nRebalancing penalty.","category":"page"},{"location":"#Risk-parity,-[RB](@ref)","page":"Home","title":"Risk parity, RB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset or factor. The optimisation attempts to minimise the difference between the risk budget and risk contribution of the asset or factor in the optimised portfolio.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-2","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nFactor risk contribution, FC.","category":"page"},{"location":"#Constraints-3","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Risk-measures-2","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-2","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, NQSkew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation (Sortino ratio), SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, NQSSkew.","category":"page"},{"location":"#Downside-2","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-2","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-3","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Relaxed-risk-parity-mean-variance,-[RRB](@ref)","page":"Home","title":"Relaxed risk parity mean variance, RRB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This type of optimisation requires a risk budget per asset. The optimisation attempts to minimise the difference between the risk budget and relaxed formulation of the standard deviation risk measure.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-3","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.","category":"page"},{"location":"#Constraints-4","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Near-Optimal-Centering,-[NOC](@ref)","page":"Home","title":"Near Optimal Centering, NOC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Near optimal centering utilise the weights of an optimised portfolio. It computes a region of near optimality using the bounds of the efficient frontier, the expected risk and return of the optimal portfolio, and a user-provided parameter. It then optimises for a portfolio that best describes the region. It provides more diversification and robustness than Trad and smooths out the weight transitions as the efficient frontier is traversed.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-4","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Constraints-5","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.\nLinear weight constraints.","category":"page"},{"location":"#Classes,-[PortClass](@ref)-5","page":"Home","title":"Classes, PortClass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Classic, Classic.\nFactor model, FM.\nBlack Litterman, BL.\nBlack Litterman Factor model, BLFM.","category":"page"},{"location":"#Expected-returns-2","page":"Home","title":"Expected returns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arithmetic returns, NoKelly.\nApproximate logarithmic mean returns, AKelly.\nExact logarithmic mean returns, EKelly.","category":"page"},{"location":"#Constraints-6","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.","category":"page"},{"location":"#Risk-measures-3","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-3","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, NQSkew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi standard deviation (Sortino ratio), SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, NQSSkew.","category":"page"},{"location":"#Downside-3","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-3","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.","category":"page"},{"location":"#Linear-moments-(L-moments)-4","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Hierarchical-portfolio-optimisation","page":"Home","title":"Hierarchical portfolio optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These types of optimisations act on instances of .","category":"page"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref),-and-hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical risk parity, HRP, and hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"#Hierarchical-risk-parity,-[HRP](@ref)","page":"Home","title":"Hierarchical risk parity, HRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical risk parity optimisations use the hierarchical clustering of assets to assign risk contributions by iteratively splitting the dendrogram in half and assigning weights to each half according to the relative risk each half represents with respect to the other. It does this until it splits the dendrogram all the way down to single leaves.","category":"page"},{"location":"#Hierarchical-equal-risk-parity,-[HERC](@ref)","page":"Home","title":"Hierarchical equal risk parity, HERC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical equal risk parity optimisations use the hierarchical clustering relationships between assets to assign risk contributions by splitting the dendrogram into k clusters. It starts with the full dendrogram and progressively cuts it into k-1 levels (since the comparison for each side belongs to the k-th level). At each step, it loops through the clusters and checks to which side of the sub-dendrogram the cluster belongs. It accumulates the risk of that cluster to the risk of the side it belongs to. The weights for the assets on each side of the dendrogram are assigned based on the relative (with respect to the other side) aggregate risk from all clusters belonging to it, these are the inter-cluster weights. It then computes the risk for each cluster, assigning weights to each asset according to the relative risk it represents with respect to other assets, these are the intra-cluster weights. It then elementwise multiplies both weights to get the final asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HERC can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Constraints-7","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum and maximum weights per asset.","category":"page"},{"location":"#Risk-measures-4","page":"Home","title":"Risk measures","text":"","category":"section"},{"location":"#Dispersion-4","page":"Home","title":"Dispersion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full dispersion.\nVariance, Variance.\nStandard deviation, SD.\nMean absolute deviation (MAD), MAD.\nSquare root kurtosis, Kurt.\nRange, RG.\nConditional value at risk range (CVaR range), CVaRRG.\nTail Gini range, TGRG.\nGini mean difference (GMD), GMD.\nQuadratic negative skewness, NQSkew.\nBrownian distance variance (BDVariance), BDVariance.\nDownside dispersion.\nSemi Variance, Variance.\nSemi standard deviation (Sortino ratio), SSD.\nFirst lower partial moment (Omega ratio), FLPM.\nSquare root semi kurtosis, SKurt.\nQuadratic negative semi skewness, NQSSkew.","category":"page"},{"location":"#Downside-4","page":"Home","title":"Downside","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Worst case realisation (Minimax), WR.\nValue at risk (VaR), VaR.\nConditional value at risk (CVaR), CVaR.\nEntropic value at risk (EVaR), EVaR.\nRelativistic value at risk (RLVaR), RLVaR.\nTail Gini, TG.","category":"page"},{"location":"#Drawdown-4","page":"Home","title":"Drawdown","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximum drawdown (Calmar ratio) for uncompounded cumulative returns, MDD.\nAverage drawdown for uncompounded cumulative returns, ADD.\nUlcer index for uncompounded cumulative returns, UCI.\nDrawdown at for uncompounded cumulative returns risk (DaR), DaR.\nConditional drawdown at risk for uncompounded cumulative returns (CDaR), CDaR.\nEntropic drawdown at risk for uncompounded cumulative returns (EDaR), EDaR.\nRelativistic drawdown at risk for uncompounded cumulative returns (RLDaR), RLDaR.\nMaximum drawdown (Calmar ratio) for compounded cumulative returns, MDD_r.\nAverage drawdown for compounded cumulative returns, ADD_r.\nUlcer index for compounded cumulative returns, UCI_r.\nDrawdown at for compounded cumulative returns risk (DaR), DaR_r.\nConditional drawdown at risk for compounded cumulative returns (CDaR), CDaR_r.\nEntropic drawdown at risk for compounded cumulative returns (EDaR), EDaR_r.\nRelativistic drawdown at risk for compounded cumulative returns (RLDaR), RLDaR_r.","category":"page"},{"location":"#Linear-moments-(L-moments)-5","page":"Home","title":"Linear moments (L-moments)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"L-moment ordered weight array, OWA.","category":"page"},{"location":"#Equal-Risk-Contribution","page":"Home","title":"Equal Risk Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equal risk contribution, Equal.","category":"page"},{"location":"#Nested-clustered-optimisation,-[NCO](@ref)","page":"Home","title":"Nested clustered optimisation, NCO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nested clustered optimisation combines the ideas of hierarchical equal risk parity optimisations and portfolio optimisations. They use the hierarchical clustering relationships between assets and splitting the dendrogram into k clusters. It then treats each cluster as its own isntance of Portfolio which is optimised in the usual way. The weights of each cluster are saved in a matrix, these are the intra-cluster weights. Then each cluster as a whole is treated as a synthetic asset, it statistics are internally computed from the fields in the NCO type. An instance of Portfolio is created from these synthetic assets and then optimised, these are the inter-cluster weights. The inter-cluster and intra-cluster weights are multiplied to give the asset weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NCO can make use of two risk measure arguments, one for the intra-cluster and one for the inter-cluster risk calculation. They can take linear combinations of risk measures.","category":"page"},{"location":"#Sub-types","page":"Home","title":"Sub-types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NCO can take keyword arguments that define the supported by optimisations of Portfolio. Since there are intra- and inter-cluster optimisations, it can take individual arguments for both. This means it can perform any combination of Portfolio optimisations.","category":"page"},{"location":"#NCO-Trad,-NCO-NOC-Trad","page":"Home","title":"NCO-Trad, NCO-NOC-Trad","text":"","category":"section"},{"location":"#Objective-functions-2","page":"Home","title":"Objective functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimum risk, MinRisk.\nMaximum utility, Utility.\nMaximum risk adjusted return ratio, Sharpe.\nMaximum return, MaxRet.","category":"page"},{"location":"#Constraints-8","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Maximum expected risk constraints.\nMinimum expected return constraint.\nLeverage constraints.","category":"page"},{"location":"#NCO-RB,-NCO-RRB,-NCO-NOC-RB,-NCO-NOC-RRB","page":"Home","title":"NCO-RB, NCO-RRB, NCO-NOC-RB, NCO-NOC-RRB","text":"","category":"section"},{"location":"#Constraints-9","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When applied to the intra-cluster optimisation the same constraint will be applied to all every cluster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimum expected return constraint.","category":"page"},{"location":"Portfolio/PortfolioTypes/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#Public","page":"Types","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"mutable struct Portfolio{ast, dat, r, tfa, tfdat, tretf, l, lo, s, us, ul, nal, nau, naus,\n                         mnak, mnaks, rb, to, kte, blbw, ami, bvi, rbv, frbv, nm, amc, bvc,\n                         ler, tmu, tcov, tkurt, tskurt, tl2, ts2, tskew, tv, tsskew, tsv,\n                         tmuf, tcovf, trfm, tmufm, tcovfm, tmubl, tcovbl, tmublf, tcovblf,\n                         tcovl, tcovu, tcovmu, tcovs, tdmu, tkmu, tks, topt, tlim, tfront,\n                         tsolv, tf, tmod, tlp, taopt, talo, tasolv, taf, tamod} <:\n               AbstractPortfolio\n    assets::ast\n    timestamps::dat\n    returns::r\n    f_assets::tfa\n    f_timestamps::tfdat\n    f_returns::tretf\n    loadings::l\n    regression_type::lo\n    short::s\n    short_lb::us\n    long_ub::ul\n    num_assets_l::nal\n    num_assets_u::nau\n    num_assets_u_scale::naus\n    max_num_assets_kurt::mnak\n    max_num_assets_kurt_scale::mnaks\n    turnover::to\n    tracking_err::kte\n    bl_bench_weights::blbw\n    a_mtx_ineq::ami\n    b_vec_ineq::bvi\n    risk_budget::rbv\n    f_risk_budget::frbv\n    network_adj::nm\n    a_vec_cent::amc\n    b_cent::bvc\n    mu_l::ler\n    mu::tmu\n    cov::tcov\n    kurt::tkurt\n    skurt::tskurt\n    L_2::tl2\n    S_2::ts2\n    skew::tskew\n    V::tv\n    sskew::tsskew\n    SV::tsv\n    f_mu::tmuf\n    f_cov::tcovf\n    fm_returns::trfm\n    fm_mu::tmufm\n    fm_cov::tcovfm\n    bl_mu::tmubl\n    bl_cov::tcovbl\n    blfm_mu::tmublf\n    blfm_cov::tcovblf\n    cov_l::tcovl\n    cov_u::tcovu\n    cov_mu::tcovmu\n    cov_sigma::tcovs\n    d_mu::tdmu\n    k_mu::tkmu\n    k_sigma::tks\n    optimal::topt\n    limits::tlim\n    frontier::tfront\n    solvers::tsolv\n    fail::tf\n    model::tmod\n    latest_prices::tlp\n    alloc_optimal::taopt\n    alloc_leftover::talo\n    alloc_solvers::tasolv\n    alloc_fail::taf\n    alloc_model::tamod\nend\n\nStructure for defining a traditional portfolio. Na is the number of assets, and Nf is the number of factors. For details on how some of these parameters are computed see asset_statistics!, wc_statistics!, factor_statistics!, black_litterman_statistics!, and black_litterman_factor_statistics!.\n\nParameters\n\nassets: Na×1 vector of asset names.\ntimestamps: T×1 vector of asset returns timestamps.\nreturns: T×Na matrix of asset returns.\nf_assets: Nf×1 vector of factor names.\nf_timestamps: T×1 vector of factor returns timestamps.\nf_returns: T×Nf matrix of asset returns.\nloadings: loadings matrix for working with factor models.\nregression_type: RegressionType used for computing the loadings matrix.\nshort:\nif true: shorting is enabled.\nelse: long-only portfolio.\nshort_lb: upper bound for the absolute value of the sum of the negative weights.\nlong_ub: upper bound for the sum of the positive weights.\nnum_assets_l: lower bound for the minimum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u: upper bound for the maximum number of significant assets.\nif > 0: applies the constraint.\nnum_assets_u_scale: scaling factor for the decision variable used for applying the num_assets_u constraint when optimising the Sharpe objective function.\nmax_num_assets_kurt: maximum number of assets to use the complete kurtosis model.\nif > 0: the approximate model will be used if the number of assets in the portfolio exceeds max_number_assets_kurt.\nmax_num_assets_kurt_scale: multipies Na to find the number of eigenvalues when computing the approximate kurtosis model, must be ∈ [1, Na].\nbeginalign\np_r = sumlimits_i=1^N r_i lvert w_i - b_i rvert\nendalign\nWhere:\np_r is the portfolio rebalancing penalty.\nN is the number of assets.\nr_i is the rebalancing penalty for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nturnover: AbstractTR for defining the asset turnover constraint.\nbeginalign\nlvert w_i - b_i rvert leq t_iquad forall i = 1ldotsN\nendalign\nWhere:\nt_i is the turnover constraint for the i-th asset.\nw_i is the weight of the i-th asset.\nb_i is the benchmark weight of the i-th asset.\nN is the number of assets.\ntracking_err: TrackingErr for defining the tracking error constraint.\nbeginalign\nleftlVert dfracmathbfX bmw - bmbT - 1 rightrVert_2 leq epsilon\nendalign\nWhere:\nlVert cdot rVert_2 is the L2 norm.\nmathbfX is the T times N matrix of asset returns.\nT is the number of returns observations.\nN is the number of assets.\nbmw is the N times 1 vector of asset weights.\nbmb is the T times 1 vector of benchmark returns.\nepsilon is the tracking error.\nbl_bench_weights: benchmark weights for Black-Litterman models BlackLittermanClass.\na_mtx_ineq: C×N matrix of asset weight linear constraints.\nif isempty: the constraint is not set.\nb_vec_ineq: C×1 vector of asset weight linear constraints.\nif isempty: the constraint is not set.\nThe linear weight constraint is defined as.\nbeginalign\nmathbfA bmw geq bmb\nendalign\nWhere:\nmathbfA is the CN matrix of asset weight linear constraints.\nbmb is the C1 vector of asset weight linear constraints.\nC is the number of constraints.\nN is the number of assets.\nrisk_budget: Na×1 vector of asset risk budgets.\nf_risk_budget: Nf×1 vector of factor risk budgets.\nnetwork_adj: AdjacencyConstraint for defining the asset network constraint. This can be defined in two ways, using an exact mixed-integer approach IP or an approximate semi-definite one SDP. See their docs for the constraint definition for each case.\nif NoAdj: the constraint is not set.\na_vec_cent: centrality vector for defining the centrality constraint.\nif isempty: the constraint is not set.\nb_cent: average centrality of the assets the portfolio.\nif isinf: the constraint is not set.\nThe centrality constraint is defined as.\nbeginalign\nbmC cdot bmw = barc\nendalign\nWhere:\nbmw is the Ntimes 1 vector of asset weights.\nbmC is the N times 1 centrality vector of the asset adjacency matrix.\ncdot is the dot product.\nbarc is the desired average centrality measure of the portfolio.\nmu_l: lower bound for the expected return of the portfolio.\nif is Inf: the constraint is not applied.\nmu: Na×1 vector of asset expected returns.\ncov: Na×Na asset covariance matrix.\nkurt: Na^2×Na^2 cokurtosis matrix.\nskurt: Na^2×Na^2 semi cokurtosis matrix.\nL_2: (Na^2)×((Na^2 + Na)/2) elimination matrix.\nS_2: ((Na^2 + Na)/2)×(Na^2) summation matrix.\nskew: Na×Na^2 coskew matrix.\nV: Na×Na sum of the symmetric negative spectral slices of coskewness.\nsskew: Na×Na^2 semi coskew matrix.\nSV: Na×Na sum of the symmetric negative spectral slices of semi coskewness.\nf_mu: Nf×1 vector of factor expected returns.\nf_cov: Nf×Nf factor covariance matrix.\nfm_returns: T×Na factor model adjusted returns matrix.\nfm_mu: Na×1 factor model adjusted asset expected returns.\nfm_cov: Na×Na factor model adjusted asset covariance matrix.\nbl_mu: Na×1 Black Litterman model adjusted asset expected returns.\nbl_cov: Na×Na Black Litterman model adjusted asset covariance matrix.\nblfm_mu: Na×1 Black Litterman factor model adjusted asset expected returns.\nblfm_cov: Na×Na Black Litterman factor model adjusted asset covariance matrix.\ncov_l: Na×Na lower bound for the worst case covariance matrix.\ncov_u: Na×Na upper bound for the worst case covariance matrix.\ncov_mu: Na×Na matrix of the estimation errors of the asset expected returns vector set.\ncov_sigma: Na×Na matrix of the estimation errors of the asset covariance matrix set.\nd_mu: absolute deviation of the worst case upper and lower asset expected returns vectors.\nk_mu: distance parameter of the uncertainty in the asset expected returns vector for the worst case optimisation.\nk_sigma: distance parameter of the uncertainty in the asset covariance matrix for the worst case optimisation.\noptimal: collection capable of storing key value pairs for storing optimal portfolios.\nlimits: collection capable of storing key value pairs for storing the minimal and maximal risk portfolios.\nfrontier: collection capable of storing key value pairs for containing points in the efficient frontier.\nsolvers: collection capable of storing key value pairs for storing JuMP-supported solvers. They must have the following structure.\nsolvers = Dict(\n               # Key-value pair for the solver, solution acceptance \n               # criteria, and solver attributes.\n               :Clarabel => Dict(\n                                 # Solver we wish to use.\n                                 :solver => Clarabel.Optimizer,\n                                 # (Optional) Solution acceptance criteria.\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 # (Optional) Solver-specific attributes.\n                                 :params => Dict(\"verbose\" => false)))\nThe dictionary contains a key value pair for each solver (plus optional solution acceptance criteria and optional attributes) we want to use.\n:solver: defines the solver to use. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.\n:check_sol: (optional) defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\n:params: (optional) defines solver-specific parameters.\nUsers are also able to provide multiple solvers by adding additional key-value pairs to the top-level dictionary as in the following snippet.\nusing JuMP\nsolvers = Dict(:Clarabel => Dict(:solver => Clarabel.Optimizer,\n                                 :check_sol => (allow_local = true, allow_almost = true),\n                                 :params => Dict(\"verbose\" => false)),\n               # Provide solver with pre-attached attributes and no arguments \n               # for the `JuMP.is_solved_and_feasible` function.\n               :COSMO => Dict(:solver => JuMP.optimizer_with_attributes(COSMO.Optimizer,\n                                                                        \"maxiter\" => 5000)))\noptimise! will iterate over the solvers until it finds the first one to successfully solve the problem.\nfail: collection capable of storing key value pairs for storing failed optimisation attempts.\nmodel: JuMP.Model which defines the optimisation model.\nlatest_prices: Na×1 vector of latest asset prices.\nalloc_optimal: collection capable of storing key value pairs for storing optimal discretely allocated portfolios.\nalloc_leftover: collection capable of storing key value pairs for containing points in the leftover investment after allocating.\nalloc_solvers: collection capable of storing key value pairs for storing JuMP-supported solvers that support Mixed-Integer Programming, only used in the LP allocation.\nalloc_fail: collection capable of storing key value pairs for storing failed discrete asset allocation attempts.\nalloc_model: JuMP.Model which defines the discrete asset allocation model.\n\n\n\n\n\n","category":"type"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.Portfolio-Tuple{}","page":"Types","title":"PortfolioOptimiser.Portfolio","text":"Portfolio(; prices::TimeArray = TimeArray(TimeType[], []),\n            returns::DataFrame = DataFrame(),\n            ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            timestamps::AbstractVector = Vector{Date}(undef, 0),\n            assets::AbstractVector = Vector{String}(undef, 0),\n            f_prices::TimeArray = TimeArray(TimeType[], []),\n            f_returns::DataFrame = DataFrame(),\n            f_ret::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_timestamps::AbstractVector = Vector{Date}(undef, 0),\n            f_assets::AbstractVector = Vector{String}(undef, 0),\n            loadings::DataFrame = DataFrame(),\n            regression_type::Union{<:RegressionType, Nothing} = nothing,\n            short::Bool = false, short_lb::Real = 0.2, long_ub::Real = 1.0,\n            num_assets_l::Integer = 0, num_assets_u::Integer = 0,\n            num_assets_u_scale::Real = 100_000.0, max_num_assets_kurt::Integer = 0,\n            max_num_assets_kurt_scale::Integer = 2, \n            turnover::AbstractTR = NoTR(), tracking_err::TrackingErr = NoTracking(),\n            bl_bench_weights::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            a_mtx_ineq::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            b_vec_ineq::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_risk_budget::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            network_adj::AdjacencyConstraint = NoAdj(),\n            a_vec_cent::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            b_cent::Real = Inf, mu_l::Real = Inf,\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            kurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skurt::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            skew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            sskew::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            f_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            f_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_returns::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            fm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            fm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            bl_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            bl_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            blfm_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            blfm_cov::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_l::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_u::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_mu::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            cov_sigma::AbstractMatrix{<:Real} = Matrix{Float64}(undef, 0, 0),\n            d_mu::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            k_mu::Real = Inf, k_sigma::Real = Inf, optimal::AbstractDict = Dict(),\n            limits::AbstractDict = Dict(), frontier::AbstractDict = Dict(),\n            solvers::AbstractDict = Dict(), fail::AbstractDict = Dict(),\n            model::JuMP.Model = JuMP.Model(),\n            latest_prices::AbstractVector{<:Real} = Vector{Float64}(undef, 0),\n            alloc_optimal::AbstractDict = Dict(),\n            alloc_leftover::AbstractDict = Dict(),\n            alloc_solvers::AbstractDict = Dict(), alloc_fail::AbstractDict = Dict(),\n            alloc_model::JuMP.Model = JuMP.Model())\n\nConstructor for Portfolio. Performs data validation checks and automatically extracts the data from prices, returns, f_prices, and f_returns if they are provided.\n\nInputs\n\nprices: (T+1)×Na TimeArray of asset prices.\nIf provided: will take precedence over returns, ret, timestamps, assets, and latest_prices because they will be automatically computed from prices.\nreturns: T×Na DataFrame of asset returns.\nIf provided: will take precedence over ret, timestamps, and assets because they will be automatically computed from returns.\nret: set the returns matrix directly.\ntimestamps: set timestamps.\nassets: set assets.\nf_prices: (T+1)×Nf TimeArray of factor prices.\nIf provided: will take precedence over f_returns, f_ret, f_timestamps, and f_assets because they will be automatically computed from f_prices.\nf_returns: T×Nf DataFrame of factor returns.\nIf provided: will take precedence over f_ret, f_timestamps, and f_assets because they will be automatically computed from returns.\nf_ret: set the f_returns matrix directly.\n\nThe rest of the inputs directly set their corresponding property.\n\nOutputs\n\nportfolio: an instance of Portfolio.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioTypes/#Private","page":"Types","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioTypes/#PortfolioOptimiser.AbstractPortfolio","page":"Types","title":"PortfolioOptimiser.AbstractPortfolio","text":"abstract type AbstractPortfolio end\n\nAbstract type for subtyping portfolios.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackingErr","page":"Constraints","title":"PortfolioOptimiser.TrackingErr","text":"abstract type TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTracking","page":"Constraints","title":"PortfolioOptimiser.NoTracking","text":"struct NoTracking <: TrackingErr end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackRet","page":"Constraints","title":"PortfolioOptimiser.TrackRet","text":"@kwdef mutable struct TrackRet{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TrackWeight","page":"Constraints","title":"PortfolioOptimiser.TrackWeight","text":"@kwdef mutable struct TrackWeight{T1 <: Real, T2 <: AbstractVector{<:Real}} <: TrackingErr\n    err::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AbstractTR","page":"Constraints","title":"PortfolioOptimiser.AbstractTR","text":"abstract type AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoTR","page":"Constraints","title":"PortfolioOptimiser.NoTR","text":"struct NoTR <: AbstractTR end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.TR","page":"Constraints","title":"PortfolioOptimiser.TR","text":"@kwdef mutable struct TR{T1 <: Union{<:Real, <:AbstractVector{<:Real}},\n                         T2 <: AbstractVector{<:Real}} <: AbstractTR\n    val::T1 = 0.0\n    w::T2 = Vector{Float64}(undef, 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Public","page":"Constraints","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AKelly","page":"Constraints","title":"PortfolioOptimiser.AKelly","text":"@kwdef mutable struct AKelly <: RetType\n    formulation::VarianceFormulation = SOC()\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.EKelly","page":"Constraints","title":"PortfolioOptimiser.EKelly","text":"struct EKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.IP","page":"Constraints","title":"PortfolioOptimiser.IP","text":"@kwdef struct IP{T1 <: AbstractMatrix{<:Real},\n                 T2 <: Union{<:Integer, <:AbstractVector{<:Integer}}, T3 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    k::T2 = 1\n    scale::T3 = 100_000.0\nend\n\nDefines the exact network constraint using mixed-integer programming.\n\nbeginalign\nleft(mathbfA + mathbfIright)bmy leq bmk\nw_i leq b_u y_i quad forall i = 1ldotsN \nw_i geq b_l y_i quad forall i = 1ldotsN\nendalign\n\nWhere:\n\nmathbfA is the N times N adjacency matrix.\nmathbfI is the identity matrix.\n\nSince each row of left(mathbfA + mathbfIright) corresponds to a path, duplicate rows add no new information whilst increasing the problem's size, therefore we only store unique rows.\n\nbmy is an N times 1 vector of binary 01 decision variables, which decide whether or not the asset should be included in the portfolio.\nbmk:\nif is a vector: Mtimes 1 vector defining the maximum number of assets allowed per unique path, where M is the number of unique paths.\nif is a scalar: defines the maximum number of assets allowed for all unique paths.\nw_i is the i-th asset weight.\nb_ub_l are the upper and lower bounds of the sum of the long and sum of the short asset weights, respectively.\nThus the constraint means we will invest in at most bmk assets per corresponding unique path.\n\nThis approach can be appied to any risk measure without work arounds like SDP. However it is more computationally costly to optimise, and may fail when mathbfA is close to the all ones matrix.\n\nParameters\n\nA: adjacency matrix, only stores unique(A + I, dims = 1).\nk:\nif is a vector: maximum number of assets per unique path.\nif A is not empty, checks that the length of k is equal to the size of unique(A + I, dims = 1).\nif is a scalar: maximum number of assets for all unique paths.\nscale: scaling variable for an auxiliary binary decision variable when optimising the Sharpe objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoAdj","page":"Constraints","title":"PortfolioOptimiser.NoAdj","text":"struct NoAdj <: AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoKelly","page":"Constraints","title":"PortfolioOptimiser.NoKelly","text":"struct NoKelly <: RetType end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.SDP","page":"Constraints","title":"PortfolioOptimiser.SDP","text":"@kwdef mutable struct SDP{T1 <: AbstractMatrix{<:Real}, T2 <: Real} <: AdjacencyConstraint\n    A::T1 = Matrix{Float64}(undef, 0, 0)\n    penalty::T2 = 0.05\nend\n\nDefines an approximate network constraint using semi-definite programming.\n\nbeginalign\nbeginbmatrix\nmathbfW  bmw\nbmw^intercal  1\nendbmatrix succeq 0\nmathbfW = mathbfW^intercal\nmathbfA odot mathbfW = bm0\nendalign\n\nWhere:\n\nmathbfW is an auxiliary variable that approximates the outer product of asset weights bmw otimes bmw.\nmathbfA is the Ntimes N adjacency matrix. It tells us which assets are connected. The matrix can only take values of 1 or 0. If entry (ij) is equal to 1, assets i and j are connected.\nodot is the Hadamard (element-wise) product.\n\nWhen the variance risk measure SD is being used, whether in the objective function or as one of the risk constraints. Its definition will change when this constraint is active. The new definition is this.\n\nbeginalign\nphi_mathrmvar(bmw) = mathrmTrleft(mathbfSigmamathbfWright)\nendalign\n\nWhere:\n\nmathrmTr(cdot) is the trace operator.\nmathbfSigma is the covariance matrix.\n\nHowever, this will not work if the variance is not being constrained, or if it is not in the objective function. For that we add/subtract the following penalty factor to the objective function.\n\nbeginalign\nundersetbmwmathrmopt quad phi(bmw) pm lambda mathrmTrleft(mathbfXright)\nendalign\n\nWhere:\n\nmathrmopt is mathrmmin when the objective is convex and mathrmmax when it is concave.\npm is + when the objective is convex and - when it is concave.\nlambda is a penalty factor.\n\nThis approach works better than IP when mathbfA is close to the all ones matrix, even though it's an approximation.\n\nParameters\n\nA: N×N adjacency matrix.\npenalty: penalty factor when the variance SD risk measure isn't being used, either in a constraint or in the objective function.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#Private","page":"Constraints","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.AdjacencyConstraint","page":"Constraints","title":"PortfolioOptimiser.AdjacencyConstraint","text":"abstract type AdjacencyConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.CustomConstraint","page":"Constraints","title":"PortfolioOptimiser.CustomConstraint","text":"abstract type CustomConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.NoCustomConstraint","page":"Constraints","title":"PortfolioOptimiser.NoCustomConstraint","text":"struct NoCustomConstraint <: CustomConstraint end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/OptimisationConstraints/#PortfolioOptimiser.RetType","page":"Constraints","title":"PortfolioOptimiser.RetType","text":"abstract type RetType end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#Distance-matrices","page":"Distance matrices","title":"Distance matrices","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#Public","page":"Distance matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistCanonical","text":"struct DistCanonical <: DistType end\n\nStruct for computing the canonical distance for a given correlation estimator in default_dist.\n\nCorrelation estimator Canonical distance\nCovMutualInfo DistVarInfo\nCovLTD DistLog\nCovDistance DistCor\nAny other estimator DistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistCor","text":"struct DistCor <: DistType end\n\nDefines the distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCanonical","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCanonical","text":"struct DistDistCanonical <: DistType end\n\nStruct for computing the canonical distance for a given correlation estimator in default_dist.\n\nCorrelation estimator Canonical distance\nCovMutualInfo DistDistVarInfo\nCovLTD DistDistLog\nCovDistance DistDistCor\nAny other estimator DistDistMLP\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistCor","page":"Distance matrices","title":"PortfolioOptimiser.DistDistCor","text":"struct DistdistCor <: DistType end\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = sqrt1 - C_ij\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix.\nC_ij: is the  (ij)-th entry of a distance correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistDistLog","text":"@kwdef mutable struct DistDistLog <: DistType\n    distance::Distances.Metric\n    args::Tuple\n    kwargs::NamedTuple\nend\n\nDefines the distance of distances matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistDistMLP","text":"@kwdef mutable struct DistDistMLP <: AbsoluteDistType\n    absolute::Bool = false\n    distance::Distances.Metric = Distances.Euclidean()\n    args::Tuple = ()\n    kwargs::NamedTuple = (;)\nend\n\nDefines the distance of distances matrix from a correlation matrix [2] in dist.\n\nbeginalign\ntildeD_ij = f_mleft(bmD_i bmD_jright)\nendalign\n\nWhere:\n\nbmD_i: is the i-th column/row of the N×N distance matrix defined in DistMLP.\nf_m: is the pairwise distance function for metric m. We use the Distances.pairwise function which computes the entire matrix at once.\ntildeD_ij: is the (ij)-th entry of the N×N distances of distances matrix.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\ndistance: distance metric from Distances.jl.\nargs: args for the Distances.pairwise function.\nkwargs: key word args for the Distances.pairwise function.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistDistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistDistVarInfo","text":"@kwdef mutable struct DistDistVarInfo <: DistType\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance of distances matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistLog","page":"Distance matrices","title":"PortfolioOptimiser.DistLog","text":"struct DistLog <: DistType end\n\nDefines the log-distance matrix from the correlation matrix.\n\nbeginalign\nD_ij = -logleft(C_ijright)\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N log-distance matrix.\nC_ij: is the  (ij)-th entry of an absolute correlation matrix.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistMLP","page":"Distance matrices","title":"PortfolioOptimiser.DistMLP","text":"@kwdef mutable struct DistMLP <: AbsoluteDistType\n    absolute::Bool = false\nend\n\nDefines the distance matrix from a correlation matrix [2] in dist.\n\nbeginalign\nD_ij = \n    begincases\n        sqrtdfrac12 left(1 - C_ijright) quad mathrmif absolute = false\n        sqrt1 - lvert C_ij rvert quad mathrmif absolute = true\n    endcases\nendalign\n\nWhere:\n\nD_ij: is the (ij)-th entry of the N×N distance matrix mathbfC.\nC_ij: is the (ij)-th entry of the N×N correlation matrix mathbfD.\nabsolute:\nif true: the correlation being used is absolute.\n\nParameters\n\nabsolute:\nif true: the correlation being used is absolute.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistVarInfo","page":"Distance matrices","title":"PortfolioOptimiser.DistVarInfo","text":"@kwdef mutable struct DistVarInfo <: DistType\n    bins::Union{<:Integer, <:AbstractBins} = HGR()\n    normalise::Bool = true\nend\n\nDefines the variation of information distance matrix.\n\nParameters\n\nbins:\nif isa(bins, AbstractBins): defines the function for computing bin widths.\nif isa(bins, Integer) and bins > 0: directly provide the number of bins.\nnormalise:\nif true: normalise the mutual information.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Freedman","page":"Distance matrices","title":"PortfolioOptimiser.Freedman","text":"struct Freedman <: AstroBins end\n\nFreedman's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.GenDistDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.GenDistDistMLP","text":"mutable struct GenDistDistMLP{T1} <: AbsoluteDistType\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.GenDistMLP","page":"Distance matrices","title":"PortfolioOptimiser.GenDistMLP","text":"mutable struct GenDistMLP{T1} <: AbsoluteDistType\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.HGR","page":"Distance matrices","title":"PortfolioOptimiser.HGR","text":"struct HGR <: AbstractBins end\n\nHacine-Gharbi and Ravier's bin width algorithm [3].\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Knuth","page":"Distance matrices","title":"PortfolioOptimiser.Knuth","text":"struct Knuth <: AstroBins end\n\nKnuth's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.Scott","page":"Distance matrices","title":"PortfolioOptimiser.Scott","text":"struct Scott <: AstroBins end\n\nScott's bin width algorithm from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.dist-Tuple{GenDistMLP, AbstractMatrix, Any}","page":"Distance matrices","title":"PortfolioOptimiser.dist","text":"dist(de::GenDistMLP, X::AbstractMatrix, ::Any)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/DistanceMatrices/#Private","page":"Distance matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AbstractBins","page":"Distance matrices","title":"PortfolioOptimiser.AbstractBins","text":"abstract type AbstractBins end\n\nAbstract type for defining the bin width estimation functions when computing DistVarInfo and CovMutualInfo distance and correlation matrices respectively.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.AstroBins","page":"Distance matrices","title":"PortfolioOptimiser.AstroBins","text":"abstract type AstroBins <: AbstractBins end\n\nAbstract type for defining which bin width function to use from astropy.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.DistType","page":"Distance matrices","title":"PortfolioOptimiser.DistType","text":"abstract type DistType end\n\nAbstract type for subtyping types for computing distance matrices from correlation ones.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DistanceMatrices/#PortfolioOptimiser.default_dist-Tuple{DistCanonical, PortCovCor}","page":"Distance matrices","title":"PortfolioOptimiser.default_dist","text":"default_dist(dist_type::DistCanonical, cor_type::PortCovCor)\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/LoGoMatrix/#Detone-matrix","page":"Detone matrix","title":"Detone matrix","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/#Public","page":"Detone matrix","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.LoGo","page":"Detone matrix","title":"PortfolioOptimiser.LoGo","text":"@kwdef mutable struct LoGo <: AbstractLoGo\n    distance::DistType = DistMLP()\n    similarity::DBHTSimilarity = DBHTMaxDist()\nend\n\nCompute the LoGo covariance and correlation matrix estimator.\n\nParameters\n\ndistance: type for computing the distance (disimilarity) matrix from the correlation matrix if the distance matrix is not provided to logo!.\nsimilarity: type for computing the similarity matrix from the correlation and distance matrices. The distance matrix is used to compute sparsity pattern of the inverse of the LoGo covariance and correlation matrices.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.NoLoGo","page":"Detone matrix","title":"PortfolioOptimiser.NoLoGo","text":"struct NoLoGo <: AbstractLoGo end\n\nLeave the matrix as is.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.logo!","page":"Detone matrix","title":"PortfolioOptimiser.logo!","text":"logo!(je::LoGo, posdef::AbstractPosdefFix, X::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.logo!-2","page":"Detone matrix","title":"PortfolioOptimiser.logo!","text":"logo!(::NoLoGo, ::AbstractPosdefFix, ::AbstractMatrix, D = nothing)\n\n\n\n\n\n","category":"function"},{"location":"ParameterEstimation/LoGoMatrix/#Private","page":"Detone matrix","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/LoGoMatrix/#PortfolioOptimiser.AbstractLoGo","page":"Detone matrix","title":"PortfolioOptimiser.AbstractLoGo","text":"abstract type AbstractLoGo end\n\nAbstract type for subtyping LoGo covariance and correlation matrix estimators.\n\n\n\n\n\n","category":"type"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/#Example-6:-Black-Litterman-Factors-Mean-Risk-Optimisation","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"","category":"section"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/#1.-Download-data.","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"1. Download data.","text":"","category":"section"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=3)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(assets; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(assets))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/#2.-Estimating-Black-Litterman-Portfolios","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"2. Estimating Black Litterman Portfolios","text":"","category":"section"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/#2.1.-Reference-portfolio","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"2.1. Reference portfolio","text":"","category":"section"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"For API details and options available see: Portfolio, PortOptSolver, PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, BLType, asset_statistics!, black_litterman, RiskMeasure, PortfolioOptimiser.ObjectiveFunction, PortfolioOptimiser.OptimType.","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices,\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n\n# Compute relevant statistics.\n# Expected returns and covariance estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\n\n# Only compute `mu` and `cov`.\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\n# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj)\n\n# Optimise portfolio.\nw1 = optimise!(port, type)\npretty_table(w1; formatters = fmt2)\nplot_bar(port)","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"","category":"page"},{"location":"examples/6_Black_Litterman_Factors_Mean_Risk_Optimisation/","page":"Example 6: Black Litterman Factors Mean Risk Optimisation","title":"Example 6: Black Litterman Factors Mean Risk Optimisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Optimisation/PortfolioClasses/#Portfolio-classes","page":"Portfolio classes","title":"Portfolio classes","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#Public","page":"Portfolio classes","title":"Public","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BL","page":"Portfolio classes","title":"PortfolioOptimiser.BL","text":"@kwdef mutable struct BL{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BLFM","page":"Portfolio classes","title":"PortfolioOptimiser.BLFM","text":"@kwdef mutable struct BLFM{T1 <: Integer} <: BlackLittermanClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.Classic","page":"Portfolio classes","title":"PortfolioOptimiser.Classic","text":"struct Classic <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FC","page":"Portfolio classes","title":"PortfolioOptimiser.FC","text":"@kwdef mutable struct FC <: PortClass\n    flag::Bool = true\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.FM","page":"Portfolio classes","title":"PortfolioOptimiser.FM","text":"@kwdef mutable struct FM{T1 <: Integer} <: PortClass\n    type::T1 = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#Private","page":"Portfolio classes","title":"Private","text":"","category":"section"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.BlackLittermanClass","page":"Portfolio classes","title":"PortfolioOptimiser.BlackLittermanClass","text":"abstract type BlackLittermanClass <: PortClass end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/PortfolioClasses/#PortfolioOptimiser.PortClass","page":"Portfolio classes","title":"PortfolioOptimiser.PortClass","text":"abstract type PortClass end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#Detone-matrix","page":"Detone matrix","title":"Detone matrix","text":"","category":"section"},{"location":"ParameterEstimation/DetoneMatrix/#Public","page":"Detone matrix","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/DetoneMatrix/#PortfolioOptimiser.Detone","page":"Detone matrix","title":"PortfolioOptimiser.Detone","text":"mutable struct Detone{T1} <: AbstractDetone\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#PortfolioOptimiser.NoDetone","page":"Detone matrix","title":"PortfolioOptimiser.NoDetone","text":"struct NoDetone <: AbstractDetone end\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/DetoneMatrix/#Private","page":"Detone matrix","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#Public","page":"Clustering","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets!-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets!","text":"cluster_assets!(port::Union{HCPortfolio, Portfolio}; clust_alg::ClustAlg = HAC(),\n                clust_opt::ClustOpt = ClustOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. Save the results in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio .\nclust_alg: hierarchical clustering algorithm ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.cluster_assets-Tuple{Portfolio}","page":"Clustering","title":"PortfolioOptimiser.cluster_assets","text":"cluster_assets(port::Union{HCPortfolio, Portfolio}; clust_alg::ClustAlg = HAC(),\n               clust_opt::ClustOpt = ClustOpt())\n\nHierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nport: hierarchical clustering portfolio .\nclust_alg: hierarchical clustering algorithm ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nidx: clustering assignments after cutting the tree into k levels Clustering.cutree.\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioClustering/#Private","page":"Clustering","title":"Private","text":"","category":"section"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.clusterise","page":"Clustering","title":"PortfolioOptimiser.clusterise","text":"clusterise(ca::DBHT, port::Union{HCPortfolio, Portfolio}, clust_opt::ClustOpt = ClustOpt())\n\nUse DBHTs to hierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: [DBHT] options for clustering with DBHTs.\nport: hierarchical clustering portfolio .\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioClustering/#PortfolioOptimiser.clusterise-2","page":"Clustering","title":"PortfolioOptimiser.clusterise","text":"clusterise(ca::HAC, port::Union{HCPortfolio, Portfolio}, clust_opt::ClustOpt = ClustOpt())\n\nUse Clustering.hclust to hierarchically cluster the assets in a hierarchical portfolio using the covariance and distance matrices stored in the portfolio. See the arguments types' docs for details.\n\nInputs\n\nca: linkage for Clustering.hclust.\nport: hierarchical clustering portfolio .\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nclustering: Clustering.Hclust of the portfolio assets.\nk: optimum number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"Optimisation/ObjectiveFunctions/#Objective-functions","page":"Objective functions","title":"Objective functions","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#Public","page":"Objective functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MaxRet","page":"Objective functions","title":"PortfolioOptimiser.MaxRet","text":"struct MaxRet <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.MinRisk","page":"Objective functions","title":"PortfolioOptimiser.MinRisk","text":"struct MinRisk <: ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Sharpe","page":"Objective functions","title":"PortfolioOptimiser.Sharpe","text":"@kwdef mutable struct Sharpe{T1 <: Real} <: ObjectiveFunction\n    rf::T1 = 0.0\nend\n\nMaximum risk-adjusted return (Sharpe) ratio objective function.\n\nParameters\n\nrf: risk free rate.\nohf::T2 = 1.0 where T2 <: Real: The optimal homogenisation factor.\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.Utility","page":"Objective functions","title":"PortfolioOptimiser.Utility","text":"@kwdef mutable struct Utility{T1 <: Real} <: ObjectiveFunction\n    l::T1 = 2.0\nend\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#Private","page":"Objective functions","title":"Private","text":"","category":"section"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.CustomObjective","page":"Objective functions","title":"PortfolioOptimiser.CustomObjective","text":"abstract type CustomObjective end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.NoCustomObjective","page":"Objective functions","title":"PortfolioOptimiser.NoCustomObjective","text":"struct NoCustomObjective <: CustomObjective end\n\n\n\n\n\n","category":"type"},{"location":"Optimisation/ObjectiveFunctions/#PortfolioOptimiser.ObjectiveFunction","page":"Objective functions","title":"PortfolioOptimiser.ObjectiveFunction","text":"abstract type ObjectiveFunction end\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-2/#Downside-dispersion","page":"Downside dispersion","title":"Downside dispersion","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-2/","page":"Downside dispersion","title":"Downside dispersion","text":"These measure how far the returns deviate from the mean in the negative direction.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-2/#Third-Lower-Partial-Moment","page":"Downside dispersion","title":"Third Lower Partial Moment","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-2/#PortfolioOptimiser.TLPM","page":"Downside dispersion","title":"PortfolioOptimiser.TLPM","text":"\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-2/#Fourth-Lower-Partial-Moment","page":"Downside dispersion","title":"Fourth Lower Partial Moment","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-2/#PortfolioOptimiser.FTLPM","page":"Downside dispersion","title":"PortfolioOptimiser.FTLPM","text":"\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-2/#Kurtosis","page":"Downside dispersion","title":"Kurtosis","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-2/#PortfolioOptimiser.Kurtosis","page":"Downside dispersion","title":"PortfolioOptimiser.Kurtosis","text":"mutable struct Kurtosis <: HCRiskMeasure\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures3-2/#Semi-Kurtosis","page":"Downside dispersion","title":"Semi Kurtosis","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-2/#PortfolioOptimiser.SKurtosis","page":"Downside dispersion","title":"PortfolioOptimiser.SKurtosis","text":"mutable struct SKurtosis{T1 <: Real} <: HCRiskMeasure\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Miscelaneous-Functions","page":"Miscelaneous Functions","title":"Miscelaneous Functions","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Public","page":"Miscelaneous Functions","title":"Public","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#Private","page":"Miscelaneous Functions","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_first_rm-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_first_rm","text":"get_first_rm(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet the first risk measure, used in efficient_frontier!.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.get_rm_symbol-Tuple{Union{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.get_rm_symbol","text":"get_rm_symbol(rm::Union{AbstractVector, <:AbstractRiskMeasure})\n\nGet a symbol for the risk measure(s). If multiple measures are given, they are concatenated by underscores.\n\nInputs\n\nrm: risk measure or vector of risk measures AbstractRiskMeasure.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, Union{PortOptSolver, AbstractVector{PortOptSolver}}, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}, Union{Nothing, AbstractMatrix{<:Real}}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.set_rm_properties!","text":"set_rm_properties!(rm::AbstractRiskMeasure, solvers::AbstractDict,\n                   sigma::Union{Nothing, <:AbstractMatrix{<:Real}})\n\nSet properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.set_rm_solvers!-Tuple{RMSolvers, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.set_rm_solvers!","text":"set_rm_solvers!(rm::RMSolvers, solvers)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_rm_solvers!-Tuple{RMSolvers, Any}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.unset_rm_solvers!","text":"unset_rm_solvers!(rm::RMSolvers, flag)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/MiscRiskMeasureFunctions/#PortfolioOptimiser.unset_set_rm_properties!-Tuple{PortfolioOptimiser.AbstractRiskMeasure, Vararg{Bool, 4}}","page":"Miscelaneous Functions","title":"PortfolioOptimiser.unset_set_rm_properties!","text":"unset_set_rm_properties!(rm::AbstractRiskMeasure, solver_flag::Bool, sigma_flag::Bool)\n\nUnset properties for risk measures that use solvers or covariance matrices.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nsolvers: solvers.\nsigma: covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#Network","page":"Network","title":"Network","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/#Public","page":"Network","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.centrality_vector-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.centrality_vector","text":"centrality_vector(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistType = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the centrality vector centrality_vector. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nC: N×1 centrality vector.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.cluster_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.cluster_matrix","text":"cluster_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistType = DistCanonical(),\n               clust_alg::ClustAlg = HAC(), clust_opt::ClustOpt = ClustOpt())\n\nCompute the centrality vector cluster_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nclust_alg: type for hierarhically clustering assets ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nC: N×N cluster-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connected_assets","page":"Network","title":"PortfolioOptimiser.connected_assets","text":"connected_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                 cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                 dist_type::DistType = DistCanonical(),\n                 network_type::NetworkType = MST())\n\nCompute the percentage of the portfolio comprised of connected assets connected_assets via a connection-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nc: percentage of the portfolio comprised of assets connected via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.connection_matrix-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Network","title":"PortfolioOptimiser.connection_matrix","text":"connection_matrix(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  dist_type::DistType = DistCanonical(),\n                  network_type::NetworkType = MST())\n\nCompute the connection matrix connection_matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nnetwork_type: type for computing the asset network NetworkType.\n\nOutputs\n\nC: N×N connection-based adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioNetwork/#PortfolioOptimiser.related_assets","page":"Network","title":"PortfolioOptimiser.related_assets","text":"related_assets(port::AbstractPortfolio; X::AbstractMatrix = port.returns,\n               type::Symbol = isa(port, Portfolio) || isa(port, Portfolio) ? :Trad : :HRP,\n               cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n               dist_type::DistType = DistCanonical(),\n               clust_alg::ClustAlg = HAC(), clust_opt::ClustOpt = ClustOpt())\n\nCompute the percentage of the portfolio comprised of related assets  related_assets via a cluster-based adjacency matrix. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nX: T×N returns matrix.\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\ndist_type: type for computing the distance matrix DistType.\nclust_alg: type for hierarhically clustering assets ClustAlg.\nclust_opt: options for determining the number of clusters ClustOpt.\n\nOutputs\n\nc: percentage of the portfolio comprised of related assets via a connection-based adjacency matrix.\n\n\n\n\n\n","category":"function"},{"location":"Portfolio/PortfolioNetwork/#Private","page":"Network","title":"Private","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Setup-functions","page":"Setup functions","title":"Setup functions","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Public","page":"Setup functions","title":"Public","text":"","category":"section"},{"location":"Optimisation/OptimisationSetup/#Private","page":"Setup functions","title":"Private","text":"","category":"section"},{"location":"Contents/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"Contents/","page":"Index","title":"Index","text":"","category":"page"},{"location":"RiskMeasures/RiskStatistics/#Risk-statistics","page":"Risk statistics","title":"Risk statistics","text":"","category":"section"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"It is possible to compute risk-derived statistics given a RiskMeasure/HCRiskMeasure, a vector of weights, and other relevant data.","category":"page"},{"location":"RiskMeasures/RiskStatistics/","page":"Risk statistics","title":"Risk statistics","text":"There are similarly named higher level functions that operate at the level of PortfolioOptimiser.AbstractPortfolio.","category":"page"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_bounds-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_bounds","text":"risk_bounds(rm::AbstractRiskMeasure, w1::AbstractVector, w2::AbstractVector;\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            V::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            SV::AbstractMatrix = Matrix{Float64}(undef, 0, 0), delta::Real = 1e-6,\n            scale::Bool = false, kwargs...)\n\nDescription\n\nCompute the risk bounds for an AbstractRiskMeasure and pair of asset weight vectors.\n\nSee also: AbstractRiskMeasure, expected_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\nV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the coskewness.\nSV::AbstractMatrix = Matrix{Float64}(undef, 0, 0): N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nscale::Bool = false: flag for scaling the kurtosis and semi kurtosis in risk_contribution.\n\nOutputs\n\nr1::Real: lower risk bound/risk corresponding to w1.\nr2::Real: upper risk bound/risk corresponding to w2.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw1 = [0.7, 0.2, 0.1]\nw2 = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nr1, r2 = risk_bounds(CVaR(), w1, w2; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.risk_contribution","text":"risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                  X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                  delta::Real = 1e-6, marginal::Bool = false, \n                  kwargs...)\n\nDescription\n\nCompute the asset risk contribution for an AbstractRiskMeasure and asset weight vector.\n\nSee also: AbstractRiskMeasure, risk_bounds, expected_risk.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure.\nw1::AbstractVector: N×1 vector of asset weights for lower bound.\nw2::AbstractVector: N×1 vector of asset weights for upper bound.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×N matrix of asset returns.\ndelta::Real = 1e-6: small displacement used for computing the Equal risk measure.\nmarginal::Bool = false:\nif true: compute the marginal risk contribution.\nelse: compute the risk contribution by multiplying the marginal risk by the asset weight.\n\nOutputs\n\nrc::AbstractVector: N×1 vector of risk contribution per asset.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.19 -0.41 -0.70;\n            1.15 -1.20 -1.27;\n           -0.27 -1.98 -0.77;\n           -0.65  0.22  0.59;\n           -0.04  0.35 -0.99]\n\n# Sample weights vector\nw = [0.3, 0.5, 0.2]\n\n# Calculate the risk bounds for the default conditional value at risk\nrc = risk_contribution(CVaR(), w; X = returns)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.factor_risk_contribution-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.factor_risk_contribution","text":"factor_risk_contribution(rm::AbstractRiskMeasure, w::AbstractVector;\n                        X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        assets::AbstractVector = Vector{String}(undef, 0),\n                        F::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n                        f_assets::AbstractVector = Vector{String}(undef, 0),\n                        B::DataFrame = DataFrame(),\n                        regression_type::RegressionType = FReg(),\n                        delta::Real = 1e-6, kwargs...)\n\nDescription\n\nCompute the factor risk contribution for an AbstractRiskMeasure, assets, and factors.\n\nSee also: AbstractRiskMeasure, risk_bounds, expected_risk, regression, RegressionType.\n\nInputs\n\nPositional\n\nrm::AbstractRiskMeasure: risk measure AbstractRiskMeasure.\nw::AbstractVector: Na×1 vector of asset weights.\n\nNamed\n\nX::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Na matrix of asset returns.\nassets::AbstractVector = Vector{String}(undef, 0): Na×1 vector of asset names.\nF::AbstractMatrix = Matrix{Float64}(undef, 0, 0): T×Nf matrix of factor returns.\nf_assets::AbstractVector = Vector{String}(undef, 0): Nf× vector of factor names.\nB::DataFrame = DataFrame(): optional Na×Nf loadings matrix.\nregression_type::RegressionType = FReg(): regression type used for computing the loadings matrix.\ndelta::Real = 1e-6: small displacement used for computing the marginal risk and equal risk measure Equal.\n\nBehaviour\n\nIf B is empty: computes the loadings matrix, B, via regression using regression_type, F, f_assets, X, assets.\n\nOutputs\n\nrc_f::AbstractVector: Nf×1 vector of risk contribution per factor.\n\nExamples\n\n# Sample returns matrix\nreturns = [ 0.57 -0.54 -0.15  0.42 -1.78;\n           -0.12 -0.02 -0.04  1.61  0.74;\n            0.09  2.58 -0.40 -0.36 -1.07;\n           -1.33 -1.13  0.35 -0.89 -1.01;\n            0.59 -1.48  0.01 -1.79 -0.18;\n            0.22  0.39 -0.04  0.22  0.64;\n            2.39  0.05 -0.24  0.76 -0.08;\n           -0.22 -0.66  0.51  1.21 -0.36;\n            1.56 -0.39  2.13  0.01  1.77;\n            0.88  0.49 -1.24  1.24  0.71]\n\n# Asset names\nassets = [\"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]\n\n# Sample factor returns matrix\nf_returns = [ 3.00  1.55;\n              0.52 -0.57;\n             -0.27  0.71;\n              0.30  0.00;\n              2.27  1.10;\n              0.23  1.33;\n              0.64  0.00;\n              0.35  1.02;\n             -1.33 -1.60;\n              0.49 -1.66]\n\n# Factor names\nf_assets = [\"F1\", \"F2\"]\n\n# Sample asset weights vector\nw = [0.15, 0.1, 0.3, 0.2, 0.25]\n\n# Risk measure\ncvar_rm = CVaR()\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# the default parameters.\nfc1 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets)\n\n# Compute the risk factor contribution by computing the loadings matrix using\n# a different regression type.\nfc2 = factor_risk_contribution(cvar_rm, w; X = returns, assets = assets, F = f_returns,\n                               f_assets = f_assets, regression_type = BReg())\n\n# Provide the loadings matrix directly.\nB = DataFrame(:tickers => assets,\n              :const => [0.019628056331070173, -0.4630372691196401, -0.051116594784858346,\n                         0.6244845397620361, -0.46039779836908995],\n              :F1 => [-0.5382419657683666, 0.0, -0.5447539204822568, 0.0,\n                      -0.4713171689983393],\n              :F2 => [0.0, -0.48659032199680796, 0.44882375725309853, -0.23791307331955935,\n                      0.0])\n\nfc3 = factor_risk_contribution(cvar_rm, w; X = returns, F = f_returns, B = B)\n\n\n\n\n\n","category":"method"},{"location":"RiskMeasures/RiskStatistics/#PortfolioOptimiser.sharpe_ratio-Tuple{PortfolioOptimiser.AbstractRiskMeasure, AbstractVector}","page":"Risk statistics","title":"PortfolioOptimiser.sharpe_ratio","text":"sharpe_ratio(rm::AbstractRiskMeasure, w::AbstractVector;\n            mu::AbstractVector = Vector{Float64}(undef, 0),\n            X::AbstractMatrix = Matrix{Float64}(undef, 0, 0),\n            delta::Real = 1e-6, rf::Real = 0.0, \n            kelly::Bool = false)\n\nDescription\n\nCompute the risk-adjusted return ratio for an AbstractRiskMeasure and asset weights vector.\n\nInputs\n\nrm: risk measure AbstractRiskMeasure.\nw: N×1 vector of asset weights.\nmu: N×1 vector of expected returns.\nX: T×N matrix of asset returns.\nV: N×N matrix of the sum of negative spectral slices of the coskewness.\nSV: N×N matrix of the sum of negative spectral slices of the semi coskewness.\ndelta: small displacement used for computing the Equal risk measure.\nrf: risk free rate.\nkelly:\nif true: use the kelly return.\nelse: use the arithmetic return.\n\nOutputs\n\nsr: risk adjusted return ratio.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Black-Litterman-models","page":"Black Litterman models","title":"Black Litterman models","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#Public","page":"Black Litterman models","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.ABLType","page":"Black Litterman models","title":"PortfolioOptimiser.ABLType","text":"@kwdef mutable struct ABLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool = true\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::AbstractPosdefFix = PosdefNearest()\n    denoise::AbstractDenoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Augmented Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nbmPi_a = begincases\n                    deltabeginbmatrix\n                      mathbfSigma\n                      mathbfSigma_F mathbfB^intercal\n                      endbmatrix bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases\nmathbfP_a =  beginbmatrix\n                      mathbfP  mathbf0\n                      mathbf0  mathbfP_F\n                    endbmatrix\nbmQ_a =  beginbmatrix\n                bmQ\n                bmQ_F\n                endbmatrix\nmathbfSigma_a =  beginbmatrix\n                            mathbfSigma  mathbfB mathbfSigma_F\n                            mathbfSigma_F mathbfB^intercal  mathbfSigma_F\n                          endbmatrix\nmathbfOmega_a =  beginbmatrix\n                            mathbfOmega  mathbf0\n                            mathbf0  mathbfOmega_F\n                          endbmatrix\nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\nmathbfM_a = left left(tau  mathbfSigma_a right)^-1 + mathbfP_a^intercal mathbfOmega_a^-1 mathbfP_aright^-1\nbmPi_mathrmABL = mathbfM_a leftleft(tau mathbfSigma_aright)^-1 bmPi_a + mathbfP_a^intercal mathbfOmega_a^-1 mathbfQ_a right\ntau = dfrac1T\nbmmu_mathrmABL = bmPi_mathrmABL + r\nmathbfSigma_mathrmABL = mathbfSigma_a + mathbfM_a\nendalign\n\nWhere:\n\nbmPi_a:\nif error is true: is the Na×1 augmented equilibrium excess returns vector.\nelse: is the Na×1 historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the Na×Na asset covariance matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfP_a: is the (Nva+Nvf)×(Na+Nf) augmented views matrix. The zeros pad the matrix so all columns and rows are of equal length.\nmathbfP: is the Nva×Na asset views matrix.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nbmQ_a: is the (Nva+Nvf)×1 augmented views returns vector.\nbmQ: is the Nva×1 asset views returns vector.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_a: is the (Na+Nf)×(Na+Nf) augmented covariance matrix.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfOmega_a: is the (Nva+Nvf)×(Nva+Nvf) covariance matrix of the errors of the augmented views.\nmathbfOmega: is the Nva×Nva covariance matrix of the errors of the asset views.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nmathbfM_a: is an (Na+Nf)×(Na+Nf) intermediate covariance matrix.\nbmPi_mathbfABL: is the Na×1 equilibrium excess returns vector after being adjusted by the augmented views.\nT: is the number of returns observations.\nbmmu_mathbfABL: is the Na×1 vector of asset expected returns obtained via the Augmented Black-Litterman model.\nmathbfSigma_mathrmABL: is the Na×Na asset covariance matrix obtained via the Augmented Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: type for fixing non positive Augmented Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Augmented Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Augmented Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BBLType","page":"Black Litterman models","title":"PortfolioOptimiser.BBLType","text":"mutable struct BBLType{T1 <: Real} <: BlackLittermanFactor\n    constant::Bool\n    error::Bool\n    delta::Union{<:Real, Nothing}\n    rf::T1\n    ve::StatsBase.CovarianceEstimator\n    var_w::Union{<:AbstractWeights, Nothing}\n    posdef::AbstractPosdefFix\n    denoise::AbstractDenoise\n    logo::AbstractLoGo\nend\n\nDefines the parameters for computing the Bayesian Black-Litterman factor model black_litterman. We define Na as the number of assets, Nva the number of asset views, Nf As the number of factors, and Nvf the number of factor views.\n\nbeginalign\nmathbfSigma = mathbfB mathbfSigma_F mathbfB^intercal + mathbfSigma_epsilon \nmathbfSigma_epsilon = begincasesmathrmDiagonalleft(mathrmvarleft(mathbfX - mathbfF mathbfB^intercal mathrmdims = 1right)right) quad mathrmif error = true\nmathbf0 quad mathrmif error = false\nendcases\noverlinemathbfSigma_F = left(mathbfSigma_F^-1 + mathbfP_F^intercal mathbfOmega_F^-1 mathbfP_Fright)^-1\nmathbfOmega_F = tau mathrmDiagonalleft(mathbfP_F mathbfSigma_F mathbfP_F^intercalright)\ntau = dfrac1T\noverlinebmPi_F = overlinemathbfSigma_F left(mathbfSigma_F^-1 bmPi_F + mathbfP_F^intercal mathbfOmega_F^-1 bmQ_Fright)\nbmPi_F = bmmu_F - r\nmathbfSigma_mathrmBF = mathbfSigma^-1 mathbfB left( overlinemathbfSigma_F + mathbfB^intercal mathbfSigma^-1 mathbfB right)^-1\nmathbfSigma_mathrmBLB = left(mathbfSigma^-1 - mathbfSigma_mathrmBF mathbfB^intercal mathbfSigma^-1right)^-1\nbmmu_mathrmBLB = mathbfSigma_mathrmBLB mathbfSigma_mathrmBF overlinemathbfSigma_F overlinebmPi_F + r\nendalign\n\nWhere:\n\nmathbfSigma: is the Na×Na estimated asset covariance matrix computed using the factor model.\nmathbfB: is the Na×Nf loadings matrix.\nmathbfSigma_F: is the Nf×Nf factor covariance matrix.\nbmw: is the Na×1 vector of benchmark asset weights.\nmathbfSigma_epsilon: is an Na×Na diagonal matrix constructed from the variances of the errors between the asset and estimated asset returns using the factor model.\nmathbfX: is the T×Na matrix of asset returns.\nmathbfF: is the T×Nf matrix of factor returns.\noverlinemathbfSigma_F: is the Nf×Nf posterior covariance matrix of the factors after adjusting by the factor views.\nmathbfP_F: is the Nvf×Nf factor views matrix.\nmathbfOmega_F: is the Nvf×Nvf covariance matrix of the errors of the factor views.\nT: is the number of returns observations.\noverlinebmPi_F: is the Nf×1 posterior equilibrium excess returns vector of the factors after adjusting by the factor views.\nbmPi_F: is the Nf×1 equilibrium excess returns vector of the factors.\nbmmu_F: is the Nf×1 factor expected returns vector.\nr: is the risk-free rate.\nbmQ_F: is the Nvf×1 factor views returns vector.\nmathbfSigma_mathrmBF: is an Na×Nf intermediate covariance matrix,.\nmathbfSigma_mathrmBLB: is the Na×Na posterior asset covariance matrix, aka the asset covariance matrix obtained via the Bayesian Black-Litterman model.\nbmmu_mathrmBLB: is the Na×1 posterior asset expected returns vector, aka the asset returns vector obtained via the Bayesian Black-Litterman model.\n\nParameters\n\nconstant:\nif true: the loadings matrix contains the constant term as its first column.\nelse: the loadings matrix does not contain the constant term.\nerror:\nif true: correct the estimated asset covariance matrix by adding the variances of the errors between the actual returns and factor estimated returns.\n\nnote: Note\nOnly useful when the factor model is based on a regression model.\n\ndelta: risk aversion factor.\nrf: risk free rate.\nve: StatsBase.CovarianceEstimator for computing the errors covariance.\nvar_w: optional weights for computing the errors covariance.\nposdef: type for fixing non positive Bayesian Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Bayesian Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Bayesian Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BLType","page":"Black Litterman models","title":"PortfolioOptimiser.BLType","text":"@kwdef mutable struct BLType{T1 <: Real} <: BlackLitterman\n    eq::Bool = true\n    delta::Union{<:Real, Nothing} = 1.0\n    rf::T1 = 0.0\n    posdef::AbstractPosdefFix = PosdefNearest()\n    denoise::AbstractDenoise = NoDenoise()\n    logo::AbstractLoGo = NoLoGo()\nend\n\nDefines the parameters for computing the Black-Litterman model black_litterman. We define N as the number of assets, and Nv the number of asset views.\n\nbeginalign\nbmPi = begincases\n                    delta mathbfSigma bmw quad mathrmif eq = true\n                      bmmu - r quad mathrmif eq = false\n                  endcases                            \nmathbfOmega = tau mathrmDiagonalleft(mathbfP mathbfSigma mathbfP^intercalright)\nmathbfM = left left(tau  mathbfSigma right)^-1 + mathbfP^intercal mathbfOmega^-1 mathbfPright^-1\nbmPi_mathrmBL = mathbfM leftleft(tau mathbfSigmaright)^-1 bmPi + mathbfP^intercal mathbfOmega^-1 mathbfQ right\ntau = dfrac1T\nbmmu_mathrmBL = bmPi_mathrmBL + r\nmathbfSigma_mathrmBL = mathbfSigma + mathbfM\nendalign\n\nWhere:\n\nbmPi:\nif error is true: is N×1 the equilibrium excess returns vector.\nelse: is N×1 the historical excess returns vector.\ndelta: is the risk aversion parameter.\nmathbfSigma: is the N×N asset covariance matrix.\nbmw: is the N×1 vector of benchmark asset weights.\nmathbfP: is the Nv×N asset views matrix.\nbmQ: is the Nv×1 asset views returns vector.\nmathbfOmega: is the Nv×Nv covariance matrix of the errors of the asset views.\nmathbfM: is an N×N intermediate covariance matrix, and M the number of assets.\nbmPi_mathbfBL: is the N×1 equilibrium excess returns after being adjusted by the views.\nT: is the number of returns observations.\nbmmu_mathbfBL: is the N×1 vector of asset expected returns obtained via the Black-Litterman model.\nmathbfSigma_mathrmBL: is the N×N asset covariance matrix obtained via the Black-Litterman model.\n\nParameters\n\neq:\nif true: use the equilibrium excess returns vector.\nelse: use the historical excess returns vector.\ndelta: risk aversion factor.\nrf: risk free rate.\nposdef: type for fixing non positive Black-Litterman matrices AbstractPosdefFix.\ndenoise type for denoising the Black-Litterman covariance matrix AbstractDenoise.\nlogo: type for computing the LoGo Black-Litterman covariance matrix AbstractLoGo.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.black_litterman-Tuple{BLType, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}","page":"Black Litterman models","title":"PortfolioOptimiser.black_litterman","text":"black_litterman(bl::BLType, X::AbstractMatrix, P::AbstractMatrix,\n                         Q::AbstractVector, w::AbstractVector;\n                         cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                         mu_type::MeanEstimator = MuSimple())\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/BlackLitterman/#Private","page":"Black Litterman models","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.BlackLittermanFactor","page":"Black Litterman models","title":"PortfolioOptimiser.BlackLittermanFactor","text":"abstract type BlackLittermanFactor <: BlackLitterman end\n\nAbstract type for subtyping Black Litterman models.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/BlackLitterman/#PortfolioOptimiser.bl_mu_cov_w-NTuple{13, Any}","page":"Black Litterman models","title":"PortfolioOptimiser.bl_mu_cov_w","text":"_mu_cov_w(tau, omega, P, Pi, Q, rf, sigma, delta, T, N, opt, cov_type, cov_flag = true)\n\nInternal function for computing the Black Litterman statistics as defined in black_litterman. See .\n\nInputs\n\ntau: variable of the same name in the Black-Litterman model.\nomega: variable of the same name in the Black-Litterman model.\nP: variable of the same name in the Black-Litterman model.\nPi: variable of the same name in the Black-Litterman model.\nQ: variable of the same name in the Black-Litterman model.\nrf: variable of the same name in the Black-Litterman model.\nsigma: variable of the same name in the Black-Litterman model.\ndelta: variable of the same name in the Black-Litterman model.\nT: variable of the same name in the Black-Litterman model.\nN: variable of the same name in the Black-Litterman model.\nopt: any valid instance of opt for .\ncov_type: any valid value from .\ncov_flag: whether the matrix is a covariance matrix or not.\n\nOutputs\n\nmu: asset expected returns vector obtained via the Black-Litterman model.\ncov_mtx: asset covariance matrix obtained via the Black-Litterman model.\nw: asset weights obtained via the Black-Litterman model.\nPi_: equilibrium excess returns after being adjusted by the views.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/#Public","page":"Statistics","title":"Public","text":"","category":"section"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.asset_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.asset_statistics!","text":"asset_statistics!(port::AbstractPortfolio;\n                  cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cov::Bool = true, mu_type::MeanEstimator = MuSimple(),\n                  set_mu::Bool = true, kurt_type::KurtFull = KurtFull(),\n                  set_kurt::Bool = true, skurt_type::KurtSemi = KurtSemi(),\n                  set_skurt::Bool = true, skew_type::SkewFull = SkewFull(),\n                  set_skew::Bool = true, sskew_type::SkewSemi = SkewSemi(),\n                  set_sskew::Bool = true,\n                  cor_type::PortfolioOptimiserCovCor = PortCovCor(),\n                  set_cor::Bool = true,\n                  dist_type::DistType = DistCanonical(),\n                  set_dist::Bool = true)\n\nCompute the asset statistics for a portfolio. See the argument types' docs for details. If a statistic requires another to be computed, the funciton will do so from the relevant estimator.\n\nThe set_* variables are flags for deciding whether or not to set the statistic. If a statistic's flag is false the statistic will not be set. Furthermore, if the flag is false and the statistic is not required by another one, it will not be computed.\n\nInputs\n\nport: portfolio AbstractPortfolio.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nset_cov: flag for setting port.cov\nmu_type: expected returns estimator MeanEstimator.\nset_mu: flag for setting port.mu\nkurt_type: cokurtosis matrix estimator KurtFull.\nset_kurt: flag for setting port.kurt.\nskurt_type: cokurtosis matrix estimator KurtSemi.\nset_skurt: flag for setting port.skurt.\nskew_type: coskew estimator SkewFull.\nset_skew: set port.skew and port.V.\nsskew_type: semi coskew estimator SkewSemi.\nset_sskew: set port.skew and port.SV.\n\nOnly relevant for .\n\ncor_type: correlation matrix estimator PortfolioOptimiserCovCor.\nset_cor: flag for setting port.cor.\ndist_type: type for computing the distance matrix DistType. asset_statistics! uses default_dist to ensure the computed distance is consistent with dist_type and either cor_type.ce or cor_type whichever is applicable.\nset_dist: flag for setting port.dist.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_factor_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_factor_statistics!","text":"black_litterman_factor_statistics!(port::AbstractPortfolio;\n                                   w::AbstractVector = port.bl_bench_weights,\n                                   B::Union{DataFrame, Nothing} = port.loadings,\n                                   P::Union{AbstractMatrix, Nothing} = nothing,\n                                   f_P::Union{AbstractMatrix, Nothing} = nothing,\n                                   Q::Union{AbstractVector, Nothing} = nothing,\n                                   f_Q::Union{AbstractVector, Nothing} = nothing,\n                                   factor_type::FactorType = FactorType(),\n                                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   mu_type::MeanEstimator = MuSimple(),\n                                   f_cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                                   f_mu_type::MeanEstimator = MuSimple(),\n                                   bl_type::BlackLittermanFactor = BBLType())\n\nCompute the Black Litterman factor model statistics. Na is the number of assets, Nva is the number of asset views, Nf is the number of factors, Nvf is the number of factors views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\nB: loadings matrix.\nif isempty(B): computes the loadings matrix using factor_type.\nP: Nva×Na matrix of asset views.\nf_P: Nvf×Nf matrix of factor views.\nQ: Nva×1 vector of asset views.\nf_Q: Nvf×1 vector of factor views.\nfactor_type: factor statistics estimator FactorType.\ncov_type: asset covariance estimator PortfolioOptimiserCovCor.\nmu_type: asset expected returns estimator MeanEstimator.\nf_cov_type: factor covariance estimator PortfolioOptimiserCovCor.\nf_mu_type: factor expected returns estimator MeanEstimator.\nbl_type: Black Litterman factor model estimator BlackLittermanFactor.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.black_litterman_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.black_litterman_statistics!","text":"black_litterman_statistics!(port::AbstractPortfolio; P::AbstractMatrix, Q::AbstractVector,\n                            w::AbstractVector = port.bl_bench_weights,\n                            cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                            mu_type::MeanEstimator = MuSimple(),\n                            bl_type::BLType = BLType())\n\nCompute the factor statistics. N is the number of assets, Nv is the number of asset views. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nP: Nv×N matrix of asset views.\nQ: Nv×1 vector of asset views.\nw: N×1 vector of benchmark weights for the Black-Litterman model.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\nbl_type: Black Litterman model estimator BLType.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.factor_statistics!-Tuple{PortfolioOptimiser.AbstractPortfolio}","page":"Statistics","title":"PortfolioOptimiser.factor_statistics!","text":"factor_statistics!(port::AbstractPortfolio; factor_type::FactorType = FactorType(),\n                   cov_type::PortfolioOptimiserCovCor = PortCovCor(),\n                   mu_type::MeanEstimator = MuSimple())\n\nCompute the factor statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio AbstractPortfolio.\nfactor_type: factor statistics estimator FactorType.\ncov_type: covariance estimator PortfolioOptimiserCovCor.\nmu_type: expected returns estimator MeanEstimator.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#PortfolioOptimiser.wc_statistics!-Tuple{Portfolio}","page":"Statistics","title":"PortfolioOptimiser.wc_statistics!","text":"wc_statistics!(port::Portfolio; wc_type::WCType = WCType(), set_box::Bool = true,\n                        set_ellipse::Bool = true)\n\nCompute the worst case mean-variance statistics. Only used in  optimisations. The set_* variables are used to compute and set the relevant statistics. See the argument types' docs for details.\n\nInputs\n\nport: portfolio Portfolio.\nwc: worst-case mean-variance statistics estimator WCType.\nset_box:\nif true: compute and set the box uncertainty sets, port.cov_l, port.cov_u, port.d_mu.\nset_ellipse:\nif true: compute and set the elliptical uncertainty sets and parameters, port.cov_mu, port.cov_sigma, port.k_mu, port.k_sigma.\n\n\n\n\n\n","category":"method"},{"location":"Portfolio/PortfolioStatistics/#Private","page":"Statistics","title":"Private","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-5/#Equal-Risk-Contribution","page":"Equal Risk Contribution","title":"Equal Risk Contribution","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-5/","page":"Equal Risk Contribution","title":"Equal Risk Contribution","text":"This assumes the risk is equally distributed among the variables.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-5/#PortfolioOptimiser.Equal","page":"Equal Risk Contribution","title":"PortfolioOptimiser.Equal","text":"struct Equal <: HCRiskMeasure\n\nDescription\n\nEqual risk measure.\n\nRisk is allocated evenly among a group of assets.\n\nProperties\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\n\nExamples\n\n# Default settings\nequal = Equal()\n\n# Custom configuration\nequal = Equal(; settings = HCRMSettings(; scale = 3))\n\n\n\n\n\n","category":"type"},{"location":"Solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Solvers/#PortfolioOptimiser.PortOptSolver","page":"Solvers","title":"PortfolioOptimiser.PortOptSolver","text":"mutable struct PortOptSolver\n\nStructure for defining solver and solver parameters for solving JuMP models.\n\nFunctions and types which take a PortOptSolver also take a <:AbstractVector{PortOptSolver}.\nIf a vector is provided, it will iterated over until a solution is accepted or the vector runs out, at which point the optimisation will be considered to have failed.\n\nSee also: Portfolio, RMSolvers, OWAJTypes.\n\nKeyword Arguments\n\nname::Union{Symbol, <:AbstractString} = \"\": optimiser name (for registering solutions).\nsolver::Any = nothing: defines the solver to be used. One can also use JuMP.optimizer_with_attributes to direcly provide a solver with attributes already attached.JuMP optimiser factory optimizer_factory.\ncheck_sol::NamedTuple = (; allow_local = true, allow_almost = true): defines the keyword arguments passed on to JuMP.is_solved_and_feasible for accepting/rejecting solutions.\nsolvers::Union{Nothing, <:AbstractDict} = nothing:  defines solver-specific parameters/attributes.\nadd_bridges::Bool = true: value of the add_bridges kwarg of JuMP.set_optimizer.\n\nExamples\n\nIt's possible to define a single solver.\n\nusing JuMP, Clarabel, PortfolioOptimiser\nsolvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                        check_sol = (allow_local = true, allow_almost = true),\n                        params = Dict(\"verbose\" => false), add_bridges = false)\n\n# output\n\nPortOptSolver(:Clarabel, Clarabel.MOIwrapper.Optimizer, (allow_local = true, allow_almost = true), Dict{String, Bool}(\"verbose\" => 0), false)\n\nOr a collection of solvers.\n\nsolvers = [PortOptSolver(; name = :Clarabel_1, solver = Clarabel.Optimizer,\n                         check_sol = (allow_local = true, allow_almost = true),\n                         params = Dict(\"verbose\" => false, \"max_step_fraction\" => 0.8)),\n           # Provide solver with pre-attached attributes and no arguments \n           # for the `JuMP.is_solved_and_feasible` function.\n           PortOptSolver(; name = :Clarabel_2,\n                         solver = JuMP.optimizer_with_attributes(Clarabel.Optimizer,\n                                                                 \"max_step_fraction\" => 0.75),\n                         # Do not add JuMP bridges to JuMP.Model()\n                         add_bridges = false)]\n\n# output\n\n2-element Vector{PortOptSolver}:\n PortOptSolver(:Clarabel_1, Clarabel.MOIwrapper.Optimizer, (allow_local = true, allow_almost = true), Dict{String, Real}(\"verbose\" => false, \"max_step_fraction\" => 0.8), true)\n PortOptSolver(:Clarabel_2, MathOptInterface.OptimizerWithAttributes(Clarabel.MOIwrapper.Optimizer, Pair{MathOptInterface.AbstractOptimizerAttribute, Any}[MathOptInterface.RawOptimizerAttribute(\"max_step_fraction\") => 0.75]), NamedTuple(), nothing, false)\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#Fixing-non-positive-definite-matrices","page":"Fixing non-positive definite matrices","title":"Fixing non-positive definite matrices","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#Public","page":"Fixing non-positive definite matrices","title":"Public","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.NoPosdef","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.NoPosdef","text":"struct NoPosdef <: AbstractPosdefFix end\n\nNon positive definite matrices will not be fixed in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.PosdefNearest","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.PosdefNearest","text":"@kwdef mutable struct PosdefNearest <: AbstractPosdefFix\n    type::NearestCorrelationMatrix.NCMAlgorithm = NearestCorrelationMatrix.Newton(;\n                                                                                    tau = 1e-12)\nend\n\nDefines which type from NearestCorrelationMatrix to use in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.posdef_fix!-Tuple{PosdefNearest, AbstractMatrix}","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.posdef_fix!","text":"posdef_fix!(type::PosdefNearest, X::AbstractMatrix)\n\nOverload this for other posdef fix types.\n\n\n\n\n\n","category":"method"},{"location":"ParameterEstimation/PosdefFix/#Private","page":"Fixing non-positive definite matrices","title":"Private","text":"","category":"section"},{"location":"ParameterEstimation/PosdefFix/#PortfolioOptimiser.AbstractPosdefFix","page":"Fixing non-positive definite matrices","title":"PortfolioOptimiser.AbstractPosdefFix","text":"abstract type AbstractPosdefFix end\n\nAbstract type for subtyping types for fixing non positive definite matrices in posdef_fix!.\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-6/#Tracking-and-Turnover","page":"Tracking and Turnover","title":"Tracking and Turnover","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-6/","page":"Tracking and Turnover","title":"Tracking and Turnover","text":"These measure how far a portfolio deviates from a benchmark.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-6/#Tracking","page":"Tracking and Turnover","title":"Tracking","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-6/#PortfolioOptimiser.TrackingRM","page":"Tracking and Turnover","title":"PortfolioOptimiser.TrackingRM","text":"\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-6/#Turnover","page":"Tracking and Turnover","title":"Turnover","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-6/#PortfolioOptimiser.TurnoverRM","page":"Tracking and Turnover","title":"PortfolioOptimiser.TurnoverRM","text":"\n\n\n\n","category":"type"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#Example-3:-Mean-Risk-Optimisation-with-Factor-Models","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#1.-Download-data.","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"1. Download data.","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"using PortfolioOptimiser, TimeSeries, DataFrames, PrettyTables, Clarabel, HiGHS, YFinance,\n      GraphRecipes, StatsPlots, JuMP\n\n# Format for pretty tables.\nfmt1 = (v, i, j) -> begin\n    if j == 1\n        return Date(v)\n    else\n        return v\n    end\nend;\nfmt2 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v, digits=5))\" : v\n    end\nend;\nfmt3 = (v, i, j) -> begin\n    if j == 1\n        return v\n    else\n        return isa(v, Number) ? \"$(round(v*100, digits=2)) %\" : v\n    end\nend;\n\n# Convert prices to time array.\nfunction stock_price_to_time_array(x)\n    # Only get the keys that are not ticker or datetime.\n    coln = collect(keys(x))[3:end]\n    # Convert the dictionary into a matrix.\n    m = hcat([x[k] for k ∈ coln]...)\n    return TimeArray(x[\"timestamp\"], m, Symbol.(coln), x[\"ticker\"])\nend\n\n# Asset tickers.\nassets = sort!([\"AAPL\", \"ADI\", \"ADP\", \"AMGN\", \"AMZN\", \"BKNG\", \"CMCSA\", \"COST\", \"CSCO\",\n                \"GILD\", \"GOOG\", \"GOOGL\", \"HON\", \"ISRG\", \"LIN\", \"MAR\", \"META\", \"MRK\", \"MSFT\",\n                \"NFLX\", \"NVDA\", \"ORLY\", \"PANW\", \"QCOM\", \"SBUX\", \"T\", \"TMUS\", \"TSLA\", \"TXN\",\n                \"VRTX\"])\n# Factor tickers.\nfactors = sort!([\"MTUM\", \"QUAL\", \"SIZE\", \"USMV\", \"VLUE\", \"LRGF\", \"INTF\", \"GLOF\", \"EFAV\",\n                 \"EEMV\"])\n\ntickers = [assets; factors]\n\n# Prices date range.\nDate_0 = \"2019-01-01\"\nDate_1 = \"2025-01-31\"\n\n# Download the price data using YFinance.\nprices = get_prices.(tickers; startdt = Date_0, enddt = Date_1)\nprices = stock_price_to_time_array.(prices)\nprices = hcat(prices...)\ncidx = colnames(prices)[occursin.(r\"adj\", string.(colnames(prices)))]\nprices = prices[cidx]\nTimeSeries.rename!(prices, Symbol.(tickers))\npretty_table(prices[1:5]; formatters = fmt1)","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#2.-Estimating-Mean-Risk-Portfolios","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"2. Estimating Mean Risk Portfolios","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#2.1.-Factor-and-asset-statistics","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"2.1. Factor and asset statistics","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"In order to use factor models, we need to estimate how the factors and assets are related. The relationships are summarised by the loadings matrix, which is obtained via regression. For this basic tutorial we will use the defaults.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"This is a simple example so we will only use default parameters for computing the statistics.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"PortfolioOptimiser.MeanEstimator, PortfolioOptimiser.PortfolioOptimiserCovCor, FactorType, asset_statistics!, factor_statistics!.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"# Creating the portfolio object. Internally computes the returns if you give a prices TimeArray.\nport = Portfolio(; prices = prices[Symbol.(assets)], f_prices = prices[Symbol.(factors)],\n                 # Continuous solvers.\n                 solvers = PortOptSolver(; name = :Clarabel, solver = Clarabel.Optimizer,\n                                         params = Dict(\"verbose\" => false)),\n                 # Discrete solvers (for discrete allocation).\n                 alloc_solvers = PortOptSolver(; name = :HiGHS,\n                                               solver = optimizer_with_attributes(HiGHS.Optimizer,\n                                                                                  MOI.Silent() => true)))\n# Compute relevant statistics.\n# Expected returns, covariance estimation and factor estimation methods.\nmu_type = MuSimple()\ncov_type = PortCovCor()\nfactor_type = FactorType()\n\nasset_statistics!(port; mu_type = mu_type, cov_type = cov_type, set_kurt = false,\n                  set_skurt = false, set_skew = false, set_sskew = false)\nfactor_statistics!(port; factor_type = factor_type, cov_type = cov_type, mu_type = mu_type)\n\n# Show the loadings matrix.\npretty_table(port.loadings; formatters = fmt2)","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#2.2.-Optimise-Portfolios","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"2.2. Optimise Portfolios","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"# Creating the optimisation object.\nrm = SD() # Risk measure.\nobj = Sharpe() # Objective function. Can be `MinRisk()`, `Utility()`, `Sharpe()`, `MaxRet()`.\nclass = Classic()\n# `Trad` optimisation corresponds to the classic mean risk optimisation.\ntype = Trad(; rm = rm, obj = obj, class = class)\n# Classic portfolio.\nw1 = optimise!(port, type)\n# Factor model portfolio.\ntype.class = FM()\nw1.FM_weights = optimise!(port, type).weights\npretty_table(w1; formatters = fmt3)","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"Factor models tend to be less sensitive to noise, which makes them less prone to overfitting. There are many ways of estimating the loadings matrix, PortfolioOptimiser provides stepwise (explicit) and principal component (implicit) regression.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"We follow the API defined in MultivariateStats, so users can extend the package's compatibility. We will explore this capability in a future, more advanced tutorial.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/#2.3.-Efficient-Frontier","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"2.3. Efficient Frontier","text":"","category":"section"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"We can plot the efficient frontier for the factor model. Which will look different to the vanilla one.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"points = 50\nfrontier = efficient_frontier!(port, type; points = points)\npretty_table(frontier[:weights]; formatters = fmt3)","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"Plot frontier.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"plot_frontier(port; rm = rm)","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"Plot frontier area.","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"plot_frontier_area(port; rm = rm, kwargs_a = (; legendfontsize = 7))","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"","category":"page"},{"location":"examples/3_Mean_Risk_Optimisation_Factor_Models/","page":"Example 3: Mean Risk Optimisation with Factor Models","title":"Example 3: Mean Risk Optimisation with Factor Models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-3/#Downside","page":"Downside","title":"Downside","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-3/","page":"Downside","title":"Downside","text":"These measure different aspects of the tail (negative side) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures3-3/#Value-at-Risk","page":"Downside","title":"Value at Risk","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures3-3/#PortfolioOptimiser.VaR","page":"Downside","title":"PortfolioOptimiser.VaR","text":"mutable struct VaR{T1 <: Real} <: HCRiskMeasure\n\nbeginalign\nmathrmCVaRRG(bmX alphabeta) = mathrmCVaR(bmX alpha) - mathrmCVaR(-bmX beta)\nendalign\n\nWhere:\n\nmathrmCVaR(bmX alpha): is the Conditional Value at Risk as defined in CVaR.\nbmX: is the T×1 vector of portfolio returns.\nalpha: is the significance level of losses.\nbeta: is the significance level of gains.\n\nDescription\n\nDefines the Value at Risk.\n\nMeasures lower bound of the losses in the worst alpha % of cases.\nmathrmVaR(bmX alpha) leq mathrmCVaR(bmX alpha) leq mathrmEVaR(bmX alpha) leq mathrmRLVaR(bmX alpha kappa) leq mathrmWR(bmX).\n\nbeginalign\nmathrmVaR(bmX alpha) = -undersett in (0 T)inf left X_t in mathbbR    F_bmX(X_t)  alpha right\nendalign\n\nSee also: HCRiskMeasure, HCRMSettings, optimise!, expected_risk(::VaR, ::AbstractVector), CVaR, EVaR, RLVaR WR, DaR, DaR_r, CDaR, CDaR_r, EDaR, EDaR_r, RLDaR, RLDaR_r, MDD, MDD_r.\n\nProperties\n\nsettings::HCRMSettings = HCRMSettings(): configuration settings for the risk measure.\nalpha::T1 = 0.05: significance level, alpha ∈ (0, 1).\n\nBehaviour\n\nValidation\n\nWhen setting alpha at construction or runtime, alpha ∈ (0, 1).\n\nExamples\n\n# Default settings\nvar = VaR()\n\n# Custom significance level\nvar = VaR(; settings = HCRMSettings(; scale = 1.0), alpha = 0.01)\n\n\n\n\n\n","category":"type"},{"location":"RiskMeasures/RiskMeasures2-5/#Linear-moments","page":"Linear moments","title":"Linear moments","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-5/","page":"Linear moments","title":"Linear moments","text":"These measure different combinations of linear moments (L-moments) of the returns distribution.","category":"page"},{"location":"RiskMeasures/RiskMeasures2-5/#Ordered-Weight-Array-Risk-Measure","page":"Linear moments","title":"Ordered Weight Array Risk Measure","text":"","category":"section"},{"location":"RiskMeasures/RiskMeasures2-5/#PortfolioOptimiser.OWA","page":"Linear moments","title":"PortfolioOptimiser.OWA","text":"mutable struct OWA <: RiskMeasureOWA\n\nDescription\n\nDefines the generic Ordered Weight Array.\n\nUses a vector of ordered weights generated by owa_l_moment or owa_l_moment_crm for arbitrary L-moment optimisations.\n\nSee also: RiskMeasureOWA, RMSettings, Portfolio, optimise!, set_rm, expected_risk(::OWA, ::AbstractVector), owa_l_moment, owa_l_moment_crm.\n\nProperties\n\nsettings::RMSettings = RMSettings(): configuration settings for the risk measure.\nformulation::OWAFormulation = OWAApprox(): OWA risk measure settings.\nw::Union{<:AbstractWeights, Nothing} = nothing: T×1 ordered weight vector of arbitrary L-moments generated by owa_l_moment or owa_l_moment_crm.\n\nExamples\n\n\n\n\n\n","category":"type"}]
}
